// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UNIVERSELLE LV-GENERATOR VALIDIERUNG F√úR ALLE 21 GEWERKE
// Funktioniert ohne Gewerk-spezifische Hardcode-Regeln
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CRITICAL_PROMPT_ADDITIONS = `

// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë  üö® UNIVERSELLE VALIDIERUNGSREGELN F√úR ALLE GEWERKE üö®               ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

DIESE REGELN GELTEN F√úR ALLE 21 GEWERKE GLEICHERMASSEN:

1. UNIVERSELLE NEIN-REGEL:
   Wenn eine Antwort "nein", "keine", "nicht", "behalte alte", "√ºbersprungen" enth√§lt:
   ‚Üí KEINE Position daf√ºr erstellen, egal welches Gewerk!
   
2. UNIVERSELLE JA-REGEL:
   Wenn eine Antwort "ja" oder konkrete Angaben (Zahlen, Mengen) enth√§lt:
   ‚Üí Position MUSS erstellt werden
   
3. MATERIAL-REGEL:
   Das in der Antwort genannte Material MUSS 1:1 √ºbernommen werden
   Niemals eigenm√§chtig √§ndern!
   
4. MENGEN-REGEL:
   Zahlen in Antworten sind EXAKT zu √ºbernehmen
   
5. KEINE ERFINDUNGEN:
   NUR Positionen f√ºr explizit best√§tigte Leistungen
`;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UNIVERSELLE KEYWORD-EXTRAKTION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function extractKeywordsFromQuestion(question) {
  // Extrahiere Haupt-Keywords aus der Frage f√ºr universelle Anwendung
  const keywords = [];
  const q = question.toLowerCase();
  
  // Substantive die oft in Fragen vorkommen (gewerk-unabh√§ngig)
  const patterns = [
    // Allgemeine Bauteile
    /(\w*fenster\w*)/g, /(\w*t√ºr\w*)/g, /(\w*wand\w*)/g, /(\w*decke\w*)/g, /(\w*boden\w*)/g,
    /(\w*dach\w*)/g, /(\w*fassade\w*)/g, /(\w*treppe\w*)/g, /(\w*gel√§nder\w*)/g,
    
    // Installationen
    /(\w*heizung\w*)/g, /(\w*heizk\w*)/g, /(\w*rohr\w*)/g, /(\w*leitung\w*)/g,
    /(\w*steckdose\w*)/g, /(\w*schalter\w*)/g, /(\w*lampe\w*)/g, /(\w*armatur\w*)/g,
    
    // Materialien/Bel√§ge
    /(\w*fliese\w*)/g, /(\w*parkett\w*)/g, /(\w*laminat\w*)/g, /(\w*teppich\w*)/g,
    /(\w*putz\w*)/g, /(\w*farbe\w*)/g, /(\w*tapete\w*)/g, /(\w*estrich\w*)/g,
    
    // Zusatzausstattung
    /(\w*rolladen\w*)/g, /(\w*rollladen\w*)/g, /(\w*jalousie\w*)/g, /(\w*markise\w*)/g,
    /(\w*bank\w*)/g, /(\w*leiste\w*)/g, /(\w*profil\w*)/g, /(\w*abdichtung\w*)/g,
    
    // Arbeiten
    /(\w*montage\w*)/g, /(\w*demontage\w*)/g, /(\w*austausch\w*)/g, /(\w*erneuer\w*)/g,
    /(\w*sanier\w*)/g, /(\w*renovier\w*)/g, /(\w*d√§mmung\w*)/g, /(\w*isolier\w*)/g,
    
    // Sonstiges
    /(\w*ger√ºst\w*)/g, /(\w*reinigung\w*)/g, /(\w*entsorgung\w*)/g, /(\w*container\w*)/g,
    /(\w*leibung\w*)/g, /(\w*laibung\w*)/g, /(\w*sturz\w*)/g, /(\w*sockel\w*)/g
  ];
  
  patterns.forEach(pattern => {
    const matches = q.match(pattern);
    if (matches) {
      matches.forEach(match => {
        if (match.length > 2) keywords.push(match);
      });
    }
  });
  
  return [...new Set(keywords)]; // Duplikate entfernen
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UNIVERSELLE VALIDIERUNG
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function validateAndCleanLV(generatedLV, enrichedAnswers, uploadContext) {
  console.log('üîç Starting UNIVERSAL LV validation...');
  
  if (!generatedLV || !generatedLV.positions) {
    console.error('‚ùå Invalid LV structure');
    return generatedLV;
  }
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // SCHRITT 1: Antworten analysieren (universell)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  const forbiddenKeywords = new Set();
  const requiredItems = [];
  const specifications = {};
  
  // Konvertiere Antworten in einheitliches Format
  const answerList = [];
  
  if (Array.isArray(enrichedAnswers)) {
    enrichedAnswers.forEach(item => {
      answerList.push({
        question: (item.question || item.question_text || '').toLowerCase(),
        answer: (item.answer || item.answer_text || '').toLowerCase()
      });
    });
  } else if (typeof enrichedAnswers === 'object') {
    Object.entries(enrichedAnswers).forEach(([key, value]) => {
      answerList.push({
        question: key.toLowerCase(),
        answer: String(value).toLowerCase()
      });
    });
  }
  
  console.log(`üìä Processing ${answerList.length} answers`);
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // SCHRITT 2: NEIN-Antworten ‚Üí Verbotene Keywords
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  answerList.forEach(({question, answer}) => {
    const isNo = answer.includes('nein') || 
                 answer.includes('keine') || 
                 answer.includes('nicht') ||
                 answer.includes('behalte') ||
                 answer.includes('behalten') ||
                 answer.includes('√ºbersprungen') ||
                 answer === 'false' ||
                 answer === 'no';
    
    const isYes = answer.includes('ja') ||
                  answer === 'true' ||
                  answer === 'yes' ||
                  /\d+/.test(answer); // Enth√§lt Zahlen
    
    if (isNo) {
      // Extrahiere Keywords aus der FRAGE und blockiere sie
      const keywords = extractKeywordsFromQuestion(question);
      keywords.forEach(kw => {
        forbiddenKeywords.add(kw);
        // F√ºge auch Varianten hinzu
        if (kw.includes('fenster')) {
          forbiddenKeywords.add('fensterbank');
          forbiddenKeywords.add('fensterb√§nke');
        }
        if (kw.includes('roll')) {
          forbiddenKeywords.add('rollladen');
          forbiddenKeywords.add('rolladen');
          forbiddenKeywords.add('rolll√§den');
        }
        if (kw.includes('leibung') || kw.includes('laibung')) {
          forbiddenKeywords.add('leibung');
          forbiddenKeywords.add('laibung');
          forbiddenKeywords.add('leibungsverputz');
          forbiddenKeywords.add('laibungsverputz');
        }
      });
      console.log(`‚ùå NEIN f√ºr: ${keywords.join(', ')}`);
      
    } else if (isYes) {
      // Bei JA-Antworten: Merke was gefordert ist
      const keywords = extractKeywordsFromQuestion(question);
      if (keywords.length > 0) {
        requiredItems.push({
          keywords: keywords,
          answer: answer
        });
        console.log(`‚úÖ JA f√ºr: ${keywords.join(', ')}`);
      }
    }
    
    // Material/Spezifikationen extrahieren (universell)
    if (question.includes('material') || question.includes('ausf√ºhrung') || 
        question.includes('typ') || question.includes('farbe')) {
      // Speichere die Antwort als Spezifikation
      const key = question.split(' ')[0]; // Erstes Wort als Key
      specifications[key] = answer;
    }
    
    // Mengen extrahieren (universell)
    const mengenMatch = answer.match(/(\d+)\s*(\w+)?/);
    if (mengenMatch && !isNo) {
      const anzahl = parseInt(mengenMatch[1]);
      const einheit = mengenMatch[2] || '';
      
      // Finde zugeh√∂riges Keyword aus der Frage
      const keywords = extractKeywordsFromQuestion(question);
      if (keywords.length > 0) {
        specifications[keywords[0] + '_menge'] = anzahl;
        console.log(`üìã Menge: ${keywords[0]} = ${anzahl}`);
      }
    }
  });
  
  // Spezialfall: "Zustand gut" bedeutet keine Arbeiten
  answerList.forEach(({question, answer}) => {
    if (question.includes('zustand') && (answer.includes('gut') || answer.includes('ok'))) {
      const keywords = extractKeywordsFromQuestion(question);
      keywords.forEach(kw => {
        forbiddenKeywords.add(kw);
        forbiddenKeywords.add(kw + 'arbeiten');
        forbiddenKeywords.add(kw + 'erneuerung');
      });
      console.log(`‚ùå Zustand GUT: keine Arbeiten f√ºr ${keywords.join(', ')}`);
    }
  });
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // SCHRITT 3: LV-Positionen validieren
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  let removedCount = 0;
  let correctedCount = 0;
  const originalCount = generatedLV.positions.length;
  
  generatedLV.positions = generatedLV.positions.filter(pos => {
    const posText = `${pos.title || ''} ${pos.description || ''}`.toLowerCase();
    
    // Pr√ºfe gegen verbotene Keywords
    for (const forbidden of forbiddenKeywords) {
      if (forbidden.length > 2 && posText.includes(forbidden)) {
        console.log(`üóëÔ∏è ENTFERNT: "${pos.title}" (verboten: ${forbidden})`);
        removedCount++;
        return false;
      }
    }
    
    // Mengen-Korrektur basierend auf specifications
    Object.entries(specifications).forEach(([key, value]) => {
      if (key.endsWith('_menge') && typeof value === 'number') {
        const itemType = key.replace('_menge', '');
        if (posText.includes(itemType) && pos.quantity > value) {
          console.log(`‚úèÔ∏è Menge korrigiert: ${pos.quantity} ‚Üí ${value}`);
          pos.quantity = value;
          correctedCount++;
        }
      }
    });
    
    return true;
  });
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // SCHRITT 4: Absurde Preise korrigieren (universell)
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  generatedLV.positions.forEach(pos => {
    const posText = `${pos.title || ''} ${pos.description || ''}`.toLowerCase();
    
    // Universelle Preis-Plausibilit√§t
    const priceChecks = [
      { keywords: ['leibung', 'laibung'], unit: 'm', maxPrice: 100, newPrice: 45 },
      { keywords: ['reinigung', 'endreinigung'], unit: null, maxPrice: 100, newPrice: 35 },
      { keywords: ['aufma√ü', 'vermessung'], unit: null, maxPrice: 200, newPrice: 75 },
      { keywords: ['abdichtung', 'verfugung'], unit: 'm', maxPrice: 80, newPrice: 35 },
      { keywords: ['grundierung'], unit: 'm¬≤', maxPrice: 30, newPrice: 12 },
      { keywords: ['sockelleiste'], unit: 'm', maxPrice: 50, newPrice: 20 },
      { keywords: ['√ºbergang', 'profil'], unit: 'm', maxPrice: 60, newPrice: 25 }
    ];
    
    priceChecks.forEach(check => {
      if (check.keywords.some(kw => posText.includes(kw))) {
        if (!check.unit || pos.unit === check.unit || pos.unit === 'lfm') {
          if (pos.unitPrice > check.maxPrice) {
            console.log(`üí∞ PREIS: ${pos.title} ${pos.unitPrice}‚Ç¨ ‚Üí ${check.newPrice}‚Ç¨`);
            pos.unitPrice = check.newPrice;
            correctedCount++;
          }
        }
      }
    });
    
    // Gesamtpreis neu berechnen
    if (pos.quantity && pos.unitPrice) {
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
    }
  });
  
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  // ZUSAMMENFASSUNG
  // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  console.log('üìä UNIVERSELLE VALIDIERUNG ABGESCHLOSSEN:');
  console.log(`üìÑ Gewerk: ${generatedLV.tradeCode || 'Unbekannt'}`);
  console.log(`‚úÖ Positionen behalten: ${generatedLV.positions.length}`);
  console.log(`üóëÔ∏è Positionen entfernt: ${removedCount}`);
  console.log(`‚úèÔ∏è Positionen korrigiert: ${correctedCount}`);
  
  if (forbiddenKeywords.size > 0) {
    console.log('\nBlockierte Keywords:', Array.from(forbiddenKeywords).slice(0, 10).join(', '));
  }
  
  console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
  
  return generatedLV;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ERWEITERTE VALIDIERUNG MIT UPLOAD-ENFORCEMENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function validateAndCleanLVComplete(generatedLV, enrichedAnswers, uploadContext) {
  // Basis-Validierung
  let validatedLV = validateAndCleanLV(generatedLV, enrichedAnswers, uploadContext);
  
  // Upload-Enforcement wenn verf√ºgbar
  try {
    const { enforceUploadData } = require('./upload-data-enforcement');
    if (typeof enforceUploadData === 'function') {
      validatedLV = enforceUploadData(validatedLV, uploadContext, enrichedAnswers);
    }
  } catch (e) {
    // Upload-Enforcement nicht verf√ºgbar
  }
  
  // Fenster/T√ºren-Preiskorrektur wenn verf√ºgbar
  try {
    const { applyWindowPriceCorrection } = require('./fenster-preis-korrektur');
    if (typeof applyWindowPriceCorrection === 'function') {
      if (validatedLV.tradeCode === 'FEN' || validatedLV.tradeCode === 'TIS') {
        validatedLV = applyWindowPriceCorrection(validatedLV, validatedLV.tradeCode);
      }
    }
  } catch (e) {
    // Preiskorrektur nicht verf√ºgbar
  }
  
  return validatedLV;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EXPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

module.exports = {
  CRITICAL_PROMPT_ADDITIONS,
  validateAndCleanLV,
  validateAndCleanLVComplete
};
