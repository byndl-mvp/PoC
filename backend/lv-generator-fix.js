// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LLM-BASIERTE LV-VALIDIERUNG
// Nutzt KI zur intelligenten Validierung statt komplexer Hardcode-Regeln
// Optimiert f√ºr Claude Haiku - schnell und pr√§zise
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CRITICAL_PROMPT_ADDITIONS = `
// ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
// ‚ïë  üö® ABSOLUTE PRIORIT√ÑT: ANTWORTEN 1:1 UMSETZEN üö®                    ‚ïë
// ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

KRITISCHE REGELN:
1. NEIN-Antworten = KEINE Position daf√ºr erstellen
2. Material EXAKT wie angegeben verwenden
3. Mengen EXAKT √ºbernehmen
4. NUR Positionen f√ºr JA-Antworten oder konkret genannte Leistungen
`;

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// LLM-VALIDIERUNG MIT HAIKU
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function validateLVWithLLM(generatedLV, enrichedAnswers, anthropic) {
  console.log('ü§ñ Starte LLM-basierte LV-Validierung mit Haiku...');
  
  // Bereite Antworten f√ºr LLM auf
  const answersText = enrichedAnswers.map(item => {
    const question = item.question || item.question_text || '';
    const answer = item.answer || item.answer_text || '';
    return `FRAGE: ${question}\nANTWORT: ${answer}`;
  }).join('\n\n');
  
  // Bereite LV-Positionen f√ºr LLM auf
  const positionsText = generatedLV.positions.map((pos, idx) => 
    `Position ${idx + 1}: ${pos.title}\nBeschreibung: ${pos.description}\nMenge: ${pos.quantity} ${pos.unit}\nPreis: ${pos.unitPrice}‚Ç¨`
  ).join('\n\n');
  
  const validationPrompt = `Du bist ein LV-Korrektur-Experte. Korrigiere NUR offensichtliche Fehler bei der √úbernahme von Nutzerantworten.

NUTZERANTWORTEN:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${answersText}

AKTUELLES LV:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${positionsText}

PR√úFSCHEMA - SCHRITT F√úR SCHRITT:
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

‚ö†Ô∏è WICHTIG: Nur EINDEUTIGE Fehler korrigieren! Im Zweifel NICHTS √§ndern!
Wenn das LV plausibel aussieht ‚Üí KEINE √Ñnderungen vornehmen!

1. NEIN-ANTWORTEN PR√úFEN:
   Nur wenn EXPLIZIT "nein", "keine", "behalte alte" in der Antwort steht
   ‚Üí Pr√ºfe ob trotzdem Positionen daf√ºr im LV sind ‚Üí ENTFERNEN
   
   ABER: "Gut - keine Sch√§den" bedeutet NICHT "keine Leibungen"!
   ABER: Fehlende Frage bedeutet NICHT automatisch NEIN!

2. MATERIAL-ABGLEICH:
   NUR wenn Material EXPLIZIT genannt und ANDERS im LV
   
   EINDEUTIG FALSCH:
   - Antwort: "Holz" ‚Üí LV: "Kunststofffenster" ‚úó
   - Antwort: "Laminat" ‚Üí LV: "Parkettboden" ‚úó
   
   NICHT √ÑNDERN:
   - Antwort nennt kein Material ‚Üí LV hat Material ‚úì
   - Antwort: "Standard" ‚Üí LV hat spezifisches Material ‚úì

3. MENGEN-ABGLEICH:
   NUR bei EINDEUTIGER Diskrepanz
   - Antwort: "24 Rolll√§den" ‚Üí LV: "36 Rolll√§den" = KORRIGIEREN
   - Antwort: "ca. 20-25" ‚Üí LV: "24" = OK, NICHT √§ndern

4. PREIS-PLAUSIBILIT√ÑT - NUR ABSURDE AUSREISSER:
   Suche Antworten mit: "nein", "keine", "nicht", "behalte alte", "√ºbersprungen", "entf√§llt"
   ‚Üí Pr√ºfe ob trotzdem Positionen daf√ºr im LV sind ‚Üí ENTFERNEN
   
   Typische NEIN-Positionen:
   - Fensterb√§nke, Leibungen, Rolll√§den, Jalousien (Fenster)
   - Armaturen, Duschkabinen (Sanit√§r)
   - Steckdosen, Schalter (Elektro)
   - Sockelleisten, √úbergangsprofile (Boden)
   - Tapeten, Anstrich (Maler)

2. MATERIAL-ABGLEICH:
   Vergleiche Material in Antwort vs. LV-Position
   
   Fenster/T√ºren: Holz ‚â† Kunststoff ‚â† Aluminium ‚â† Holz-Alu
   B√∂den: Parkett ‚â† Laminat ‚â† Vinyl ‚â† Fliesen
   Sanit√§r: Keramik ‚â† Acryl ‚â† Stahl-Email
   W√§nde: Tapete ‚â† Putz ‚â† Anstrich

3. MENGEN-ABGLEICH:
   Zahl in Antwort muss mit Menge im LV √ºbereinstimmen
   - "24 Rolll√§den" ‚Üí LV muss 24 haben, nicht 36
   - "120 m¬≤" ‚Üí LV muss 120 haben, nicht 150
   - "6 Fenster" ‚Üí LV muss 6 haben, nicht 10

4. PREIS-PLAUSIBILIT√ÑT - NUR ABSURDE AUSREISSER:
   
   OFFENSICHTLICH ZU HOCH:
   - Leibungsverputz > 100‚Ç¨/lfm (normal: 30-60‚Ç¨)
   - Fensterreinigung > 100‚Ç¨/Stk (normal: 15-40‚Ç¨)
   - Abdichtung > 100‚Ç¨/lfm (normal: 20-50‚Ç¨)
   - Aufma√ü/Vermessung > 200‚Ç¨ pauschal (normal: 50-100‚Ç¨)
   - Innent√ºr > 2000‚Ç¨ (normal: 300-900‚Ç¨)
   - Steckdose > 200‚Ç¨ (normal: 30-80‚Ç¨)
   - Anstrich > 100‚Ç¨/m¬≤ (normal: 8-30‚Ç¨)
   - Sockelleiste > 50‚Ç¨/lfm (normal: 10-25‚Ç¨)
   
   FAUSTREGEL: Wenn der Preis mehr als 3x √ºber dem Normalwert liegt ‚Üí KORRIGIEREN
   
   NICHT √ÑNDERN:
   - Hauptpositionen (Fenster, T√ºren, Sanit√§robjekte) - diese sind meist OK
   - Demontage/Entsorgung - Preise variieren stark
   - Komplettleistungen - schwer zu beurteilen

5. WAS NICHT √ÑNDERN:
   ‚úì Demontage/Entsorgung (immer notwendig)
   ‚úì Abdichtung/Anschlussarbeiten (technisch erforderlich)
   ‚úì Reinigung/Endreinigung (Standard)
   ‚úì Grundierung/Vorarbeiten (fachlich korrekt)
   ‚úì Untergrund vorbereiten (notwendig)

JSON-ANTWORT (NUR DIES, NICHTS ANDERES):

WENN KEINE FEHLER GEFUNDEN:
{
  "positionen_zu_entfernen": [],
  "positionen_zu_korrigieren": [],
  "preiskorrekturen": [],
  "zusammenfassung": "LV ist korrekt, keine √Ñnderungen notwendig"
}

WENN FEHLER GEFUNDEN:
{
  "positionen_zu_entfernen": [
    {
      "position_nummer": X,
      "grund": "Kurzer EINDEUTIGER Grund"
    }
  ],
  "positionen_zu_korrigieren": [
    {
      "position_nummer": Y,
      "korrektur": {
        "material": "Neu statt Alt",
        "menge": "Richtig statt Falsch",
        "preis": "Realistisch statt Absurd"
      },
      "grund": "Kurzer EINDEUTIGER Grund"
    }
  ],
  "preiskorrekturen": [
    {
      "position_nummer": Z,
      "alter_preis": XXX,
      "neuer_preis": YY,
      "grund": "Zu hoch/niedrig f√ºr [Position]"
    }
  ],
  "zusammenfassung": "Nur die TATS√ÑCHLICHEN Hauptfehler"
}`;

  try {
    const response = await anthropic.messages.create({
      model: 'claude-haiku-4-5-20251001',  // Haiku f√ºr Speed
      max_tokens: 2000,
      temperature: 0,
      messages: [{
        role: 'user',
        content: validationPrompt
      }]
    });
    
    // Parse JSON Response
    let validationResult;
    try {
      // Extrahiere JSON aus der Antwort (falls Text drumherum)
      const jsonMatch = response.content[0].text.match(/\{[\s\S]*\}/);
      if (jsonMatch) {
        validationResult = JSON.parse(jsonMatch[0]);
      } else {
        validationResult = JSON.parse(response.content[0].text);
      }
    } catch (parseError) {
      console.error('‚ùå JSON Parse Fehler:', parseError.message);
      console.log('Raw Response:', response.content[0].text);
      // Fallback auf einfache Validierung
      return simpleValidation(generatedLV, enrichedAnswers);
    }
    
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // ANWENDUNG DER VALIDIERUNGSERGEBNISSE
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    console.log('üìã LLM-Validierung abgeschlossen:');
    console.log(`- ${validationResult.positionen_zu_entfernen?.length || 0} zu entfernen`);
    console.log(`- ${validationResult.positionen_zu_korrigieren?.length || 0} zu korrigieren`);
    console.log(`- ${validationResult.preiskorrekturen?.length || 0} Preise zu korrigieren`);
    
    // 1. Positionen entfernen
    if (validationResult.positionen_zu_entfernen?.length > 0) {
      const zuEntfernen = new Set(validationResult.positionen_zu_entfernen.map(p => p.position_nummer - 1));
      generatedLV.positions = generatedLV.positions.filter((pos, idx) => {
        if (zuEntfernen.has(idx)) {
          console.log(`üóëÔ∏è Entferne: ${pos.title} - ${validationResult.positionen_zu_entfernen.find(p => p.position_nummer === idx + 1)?.grund}`);
          return false;
        }
        return true;
      });
    }
    
    // 2. Positionen korrigieren
    if (validationResult.positionen_zu_korrigieren?.length > 0) {
      validationResult.positionen_zu_korrigieren.forEach(korrektur => {
        const idx = korrektur.position_nummer - 1;
        if (generatedLV.positions[idx]) {
          const pos = generatedLV.positions[idx];
          
          if (korrektur.korrektur.material) {
            const parts = korrektur.korrektur.material.split(' statt ');
            if (parts.length === 2) {
              const [zu, von] = parts;
              pos.title = pos.title.replace(new RegExp(von, 'gi'), zu);
              pos.description = pos.description.replace(new RegExp(von, 'gi'), zu);
              console.log(`‚úèÔ∏è Material korrigiert: ${von} ‚Üí ${zu}`);
            }
          }
          
          if (korrektur.korrektur.menge) {
            const [neu] = korrektur.korrektur.menge.split(' statt ');
            pos.quantity = parseInt(neu) || pos.quantity;
            console.log(`‚úèÔ∏è Menge korrigiert: ‚Üí ${neu}`);
          }
          
          if (korrektur.korrektur.preis) {
            const [neu] = korrektur.korrektur.preis.split(' statt ');
            pos.unitPrice = parseFloat(neu) || pos.unitPrice;
            console.log(`‚úèÔ∏è Preis korrigiert: ‚Üí ${neu}‚Ç¨`);
          }
        }
      });
    }
    
    // 3. Preiskorrekturen anwenden
    if (validationResult.preiskorrekturen?.length > 0) {
      validationResult.preiskorrekturen.forEach(korrektur => {
        const idx = korrektur.position_nummer - 1;
        if (generatedLV.positions[idx]) {
          const pos = generatedLV.positions[idx];
          console.log(`üí∞ Preis korrigiert: ${pos.title} - ${korrektur.alter_preis}‚Ç¨ ‚Üí ${korrektur.neuer_preis}‚Ç¨ (${korrektur.grund})`);
          pos.unitPrice = korrektur.neuer_preis;
          
          // Gesamtpreis neu berechnen
          if (pos.quantity) {
            pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
          }
        }
      });
    }
    
    if (validationResult.zusammenfassung) {
      console.log('\nüìä Zusammenfassung:', validationResult.zusammenfassung);
    }
    
  } catch (error) {
    console.error('‚ùå LLM-Validierung fehlgeschlagen:', error.message);
    // Fallback auf einfache Validierung
    return simpleValidation(generatedLV, enrichedAnswers);
  }
  
  return generatedLV;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EINFACHE FALLBACK-VALIDIERUNG
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function simpleValidation(generatedLV, enrichedAnswers) {
  console.log('üìã Fallback auf einfache Validierung...');
  
  const neinAntworten = new Set();
  const material = {};
  const mengen = {};
  
  enrichedAnswers.forEach(item => {
    const answer = (item.answer || '').toLowerCase();
    const question = (item.question || '').toLowerCase();
    
    // NEIN-Antworten sammeln
    if (answer.includes('nein') || answer.includes('keine') || answer.includes('behalte alte')) {
      if (question.includes('fensterbank')) neinAntworten.add('fensterbank');
      if (question.includes('leibung') || question.includes('laibung')) {
        neinAntworten.add('leibung');
        neinAntworten.add('laibung');
      }
      if (question.includes('rollladen') || question.includes('rolladen')) {
        neinAntworten.add('rollladen');
        neinAntworten.add('rolladen');
      }
      if (question.includes('ger√ºst')) neinAntworten.add('ger√ºst');
      if (question.includes('stundenlohn')) neinAntworten.add('stundenlohn');
    }
    
    // Material extrahieren
    if (question.includes('material')) {
      if (answer.includes('holz') && !answer.includes('alu')) material.type = 'holz';
      else if (answer.includes('kunststoff') || answer.includes('pvc')) material.type = 'kunststoff';
      else if (answer.includes('aluminium') || answer.includes('alu')) material.type = 'aluminium';
    }
    
    // Mengen extrahieren
    const zahlenMatch = answer.match(/(\d+)/);
    if (zahlenMatch) {
      const zahl = parseInt(zahlenMatch[1]);
      if (question.includes('rolll√§den')) mengen.rolllaeden = zahl;
      if (question.includes('fenster') && question.includes('wie viele')) mengen.fenster = zahl;
    }
  });
  
  // Filtere Positionen
  let removed = 0;
  generatedLV.positions = generatedLV.positions.filter(pos => {
    const text = `${pos.title} ${pos.description}`.toLowerCase();
    
    // Pr√ºfe gegen NEIN-Antworten
    for (const verboten of neinAntworten) {
      if (text.includes(verboten)) {
        console.log(`üóëÔ∏è Entfernt: ${pos.title} (${verboten} war NEIN)`);
        removed++;
        return false;
      }
    }
    
    // Korrigiere Mengen
    if (mengen.rolllaeden && text.includes('rollladen')) {
      if (pos.quantity > mengen.rolllaeden) {
        console.log(`‚úèÔ∏è Rolll√§den-Menge korrigiert: ${pos.quantity} ‚Üí ${mengen.rolllaeden}`);
        pos.quantity = mengen.rolllaeden;
      }
    }
    
    return true;
  });
  
  console.log(`üìä Einfache Validierung: ${removed} Positionen entfernt`);
  
  return generatedLV;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// HAUPT-VALIDIERUNGSFUNKTION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function validateAndCleanLVComplete(generatedLV, enrichedAnswers, uploadContext, anthropic) {
  // Erst LLM-Validierung versuchen
  let validatedLV = generatedLV;
  
  if (anthropic) {
    validatedLV = await validateLVWithLLM(generatedLV, enrichedAnswers, anthropic);
  } else {
    console.log('‚ö†Ô∏è Kein Anthropic Client verf√ºgbar, nutze einfache Validierung');
    validatedLV = simpleValidation(generatedLV, enrichedAnswers);
  }
  
  // Dann Upload-Enforcement (falls vorhanden)
  try {
    const { enforceUploadData } = require('./upload-data-enforcement');
    if (typeof enforceUploadData === 'function') {
      validatedLV = enforceUploadData(validatedLV, uploadContext, enrichedAnswers);
    }
  } catch (e) {
    // Upload-Enforcement nicht verf√ºgbar
  }
  
  // Gesamtpreise neu berechnen
  validatedLV.positions.forEach(pos => {
    if (pos.quantity && pos.unitPrice) {
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
    }
  });
  
  return validatedLV;
}

// Sync-Version f√ºr Kompatibilit√§t (ruft intern async auf)
function validateAndCleanLV(generatedLV, enrichedAnswers, uploadContext) {
  return simpleValidation(generatedLV, enrichedAnswers);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EXPORT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

module.exports = {
  CRITICAL_PROMPT_ADDITIONS,
  validateAndCleanLVComplete,
  validateAndCleanLV,
  validateLVWithLLM,
  simpleValidation
};
