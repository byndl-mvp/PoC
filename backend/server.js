/*
 * BYNDL Proof of Concept – Backend v4.0
 * 
 * HAUPTVERBESSERUNGEN:
 * - Intelligente Fragenanzahl basierend auf Gewerke-Komplexität
 * - Detaillierte Mengenerfassung mit Validierung
 * - Keine erfundenen LV-Positionen - nur explizit erfragte
 * - Laienverständliche Fragen mit Erläuterungen
 * - Intelligente Schätzlogik bei unsicheren Angaben
 * - Realistische Preiskalkulationen
 */

const { query } = require('./db.js');
const fs = require('fs');
const path = require('path');
const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');  // oder require('bcrypt')
const crypto = require('crypto');  // Für Reset-Token
const PDFDocument = require('pdfkit');
require('dotenv').config({ path: path.join(__dirname, '.env') });
const multer = require('multer');
const pdf = require('pdf-parse');
const xlsx = require('xlsx');
const sharp = require('sharp');
const { analyzeImageWithClaude } = require('./imageAnalysis');
const { parseSpreadsheetContent } = require('./spreadsheetParser');
const { analyzePdfWithClaude } = require('./pdfAnalyzer');
const nodemailer = require('nodemailer');
const emailService = require('./emailService');
const OpenAI = require("openai");
const Anthropic = require("@anthropic-ai/sdk");

// ===========================================================================
// FILE UPLOAD CONFIGURATION
// ===========================================================================
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { 
    fileSize: 10 * 1024 * 1024  // 10MB
  },
  fileFilter: (req, file, cb) => {
    const allowedTypes = [
      'image/jpeg',
      'image/png',
      'image/jpg',
      'image/webp',
      'application/pdf',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'application/vnd.ms-excel',
      'text/csv'
    ];
    
    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error(`Dateityp ${file.mimetype} nicht unterstützt`), false);
    }
  }
});

// Irgendwo vor den Routes:
const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: process.env.SMTP_PORT || 587,
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY,
});

function formatCurrency(amount) {
  if (!amount && amount !== 0) return '0 €';
  return new Intl.NumberFormat('de-DE', {
    style: 'currency',
    currency: 'EUR'
  }).format(amount);
}

// Modellnamen aus Umgebungsvariablen
const MODEL_OPENAI = process.env.MODEL_OPENAI || process.env.OPENAI_MODEL || 'gpt-4.1-mini';
const MODEL_ANTHROPIC_QUESTIONS = process.env.MODEL_ANTHROPIC_QUESTIONS || process.env.ANTHROPIC_MODEL_QUESTIONS || 'claude-sonnet-4-5-20250929';
const MODEL_ANTHROPIC_LV = process.env.MODEL_ANTHROPIC_LV || process.env.ANTHROPIC_MODEL_LV || 'claude-opus-4-1-20250805';

// ===========================================================================
// GEWERKE-KOMPLEXITÄT DEFINITIONEN (KORREKTE CODES)
// ===========================================================================

const TRADE_COMPLEXITY = {
  // Sehr komplexe Gewerke (25-40 Fragen)
  DACH:  { complexity: 'SEHR_HOCH', minQuestions: 20, maxQuestions: 28, targetPositionsRatio: 0.9 },
  ELEKT: { complexity: 'SEHR_HOCH', minQuestions: 18, maxQuestions: 26, targetPositionsRatio: 0.9 },
  SAN:   { complexity: 'SEHR_HOCH', minQuestions: 18, maxQuestions: 26, targetPositionsRatio: 0.85 },
  HEI:   { complexity: 'SEHR_HOCH', minQuestions: 18, maxQuestions: 26, targetPositionsRatio: 0.8 },
  KLIMA: { complexity: 'SEHR_HOCH', minQuestions: 18, maxQuestions: 22, targetPositionsRatio: 0.8 },
  ROH:   { complexity: 'SEHR_HOCH', minQuestions: 18, maxQuestions: 28, targetPositionsRatio: 0.9 },
  
  // Komplexe Gewerke (20-30 Fragen)
  TIS:   { complexity: 'HOCH', minQuestions: 17, maxQuestions: 25, targetPositionsRatio: 1.0 }, // Türen: oft 1:1
  FEN:   { complexity: 'HOCH', minQuestions: 18, maxQuestions: 26, targetPositionsRatio: 1.0 }, // Fenster: oft 1:1
  FASS:  { complexity: 'HOCH', minQuestions: 18, maxQuestions: 26, targetPositionsRatio: 0.9 },
  SCHL:  { complexity: 'HOCH', minQuestions: 15, maxQuestions: 22, targetPositionsRatio: 0.8 },
  PV:    { complexity: 'HOCH', minQuestions: 15, maxQuestions: 22, targetPositionsRatio: 0.8 },
  ZIMM:  { complexity: 'HOCH', minQuestions: 15, maxQuestions: 25, targetPositionsRatio: 0.8 },

  // Mittlere Komplexität (15-20 Fragen)
  FLI:   { complexity: 'MITTEL', minQuestions: 16, maxQuestions: 20, targetPositionsRatio: 0.8 },
  ESTR:  { complexity: 'MITTEL', minQuestions: 12, maxQuestions: 17, targetPositionsRatio: 0.7 },
  TRO:   { complexity: 'MITTEL', minQuestions: 15, maxQuestions: 22, targetPositionsRatio: 0.8 },
  BOD:   { complexity: 'MITTEL', minQuestions: 15, maxQuestions: 22, targetPositionsRatio: 0.8 },
  AUSS:  { complexity: 'MITTEL', minQuestions: 15, maxQuestions: 22, targetPositionsRatio: 0.8 },

  // Einfache Gewerke (8-18 Fragen)
  MAL:   { complexity: 'EINFACH', minQuestions: 12,  maxQuestions: 18, targetPositionsRatio: 0.8 },
  GER:   { complexity: 'EINFACH', minQuestions: 8,  maxQuestions: 12, targetPositionsRatio: 0.8 },
  ABBR:  { complexity: 'EINFACH', minQuestions: 12, maxQuestions: 17, targetPositionsRatio: 0.8 },

  // Intake ist speziell (18-26 Fragen)
  INT:   { complexity: 'INTAKE', minQuestions: 18, maxQuestions: 26, targetPositionsRatio: 0.0 }
};

// Fallback für nicht definierte Gewerke
const DEFAULT_COMPLEXITY = { 
  complexity: 'MITTEL', 
  minQuestions: 14, 
  maxQuestions: 22,
  targetPositionsRatio: 0.75  // NEU: Ratio hinzufügen
};

// ===========================================================================
// HELPER FUNCTIONS
// ===========================================================================

/**
 * Erweiterte LLM-Policy mit robuster Fehlerbehandlung
 */
async function llmWithPolicy(task, messages, options = {}) {
  const defaultMaxTokens = {
    'detect': 3000,      
    'questions': 10000,   
    'lv': 16000,         
    'intake': 10000,      
    'summary': 3000,
    'validation': 3000,
    'clarification': 1000, // NEU: Für Rückfragen
    'context': 8000       // NEU: Für Kontext-basierte Fragen
  };
  
  const maxTokens = options.maxTokens || defaultMaxTokens[task] || 4000;
  
  const defaultTimeouts = {
    'questions': 90000,  
    'lv': 120000,        
    'intake': 90000,     
    'optimization': 60000,
    'clarification': 30000, // NEU: Rückfragen sind schneller
    'context': 60000,       // NEU: Kontext-Fragen
    'default': 45000     
  };
  
  if (!options.timeout) {
    options.timeout = defaultTimeouts[task] || defaultTimeouts.default;
    console.log(`[LLM] Setting timeout for ${task}: ${options.timeout}ms`);
  }
  
  // Optimization-Task mit Claude als Haupt-LLM, OpenAI als Fallback
if (task === 'optimization') {
  console.log('[LLM] Optimization task - using Claude with OpenAI fallback');
  
  try {
    // Primär: Claude verwenden
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: options.maxTokens || 12000,
      temperature: options.temperature || 0.35,
      messages: messages.map(msg => ({
        role: msg.role === 'system' ? 'user' : msg.role,
        content: msg.content
      }))
    });
    
    return response.content[0].text;
    
  } catch (claudeError) {
    console.error('[LLM] Claude failed for optimization, trying OpenAI fallback:', claudeError.message);
    
    // Fallback: OpenAI
    try {
      const response = await openai.chat.completions.create({
        model: MODEL_OPENAI,
        messages,
        temperature: options.temperature || 0.3,
        max_tokens: options.maxTokens || 4000,
        response_format: { type: "json_object" }
      });
      return response.choices[0].message.content;
    } catch (openaiError) {
      console.error('[LLM] Both Claude and OpenAI failed for optimization');
      throw openaiError;
    }
  }
}
  
  // DEBUG: Log prompt sizes for questions task
  if (task === 'questions' || task === 'intake') {
    const systemMsg = messages.find(m => m.role === 'system');
    const userMsg = messages.find(m => m.role === 'user');
    
    console.log(`[LLM-DEBUG] Task: ${task}`);
    console.log(`[LLM-DEBUG] System prompt length: ${systemMsg?.content?.length || 0} chars`);
    console.log(`[LLM-DEBUG] User prompt length: ${userMsg?.content?.length || 0} chars`);
    
    if (systemMsg?.content?.length > 32000) {
      console.log(`[LLM-DEBUG] ⚠️ System prompt exceeds Anthropic limit!`);
    }
  }
  
  const temperature = options.temperature !== undefined ? options.temperature : 0.4;
  
  // NEU: Modell-Selektion basierend auf Task
  const getAnthropicModel = (task) => {
    if (task === 'lv') {
      // Claude Opus für LV-Generierung
      return MODEL_ANTHROPIC_LV || MODEL_ANTHROPIC || 'claude-sonnet-4-5-20250929';
    }
    // Claude Sonnet für alle anderen Tasks
    return MODEL_ANTHROPIC_QUESTIONS || MODEL_ANTHROPIC || 'claude-sonnet-4-5-20250929';
  };
  
  // GEÄNDERT: Anthropic als primärer Provider für ALLE Tasks
  const primaryProvider = 'anthropic';
  
  // OpenAI als Fallback bleibt unverändert
  const callOpenAI = async () => {
    try {
      const useJsonMode = options.jsonMode;
      
      const response = await openai.chat.completions.create({
        model: MODEL_OPENAI,
        messages,
        temperature,
        max_tokens: Math.min(maxTokens, 16384),
        response_format: useJsonMode ? { type: "json_object" } : undefined
      });
      return response.choices[0].message.content;
    } catch (error) {
      console.error('[LLM] OpenAI error:', error.status || error.message);
      throw error;
    }
  };

  // Unicode-Bereinigung für Anthropic
  function cleanUnicodeForAnthropic(text) {
    if (!text) return '';
    
    return text
      .normalize('NFC')
      .replace(/[\uD800-\uDFFF]/g, '')
      .replace(/[\u0000-\u001F\u007F-\u009F]/g, ' ')
      .replace(/[\uFFFD]/g, '')
      .trim();
  }
  
  // GEÄNDERT: Claude mit task-spezifischem Modell
  const callClaude = async () => {
    try {
      // Wähle das richtige Modell basierend auf Task
      const modelToUse = getAnthropicModel(task);
      
      console.log(`[LLM-CLAUDE] Using model ${modelToUse} for task: ${task}`);
      
      let systemMessage = messages.find(m => m.role === "system")?.content || "";
      const originalUserMessages = messages.filter(m => m.role === "user");
      
      // BEREINIGE Unicode
      systemMessage = cleanUnicodeForAnthropic(systemMessage);
      const cleanedUserMessages = originalUserMessages.map(msg => ({
        ...msg,
        content: cleanUnicodeForAnthropic(msg.content)
      }));
      
      // Baue Messages für Anthropic auf
      let claudeMessages = [];
      
      // Kombiniere System-Content mit erster User-Message wenn System zu lang
      if (systemMessage.length > 32000) {
        console.log(`[LLM-CLAUDE] System prompt ${systemMessage.length} chars - moving to user message`);
        
        const combinedContent = `SYSTEM-INSTRUKTIONEN:
=====================================
${systemMessage}

ANFRAGE:
========
${cleanedUserMessages[0]?.content || 'Bitte die obigen Instruktionen befolgen.'}`;
        
        claudeMessages.push({
          role: "user",
          content: cleanUnicodeForAnthropic(combinedContent)
        });
        
        for (let i = 1; i < cleanedUserMessages.length; i++) {
          claudeMessages.push({
            role: "user",
            content: cleanedUserMessages[i].content
          });
        }
        
        // GEÄNDERT: Verwende task-spezifisches Modell
        const response = await anthropic.messages.create({
          model: modelToUse,
          max_tokens: Math.min(maxTokens, 16000),
          temperature,
          messages: claudeMessages
        });
        
        console.log(`[LLM-CLAUDE] Success with ${modelToUse} (no system prompt)`);
        return response.content[0].text;
        
      } else {
        // System ist klein genug - normale Verarbeitung
        for (const msg of messages.filter(m => m.role !== "system")) {
          claudeMessages.push({
            role: msg.role,
            content: cleanUnicodeForAnthropic(
              typeof msg.content === 'string' ? msg.content : JSON.stringify(msg.content)
            )
          });
        }
        
        // NEU: Spezielle JSON-Mode Behandlung je nach Modell
let finalSystem = systemMessage;
if (options.jsonMode) {
  // Universelle JSON-Instruktion für ALLE Tasks und ALLE Claude-Modelle
  finalSystem = `KRITISCH: Du MUSST ausschließlich valides JSON zurückgeben!
- Beginne deine Antwort DIREKT mit {
- Ende deine Antwort mit }
- KEINE Markdown-Formatierung (keine \`\`\`json)
- KEINE Erklärungen vor oder nach dem JSON
- NUR das reine JSON-Objekt

${systemMessage}`;
}
        
        console.log(`[LLM-CLAUDE] Normal call - Model: ${modelToUse} | System: ${finalSystem.length} chars`);
        
        // GEÄNDERT: Verwende task-spezifisches Modell
        const response = await anthropic.messages.create({
          model: modelToUse,
          max_tokens: Math.min(maxTokens, 16000),
          temperature,
          system: finalSystem,
          messages: claudeMessages
        });
        
        console.log(`[LLM-CLAUDE] Success with ${modelToUse}`);
        return response.content[0].text;
      }
      
    } catch (error) {
      console.error('[LLM-CLAUDE] Full error:', error);
      console.error(`[LLM-CLAUDE] Failed model: ${getAnthropicModel(task)}`);
      
      if (error.status === 400) {
        console.error('[LLM-CLAUDE] 400 Error - Message:', error.message);
        if (error.error) {
          console.error('[LLM-CLAUDE] Error details:', error.error);
        }
      }
      
      throw error;
    }
  };
  
  // Rest der Funktion - jetzt mit Anthropic als primär
  let result = null;
  let lastError = null;
  
  // Try primary provider (jetzt immer Anthropic)
  try {
    const model = getAnthropicModel(task);
    console.log(`[LLM] Task: ${task} | Primary: Anthropic (${model}) | Tokens: ${maxTokens}`);
    
    result = await callClaude();
    
    console.log(`[LLM] Success with Anthropic (${model})`);
    return result;
    
  } catch (primaryError) {
    lastError = primaryError;
    console.warn(`[LLM] Anthropic failed with status ${primaryError.status || 'unknown'}`);
    
    // Try fallback provider (OpenAI)
    try {
      console.log(`[LLM] Trying fallback: OpenAI (${MODEL_OPENAI})`);
      
      result = await callOpenAI();
      
      console.log(`[LLM] Success with fallback OpenAI`);
      return result;
      
    } catch (fallbackError) {
      console.error(`[LLM] Fallback OpenAI also failed with status ${fallbackError.status || 'unknown'}`);
      lastError = fallbackError;
    }
  }
  
  // Both failed - last resort for questions
  if (task === 'questions' || task === 'intake') {
    console.log('[LLM] Both providers failed, using emergency fallback questions');
    return '[]';
  }
  
  throw new Error(`All LLM providers unavailable. Last error: ${lastError?.message || 'Unknown error'}`);
}

// Konstante für alle maßrelevanten Bauteile (ca. Zeile 415, vor extractProjectKeyData)
const DIMENSION_REQUIRED_ITEMS = {
  'FEN': {
    keywords: ['fenster', 'haustür', 'außentür', 'terrassenentür'],
    format: /\d+\s*x\s*\d+\s*(cm|mm)/,
    example: 'Fenster Kunststoff weiß, 120 x 140 cm, Dreh-Kipp',
    itemName: 'Fenster',
    requireExactDimensions: true
  },
  'TIS': {
    keywords: ['tür', 'türen', 'innentür'],
    format: /\d+\s*x\s*\d+\s*(cm|mm)/,
    example: 'Innentür Weißlack, 86 x 198,5 cm, inkl. Zarge',
    itemName: 'Innentüren',
    requireExactDimensions: true
  },
  'HEI': {
    keywords: ['heizkörper', 'radiator'],
    format: /\d+\s*x\s*\d+\s*(cm|mm)|typ\s*\d+|(\d+\s*watt)/i,
    example: 'Heizkörper Typ 22, Leistung nach Heizlastberechnung',
    itemName: 'Heizkörper',
    requireExactDimensions: false,
    alternativeSpec: 'Leistung/Typ'
  },
  'SAN': {
    keywords: ['waschbecken', 'wc', 'dusche', 'badewanne', 'waschtisch'],
    format: /\d+\s*(x\s*\d+)?\s*(cm|mm)|standard/i,
    example: 'Waschtisch 60 cm oder Standardmaß',
    itemName: 'Sanitärobjekte',
    requireExactDimensions: true
  },
  'SCHL': {
    keywords: ['geländer', 'handlauf', 'brüstung'],
    format: /\d+\s*(m|meter|lfm)/,
    example: 'Balkongeländer Stahl feuerverzinkt, 12 m, Höhe 110 cm, Lieferung und Montage',
    itemName: 'Geländer',
    requireExactDimensions: true
  },
  'FLI': {
    keywords: ['fliesen', 'platten'],
    format: /\d+\s*x\s*\d+\s*(cm|mm)/,
    example: 'Fliesen Feinsteinzeug, 60 x 60 cm, grau',
    itemName: 'Fliesen',
    requireExactDimensions: true
  }
};

/**
 * Extrahiert Schlüsseldaten aus der Projektbeschreibung
 */
function extractProjectKeyData(description, category = null) {
  const extractedData = {
    quantities: {},
    measures: [],
    rooms: [],
    specificDetails: {}
  };
  
  if (!description) return extractedData;
  
  const desc = description.toLowerCase();
  
  // Extrahiere Mengenangaben
  const quantityPatterns = [
    { pattern: /(\d+)\s*(fenster|fenstern)/gi, key: 'fenster' },
    { pattern: /(\d+)\s*(tür|türen)/gi, key: 'tueren' },
    { pattern: /(\d+)\s*(m²|qm|quadratmeter)/gi, key: 'flaeche' },
    { pattern: /(\d+)\s*(zimmer|räume)/gi, key: 'raeume' },
    { pattern: /(\d+)\s*(stockwerk|etage|geschoss)/gi, key: 'stockwerke' },
    { pattern: /(\d+)\s*(heizkörper)/gi, key: 'heizkoerper' },
    { pattern: /(\d+)\s*(steckdose|schalter)/gi, key: 'elektropunkte' }
  ];
  
  quantityPatterns.forEach(({ pattern, key }) => {
    const matches = description.match(pattern);
    if (matches && matches[0]) {
      const number = matches[0].match(/\d+/);
      if (number) {
        extractedData.quantities[key] = parseInt(number[0]);
      }
    }
  });
  
  // Extrahiere spezifische Maßnahmen
  const measureKeywords = [
    { keyword: 'wdvs', measure: 'WDVS Fassadendämmung' },
    { keyword: 'fassadendämmung', measure: 'Fassadendämmung' },
    { keyword: 'dachdämmung', measure: 'Dachdämmung' },
    { keyword: 'fenster austausch', measure: 'Fensteraustausch' },
    { keyword: 'fenster erneuern', measure: 'Fensteraustausch' },
    { keyword: 'bad sanierung', measure: 'Badsanierung' },
    { keyword: 'badsanierung', measure: 'Badsanierung' },
    { keyword: 'küche', measure: 'Küchenerneuerung' },
    { keyword: 'heizung', measure: 'Heizungserneuerung' },
    { keyword: 'elektro', measure: 'Elektroerneuerung' },
    { keyword: 'dach neu', measure: 'Dacherneuerung' },
    { keyword: 'parkett', measure: 'Parkettverlegung' },
    { keyword: 'fliesen', measure: 'Fliesenarbeiten' }
  ];
  
  measureKeywords.forEach(({ keyword, measure }) => {
    if (desc.includes(keyword)) {
      extractedData.measures.push(measure);
    }
  });
  
  // Extrahiere Rauminformationen
  const roomKeywords = ['bad', 'küche', 'wohnzimmer', 'schlafzimmer', 'kinderzimmer', 
                        'büro', 'keller', 'dachgeschoss', 'flur', 'gäste-wc'];
  
  roomKeywords.forEach(room => {
    if (desc.includes(room)) {
      extractedData.rooms.push(room);
    }
  });
  // Spezielle Gewerke-Kombinationen für häufige Sanierungsmaßnahmen
extractedData.impliedTrades = [];

// 1. BADSANIERUNG - sehr häufig
if (desc.includes('bad') || desc.includes('bäder') || 
    desc.includes('sanitär') || desc.includes('dusch') || 
    desc.includes('wc')) {
  
  extractedData.impliedTrades.push({
    code: 'TRO',
    reason: 'Vorwandinstallation für Sanitärleitungen',
    confidence: 85
  });
  
  extractedData.impliedTrades.push({
    code: 'FLI',
    reason: 'Fliesenarbeiten Wand und Boden',
    confidence: 90
  });
  
  extractedData.impliedTrades.push({
    code: 'SAN',
    reason: 'Sanitärinstallation',
    confidence: 95
  });
  
  extractedData.impliedTrades.push({
    code: 'ELEKT',
    reason: 'Elektroinstallation Feuchtraum',
    confidence: 80
  });
  
  extractedData.impliedTrades.push({
    code: 'MAL',
    reason: 'Malerarbeiten Decke',
    confidence: 70
  });
}

// 2. KÜCHENSANIERUNG
if (desc.includes('küche')) {
  extractedData.impliedTrades.push({
    code: 'ELEKT',
    reason: 'Elektroanschlüsse Herd, Spülmaschine, Beleuchtung',
    confidence: 95
  });
  
  extractedData.impliedTrades.push({
    code: 'SAN',
    reason: 'Wasseranschlüsse Spüle, Spülmaschine',
    confidence: 90
  });
  
  if (desc.includes('fliesen') || desc.includes('komplett')) {
    extractedData.impliedTrades.push({
      code: 'FLI',
      reason: 'Fliesenspiegel',
      confidence: 75
    });
  }
  
  extractedData.impliedTrades.push({
    code: 'MAL',
    reason: 'Wandanstrich',
    confidence: 70
  });
}

// 3. DACHAUSBAU / DACHGESCHOSS
if (desc.includes('dachausbau') || desc.includes('dachgeschoss') || 
    (desc.includes('dach') && desc.includes('ausbau'))) {
  
  extractedData.impliedTrades.push({
    code: 'TRO',
    reason: 'Dachschrägen verkleiden, Trennwände',
    confidence: 95
  });
  
  extractedData.impliedTrades.push({
    code: 'ZIMM',
    reason: 'Holzkonstruktion, Gauben',
    confidence: 80
  });
  
  extractedData.impliedTrades.push({
    code: 'FEN',
    reason: 'Dachfenster',
    confidence: 85
  });
  
  extractedData.impliedTrades.push({
    code: 'ELEKT',
    reason: 'Elektroinstallation neue Räume',
    confidence: 90
  });
  
  extractedData.impliedTrades.push({
    code: 'HEI',
    reason: 'Heizung erweitern',
    confidence: 75
  });
}

// 4. FASSADENSANIERUNG
if (desc.includes('fassade') || desc.includes('wdvs') || 
    desc.includes('außendämmung')) {
  
  extractedData.impliedTrades.push({
    code: 'FASS',
    reason: 'Fassadenarbeiten',
    confidence: 100
  });
  
  extractedData.impliedTrades.push({
    code: 'GER',
    reason: 'Gerüst für Fassadenarbeiten',
    confidence: 95
  });
  
  if (desc.includes('fenster') || desc.includes('komplett')) {
    extractedData.impliedTrades.push({
      code: 'FEN',
      reason: 'Fensteraustausch bei Fassadensanierung',
      confidence: 70
    });
  }
}

// 5. KOMPLETTSANIERUNG / KERNSANIERUNG
if (desc.includes('kernsanierung') || desc.includes('komplettsanierung') || 
    desc.includes('vollsanierung')) {
  
  extractedData.impliedTrades.push({
    code: 'ABBR',
    reason: 'Entkernung',
    confidence: 90
  });
  
  extractedData.impliedTrades.push({
    code: 'ROH',
    reason: 'Rohbauarbeiten',
    confidence: 85
  });
  
  extractedData.impliedTrades.push({
    code: 'ELEKT',
    reason: 'Komplette Elektroerneuerung',
    confidence: 95
  });
  
  extractedData.impliedTrades.push({
    code: 'SAN',
    reason: 'Komplette Sanitärerneuerung',
    confidence: 95
  });
  
  extractedData.impliedTrades.push({
    code: 'HEI',
    reason: 'Heizungserneuerung',
    confidence: 90
  });
}

// 6. KELLERSANIERUNG
if (desc.includes('keller')) {
  extractedData.impliedTrades.push({
    code: 'MAL',
    reason: 'Kellerwände streichen',
    confidence: 70
  });
  
  if (desc.includes('feucht') || desc.includes('nass')) {
    extractedData.impliedTrades.push({
      code: 'ROH',
      reason: 'Sanierputz, Abdichtung',
      confidence: 85
    });
  }
  
  if (desc.includes('ausbau')) {
    extractedData.impliedTrades.push({
      code: 'TRO',
      reason: 'Kellerausbau Trockenbauwände',
      confidence: 80
    });
    
    extractedData.impliedTrades.push({
      code: 'ELEKT',
      reason: 'Elektroinstallation Kellerräume',
      confidence: 75
    });
  }
}

// 7. WOHNUNGSSANIERUNG
if (desc.includes('wohnung') && 
    (desc.includes('sanier') || desc.includes('renovier'))) {
  
  extractedData.impliedTrades.push({
    code: 'MAL',
    reason: 'Malerarbeiten alle Räume',
    confidence: 90
  });
  
  extractedData.impliedTrades.push({
    code: 'BOD',
    reason: 'Bodenbelagsarbeiten',
    confidence: 85
  });
  
  extractedData.impliedTrades.push({
    code: 'ELEKT',
    reason: 'Elektromodernisierung',
    confidence: 70
  });
  
  if (!desc.includes('ohne bad')) {
    extractedData.impliedTrades.push({
      code: 'SAN',
      reason: 'Sanitärmodernisierung',
      confidence: 60
    });
  }
}

// 8. ENERGETISCHE SANIERUNG
if (desc.includes('energetisch') || desc.includes('energiespar') || 
    desc.includes('kfw') || desc.includes('bafa')) {
  
  extractedData.impliedTrades.push({
    code: 'FASS',
    reason: 'Fassadendämmung WDVS',
    confidence: 90
  });
  
  extractedData.impliedTrades.push({
    code: 'DACH',
    reason: 'Dachdämmung',
    confidence: 85
  });
  
  extractedData.impliedTrades.push({
    code: 'FEN',
    reason: 'Fensteraustausch energetisch',
    confidence: 90
  });
  
  extractedData.impliedTrades.push({
    code: 'HEI',
    reason: 'Heizungsmodernisierung',
    confidence: 80
  });
}

// 9. DACHSANIERUNG
if (desc.includes('dach') && 
    (desc.includes('neu') || desc.includes('sanier'))) {
  
  extractedData.impliedTrades.push({
    code: 'DACH',
    reason: 'Dachdeckerarbeiten',
    confidence: 100
  });
  
  extractedData.impliedTrades.push({
    code: 'ZIMM',
    reason: 'Dachstuhl prüfen/reparieren',
    confidence: 60
  });
  
  extractedData.impliedTrades.push({
    code: 'GER',
    reason: 'Gerüst für Dacharbeiten',
    confidence: 95
  });
}

// 10. BALKON/TERRASSEN-SANIERUNG
if (desc.includes('balkon') || desc.includes('terrasse') || 
    desc.includes('loggia')) {
  
  extractedData.impliedTrades.push({
    code: 'FLI',
    reason: 'Balkonbelag Fliesen/Platten',
    confidence: 85
  });
  
  extractedData.impliedTrades.push({
    code: 'SCHL',
    reason: 'Balkongeländer',
    confidence: 75
  });
  
  if (desc.includes('überdach')) {
    extractedData.impliedTrades.push({
      code: 'ZIMM',
      reason: 'Überdachung Holzkonstruktion',
      confidence: 70
    });
  }
}

// NEU: Initialisiere suggestedTrades für spätere Verwendung
extractedData.suggestedTrades = [];
extractedData.intakeKeywords = []; // Für spätere Analyse

// Keyword-Liste für spätere Verwendung speichern
extractedData.tradeKeywords = {
  'ELEKT': ['steckdose', 'schalter', 'lampe', 'elektro', 'kabel', 'sicherung', 'strom', 'leitung', 'verteiler', 'fi-schalter'],
  'HEI': ['heizung', 'heizkörper', 'thermostat', 'warmwasser', 'kessel', 'brenner', 'fußbodenheizung', 'radiator'],
  'KLIMA': ['lüftung', 'klima', 'luftwechsel', 'abluft', 'zuluft', 'klimaanlage', 'wärmerückgewinnung'],
  'TRO': ['rigips', 'trockenbau', 'ständerwerk', 'vorwand', 'gipskarton', 'abgehängte decke', 'schallschutz'],
  'FLI': ['fliesen', 'verfugen', 'mosaik', 'bad', 'naturstein', 'feinsteinzeug', 'bodenfliesen', 'wandfliesen'],
  'MAL': ['streichen', 'innenputz', 'tapezieren', 'verputzen', 'spachteln', 'anstrich', 'farbe', 'lackieren', 'grundierung', 'malerarbeiten'],
  'BOD': ['parkett', 'laminat', 'vinyl', 'teppich', 'linoleum', 'kork', 'designboden', 'bodenbelag'],
  'ROH': ['mauerwerk', 'durchbruch', 'beton', 'wand', 'decke', 'maurerarbeiten'],
  'SAN': ['bad', 'wc', 'waschbecken', 'dusche', 'badewanne', 'sanitär', 'abfluss', 'wasserhahn', 'armatur'],
  'FEN': ['fenster', 'verglasung', 'rolladen', 'jalousie', 'fensterbank', 'glasbruch', 'isolierglas'],
  'TIS': ['tür', 'innentür', 'zarge', 'möbel', 'einbauschrank', 'holzarbeiten', 'küche', 'arbeitsplatte'],
  'DACH': ['dach', 'ziegel', 'dachrinne', 'schneefang', 'dachfenster', 'gauben', 'dachstuhl', 'eindeckung'],
  'FASS': ['fassade', 'wdvs', 'außenputz', 'dämmung', 'verblendung', 'klinker', 'fassadenfarbe'],
  'GER': ['gerüst', 'baugerüst', 'arbeitsgerüst', 'fassadengerüst', 'rollgerüst'],
  'ZIMM': ['holzbau', 'gaube', 'dachstuhl', 'balken', 'carport', 'pergola', 'holzkonstruktion', 'fachwerk'],
  'ESTR': ['estrich', 'fließestrich', 'zementestrich', 'anhydritestrich', 'trockenestrich', 'ausgleichsmasse'],
  'SCHL': ['geländer', 'zaun', 'tor', 'metallbau', 'stahltreppe', 'gitter', 'schlosserarbeiten'],
  'AUSS': ['pflaster', 'terrasse', 'einfahrt', 'garten', 'außenanlage', 'randstein', 'rasen'],
  'PV': ['solar', 'photovoltaik', 'solaranlage', 'wechselrichter', 'speicher', 'batterie', 'einspeisung'],
  'ABBR': ['abriss', 'abbruch', 'entkernung', 'rückbau', 'demontage', 'entsorgung', 'schutt']
};

// Entferne Duplikate (falls ein Gewerk mehrfach impliziert wurde)
const uniqueTrades = {};
extractedData.impliedTrades.forEach(trade => {
  if (!uniqueTrades[trade.code] || uniqueTrades[trade.code].confidence < trade.confidence) {
    uniqueTrades[trade.code] = trade;
  }
});
extractedData.impliedTrades = Object.values(uniqueTrades);
  
  // Spezifische Details extrahieren
  if (desc.includes('altbau')) extractedData.specificDetails.buildingType = 'Altbau';
  if (desc.includes('neubau')) extractedData.specificDetails.buildingType = 'Neubau';
  if (desc.includes('einfamilienhaus') || desc.includes('efh')) {
    extractedData.specificDetails.buildingType = 'Einfamilienhaus';
  }
  if (desc.includes('mehrfamilienhaus') || desc.includes('mfh')) {
    extractedData.specificDetails.buildingType = 'Mehrfamilienhaus';
  }
  
  // Prüfe ob Gerüst benötigt wird (für spätere Verwendung)
  extractedData.specificDetails.needsScaffolding = 
    desc.includes('dach') || desc.includes('fassade') || 
    desc.includes('fenster') && (desc.includes('obergeschoss') || desc.includes('2. stock'));
  
  // Extrahiere "KEINE" Angaben (wichtig für Ausschlüsse)
  if (desc.includes('keine haustür') || desc.includes('ohne haustür')) {
    extractedData.specificDetails.excludeHaustuer = true;
  }
  if (desc.includes('ohne gerüst') || desc.includes('kein gerüst')) {
    extractedData.specificDetails.excludeGeruest = true;
  }
  
  console.log('[EXTRACT] Extracted data from description:', extractedData);
  
  return extractedData;
}

/**
 * Intelligente Antwort-Validierung und Schätzung
 */
async function validateAndEstimateAnswers(answers, tradeCode, projectContext) {
  const systemPrompt = `Du bist ein erfahrener Bausachverständiger mit 20+ Jahren Erfahrung.
Deine Aufgabe: Validiere Nutzerantworten und erstelle realistische Schätzungen für unsichere Angaben.

WICHTIGE REGELN:
1. Prüfe die Plausibilität aller Mengenangaben
2. Bei "unsicher" oder fehlenden kritischen Angaben: Erstelle realistische Schätzungen basierend auf:
   - Typischen Werten für ähnliche Projekte
   - Ableitungen aus anderen Angaben (z.B. Raumgröße → Kabellänge)
   - Branchenüblichen Standards
3. Berechne abgeleitete Werte intelligent:
   - Kabellängen: ca. 15-20m pro Raum + Steigungen
   - Rohrleitungen: Direkte Wege + 20% Zuschlag
   - Materialmengen: Flächen × Erfahrungswerte
4. Dokumentiere ALLE Annahmen transparent

OUTPUT (NUR valides JSON):
{
  "validated": [
    {
      "questionId": "string",
      "originalAnswer": "string oder null",
      "validatedValue": "number",
      "unit": "m²/m/Stk/kg/l",
      "assumption": "Detaillierte Erklärung der Schätzgrundlage",
      "confidence": 0.5-1.0
    }
  ],
  "derivedValues": {
    "totalArea": "number",
    "perimeter": "number",
    "volume": "number",
    "additionalMetrics": {}
  },
  "warnings": ["Liste von Hinweisen auf unrealistische oder fehlende Angaben"]
}`;

  const userPrompt = `Gewerk: ${tradeCode}
Projektkontext: ${JSON.stringify(projectContext)}
Nutzerantworten: ${JSON.stringify(answers)}

Validiere diese Antworten und erstelle realistische Schätzungen wo nötig.`;

  try {
    const response = await llmWithPolicy('validation', [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], { maxTokens: 3000, temperature: 0.3, jsonMode: true });
    
    const cleanedResponse = response
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .trim();
    
    return JSON.parse(cleanedResponse);
  } catch (err) {
    console.error('[VALIDATION] Failed:', err);
    return null;
  }
}

/**
 * Intelligente, dynamische Fragenanzahl-Ermittlung
 * VERBESSERT: Realistischere Bewertung der vorhandenen Informationen
 */
function getIntelligentQuestionCount(tradeCode, projectContext, intakeAnswers = []) {
  const tradeConfig = TRADE_COMPLEXITY[tradeCode] || DEFAULT_COMPLEXITY;

  // NEU: Nutze gespeicherte Komplexität falls vorhanden
  const projectComplexity = projectContext.complexity || 
    projectContext.metadata?.complexity?.level ||
    determineProjectComplexity(projectContext, intakeAnswers);
  
  // NEU: Komplexitäts-basierte Anpassung der Fragenanzahl
  const complexityMultiplier = {
    'SEHR_HOCH': 1.25,
    'HOCH': 1.15,
    'MITTEL': 1.0,
    'NIEDRIG': 0.85,
    'EINFACH': 0.7
  }[projectComplexity] || 1.0;
  
  // Basis-Range mit Komplexitäts-Multiplikator
  const baseRange = {
    min: Math.round(tradeConfig.minQuestions * complexityMultiplier),
    max: Math.round(tradeConfig.maxQuestions * complexityMultiplier),
    complexity: tradeConfig.complexity
  };
  
  // Analysiere wie viel Information bereits vorhanden ist
  let informationCompleteness = 0;
  let missingCriticalInfo = [];
  
  // Prüfe Projektbeschreibung
  if (projectContext.description) {
    const desc = projectContext.description.toLowerCase();
    const wordCount = desc.split(' ').length;
    
    // REALISTISCHERE Bewertung der Beschreibung
    if (wordCount > 100) informationCompleteness += 20;
    else if (wordCount > 50) informationCompleteness += 15;
    else if (wordCount > 20) informationCompleteness += 10;
    else informationCompleteness += 5;
    
    // Gewerke-spezifische Prüfungen mit höherer Gewichtung
    switch(tradeCode) {
      case 'MAL': // Malerarbeiten
        if (desc.match(/\d+\s*(m²|qm|quadratmeter)/)) {
          informationCompleteness += 25; // Fläche ist kritisch!
        } else {
          missingCriticalInfo.push('Flächenangabe');
        }
        if (desc.includes('zimmer') || desc.includes('raum') || desc.includes('wohnung')) {
          informationCompleteness += 15;
        }
        if (desc.includes('weiß') || desc.includes('farbe') || desc.includes('farbton')) {
          informationCompleteness += 10;
        }
        // Bei "Zimmer streichen" ist oft schon genug Info da
        if (desc.includes('zimmer') && desc.includes('streichen')) {
          informationCompleteness += 20;
        }
        break;
        
      case 'DACH':
        if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Dachfläche');
        else informationCompleteness += 20;
        if (!desc.includes('dachform') && !desc.includes('sattel') && !desc.includes('flach')) {
          missingCriticalInfo.push('Dachform');
        } else {
          informationCompleteness += 15;
        }
        break;
        
      case 'ELEKT':
        if (!desc.match(/\d+\s*(steckdose|schalter|dose)/)) missingCriticalInfo.push('Anzahl Elektropunkte');
        else informationCompleteness += 15;
        if (!desc.includes('verteiler') && !desc.includes('sicherung')) missingCriticalInfo.push('Verteilerinfo');
        else informationCompleteness += 10;
        break;
        
      case 'FLI': // Fliesenarbeiten
        if (desc.match(/\d+\s*(m²|qm)/)) informationCompleteness += 25;
        else missingCriticalInfo.push('Fliesenfläche');
        if (desc.includes('bad') || desc.includes('küche')) informationCompleteness += 10;
        break;
        
      case 'SAN': // Sanitär
        if (desc.includes('bad') || desc.includes('wc') || desc.includes('dusche')) {
          informationCompleteness += 15;
        }
        if (!desc.includes('austausch') && !desc.includes('erneuer') && !desc.includes('neu')) {
          missingCriticalInfo.push('Umfang der Arbeiten');
        }
        break;
        
      case 'GER': // Gerüstbau
        if (desc.match(/\d+\s*(m|meter)/)) informationCompleteness += 20;
        else missingCriticalInfo.push('Gebäudehöhe');
        if (desc.includes('einfamilienhaus') || desc.includes('efh')) informationCompleteness += 10;
        break;

      case 'FASS':
  if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Fassadenfläche');
  else informationCompleteness += 20;
  if (!desc.includes('fassade') && !desc.includes('putz') && !desc.includes('dämmung')) {
    missingCriticalInfo.push('Art der Fassadenarbeiten');
  } else {
    informationCompleteness += 20;
  }
  break;

case 'ABBR':
  if (!desc.match(/\d+\s*(m²|m³|tonnen)/)) missingCriticalInfo.push('Abbruchmenge');
  else informationCompleteness += 20;
  if (!desc.includes('entkernung') && !desc.includes('teilabbruch') && !desc.includes('komplettabbruch')) {
    missingCriticalInfo.push('Art des Abbruchs');
  } else {
    informationCompleteness += 10;
  }
  break;

case 'BOD':
  if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Bodenfläche');
  else informationCompleteness += 20;
  if (!desc.includes('parkett') && !desc.includes('laminat') && !desc.includes('vinyl')) {
    missingCriticalInfo.push('Bodenbelagsart');
  } else {
    informationCompleteness += 20;
  }
  break;

case 'HEI':
  if (!desc.match(/\d+\s*(kw|heizkörper|räume)/)) missingCriticalInfo.push('Heizleistung/Umfang');
  else informationCompleteness += 10;
  if (!desc.includes('gastherme') && !desc.includes('wärmepumpe') && !desc.includes('ölheizung')) {
    missingCriticalInfo.push('Heizungstyp');
  } else {
    informationCompleteness += 15;
  }
  break;

case 'KLIMA': // Lüftung- und Klimatechnik
    if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Raumflächen');
    else informationCompleteness += 20;
    if (!desc.includes('raumhöhe') && !desc.includes('geschoss')) missingCriticalInfo.push('Raumhöhen');
    else informationCompleteness += 10;
    if (desc.includes('lüftung') || desc.includes('klima') || desc.includes('luftwechsel')) {
        informationCompleteness += 10;
    }
    if (desc.includes('kühlung') || desc.includes('heizung')) informationCompleteness += 20;
    break;

case 'PV': // Photovoltaik
  if (!desc.match(/\d+\s*(kwp|kw)/i)) missingCriticalInfo.push('Anlagengröße');
  else informationCompleteness += 20;
  if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Dachfläche');
  else informationCompleteness += 15;
  if (desc.includes('speicher') || desc.includes('batterie')) informationCompleteness += 20;
  break;
        
case 'FEN':
  if (!desc.match(/\d+\s*(fenster|türen|stück)/)) missingCriticalInfo.push('Anzahl Fenster/Türen');
  else informationCompleteness += 20;
  if (!desc.includes('kunststoff') && !desc.includes('holz') && !desc.includes('aluminium')) {
    missingCriticalInfo.push('Material Fenster/Türen');
  } else {
    informationCompleteness += 15;
  }
  break;

case 'TIS':
  if (!desc.match(/\d+\s*(m|schrank|element)/)) missingCriticalInfo.push('Umfang Tischlerarbeiten');
  else informationCompleteness += 15;
  if (!desc.includes('einbauschrank') && !desc.includes('küche') && !desc.includes('möbel')) {
    missingCriticalInfo.push('Art der Tischlerarbeiten');
  } else {
    informationCompleteness += 10;
  }
  break;

case 'ROH':
  // Spezialfall: Bei EINFACHEN oder NIEDRIGEN Projekten mit Wanddurchbruch
  if ((projectComplexity === 'EINFACH' || projectComplexity === 'NIEDRIG') && 
      (desc.includes('wanddurchbruch') || 
       desc.includes('türdurchbruch') || 
       (desc.includes('durchbruch') && !desc.includes('mehrere')))) {
    
    // Erhöhe Vollständigkeit stark für einfache Durchbrüche
    informationCompleteness += 30;
    console.log('[QUESTIONS] Simple wall opening in SIMPLE/LOW project - increasing completeness');
    
    if (desc.match(/\d+\s*(cm|m|mm)/)) {
      informationCompleteness += 20;
    }
    
  } else if ((projectComplexity === 'HOCH' || projectComplexity === 'SEHR_HOCH') && 
             desc.includes('durchbruch')) {
    // Komplexes Projekt mit Durchbruch - normale Behandlung
    informationCompleteness += 10; // Nur leichte Erhöhung
    console.log('[QUESTIONS] Wall opening in COMPLEX project - standard handling');
    
    // Normale Prüfungen fortsetzen
    if (!desc.match(/\d+\s*(m²|m³|qm)/)) {
      missingCriticalInfo.push('Rohbaufläche/Volumen');
    } else {
      informationCompleteness += 10;
    }
    
  } else {
    // Normale Rohbau-Prüfung (MITTEL-Komplexität oder ohne Durchbruch)
    if (!desc.match(/\d+\s*(m²|m³|qm)/)) {
      missingCriticalInfo.push('Rohbaufläche/Volumen');
    } else {
      informationCompleteness += 10;
    }
    
    if (!desc.includes('bodenplatte') && !desc.includes('wand') && !desc.includes('decke')) {
      missingCriticalInfo.push('Art der Rohbauarbeiten');
    } else {
      informationCompleteness += 10;
    }
  }
  break;

case 'ZIMM': // Zimmererarbeiten
  if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Holzkonstruktionsfläche');
  else informationCompleteness += 10;
  if (!desc.includes('dachstuhl') && !desc.includes('holzbau') && !desc.includes('carport')) {
    missingCriticalInfo.push('Art der Zimmererarbeiten');
  } else {
    informationCompleteness += 10;
  }
  break;
        
case 'ESTR':
  if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Estrichfläche');
  else informationCompleteness += 30;
  if (!desc.includes('fließestrich') && !desc.includes('zementestrich') && !desc.includes('trockenestrich')) {
    missingCriticalInfo.push('Estrichart');
  } else {
    informationCompleteness += 20;
  }
  break;

case 'TRO':
  if (!desc.match(/\d+\s*(m²|qm|wände)/)) missingCriticalInfo.push('Trockenbaufläche');
  else informationCompleteness += 20;
  if (!desc.includes('rigips') && !desc.includes('gipskarton') && !desc.includes('ständerwerk')) {
    missingCriticalInfo.push('Art der Trockenbauarbeiten');
  } else {
    informationCompleteness += 10;
  }
  break;

case 'SCHL':
  if (!desc.match(/\d+\s*(m|meter|stück)/)) missingCriticalInfo.push('Umfang Schlosserarbeiten');
  else informationCompleteness += 20;
  if (!desc.includes('geländer') && !desc.includes('zaun') && !desc.includes('tor')) {
    missingCriticalInfo.push('Art der Schlosserarbeiten');
  } else {
    informationCompleteness += 10;
  }
  break;

case 'AUSS':
  if (!desc.match(/\d+\s*(m²|qm)/)) missingCriticalInfo.push('Außenbereichsfläche');
  else informationCompleteness += 20;
  if (!desc.includes('pflaster') && !desc.includes('rasen') && !desc.includes('bepflanzung')) {
    missingCriticalInfo.push('Art der Außenarbeiten');
  } else {
    informationCompleteness += 10;
  }
  break;

case 'INT':
  // Spezialfall INT - weniger strenge Anforderungen
  if (!desc.match(/\d+/)) missingCriticalInfo.push('Projektumfang');
  else informationCompleteness += 10;
  informationCompleteness += 10; // Bonus für INT
  break;
    
    }
    
    // Allgemeine hilfreiche Informationen
    if (desc.match(/\d+\s*(zimmer|räume)/)) informationCompleteness += 10;
    if (desc.includes('altbau') || desc.includes('neubau')) informationCompleteness += 5;
    if (desc.includes('komplett') || desc.includes('gesamt')) informationCompleteness += 5;
  }
  
  // Prüfe Intake-Antworten (haben mehr Gewicht)
  if (intakeAnswers.length > 0) {
    // Jede beantwortete Intake-Frage erhöht die Vollständigkeit
    informationCompleteness += Math.min(40, intakeAnswers.length * 3);
    
    // Prüfe auf konkrete Mengenangaben in Antworten
    const hasNumbers = intakeAnswers.filter(a => 
      a.answer && a.answer.match(/\d+/)
    ).length;
    informationCompleteness += Math.min(20, hasNumbers * 5);
  }
  
  // Budget gibt Aufschluss über Projektumfang
  if (projectContext.budget && !projectContext.budget.includes('unsicher')) {
    informationCompleteness += 10;
  }
  
  // Kategorie kann auch helfen
  if (projectContext.category) {
    const cat = projectContext.category.toLowerCase();
    if (cat.includes('renovierung') || cat.includes('sanierung')) {
      informationCompleteness += 5;
    }
  }
  
  // Berechne finale Fragenanzahl
  informationCompleteness = Math.min(100, informationCompleteness);
  
  // VERBESSERTE Reduktionslogik
  let targetCount;
  
  if (baseRange.complexity === 'EINFACH') {
    // Einfache Gewerke brauchen weniger Fragen
    if (informationCompleteness >= 75) {
      targetCount = baseRange.min; // Minimum
    } else if (informationCompleteness >= 60) {
      targetCount = Math.round(baseRange.min + 2);
    } else if (informationCompleteness >= 40) {
      targetCount = Math.round((baseRange.min + baseRange.max) / 2);
    } else {
      targetCount = baseRange.max - 2;
    }
  } else if (baseRange.complexity === 'SEHR_HOCH' || baseRange.complexity === 'HOCH') {
    // Komplexe Gewerke brauchen mehr Details
    if (informationCompleteness >= 85) {
      targetCount = Math.round(baseRange.min + 5);
    } else if (informationCompleteness >= 70) {
      targetCount = Math.round((baseRange.min + baseRange.max) / 2);
    } else if (informationCompleteness >= 50) {
      targetCount = Math.round(baseRange.max - 5);
    } else {
      targetCount = baseRange.max;
    }
  } else {
    // Mittlere Komplexität
    if (informationCompleteness >= 80) {
      targetCount = baseRange.min + 2;
    } else if (informationCompleteness >= 60) {
      targetCount = Math.round((baseRange.min + baseRange.max) / 2);
    } else {
      targetCount = baseRange.max - 3;
    }
  }
  
  // Kritische fehlende Infos erhöhen Fragenbedarf
  targetCount += missingCriticalInfo.length * 2;
  
  // Sicherstellen dass wir in sinnvollen Grenzen bleiben
  targetCount = Math.max(baseRange.min, targetCount);
  targetCount = Math.min(baseRange.max, targetCount);
  
 // SPEZIALFALL: Sehr einfache Projekte
if (projectContext.description && 
    (projectComplexity === 'EINFACH' || projectComplexity === 'NIEDRIG')) {
  const desc = projectContext.description.toLowerCase();
  
  // Wanddurchbruch-Spezialbehandlung bei einfachen/niedrigen Projekten
  if (tradeCode === 'ROH' && 
      (desc.includes('wanddurchbruch') || 
       desc.includes('türdurchbruch') || 
       (desc.includes('durchbruch') && !desc.includes('anbau')))) {
    
    targetCount = Math.min(targetCount, 12);
    console.log(`[QUESTIONS] SIMPLE/LOW ROH wall opening: capped at 12 questions`);
  }
}
  console.log(`[QUESTIONS] Intelligent count for ${tradeCode}:`);
  console.log(`  -> Information completeness: ${informationCompleteness}%`);
  console.log(`  -> Missing critical info: ${missingCriticalInfo.join(', ') || 'none'}`);
  console.log(`  -> Base range: ${baseRange.min}-${baseRange.max}`);
  console.log(`  -> Target questions: ${targetCount}`);
  
  return {
    count: targetCount,
    completeness: informationCompleteness,
    missingInfo: missingCriticalInfo
  };
}

/**
 * Berechnet Orientierungswerte für LV-Positionen (NICHT als strikte Vorgabe!)
 */
function getPositionOrientation(tradeCode, questionCount, projectContext = null) {
  const tradeConfig = TRADE_COMPLEXITY[tradeCode] || DEFAULT_COMPLEXITY;
  
  const projectComplexity = projectContext?.complexity || 
    projectContext?.metadata?.complexity?.level || 'MITTEL';
  
  // MODERATE Anpassung für NIEDRIG/EINFACH Projekte
  if (projectComplexity === 'EINFACH' || projectComplexity === 'NIEDRIG') {
    console.log(`[LV-ORIENTATION] ${projectComplexity} project - angepasste Positionen für ${tradeCode}`);
    
    // Moderatere Faktoren: 0.8 - 1.2 der Fragenanzahl
    const reductionFactor = projectComplexity === 'NIEDRIG' ? 0.8 : 0.9;
    const maxFactor = projectComplexity === 'NIEDRIG' ? 1.2 : 1.3;
    
    const baseMin = Math.max(5, Math.floor(questionCount * reductionFactor));
    const baseMax = Math.floor(questionCount * maxFactor);
    
    // Sanfte Obergrenze - verhindert Extreme wie 19 bei 10 Fragen
    const absoluteMax = projectComplexity === 'NIEDRIG' ? 
      Math.max(12, questionCount + 2) :  // Max: Fragen + 2 oder 12
      Math.max(15, questionCount + 3);    // Max: Fragen + 3 oder 15
    
    return {
      min: baseMin,
      max: Math.min(baseMax, absoluteMax),
      base: Math.floor((baseMin + Math.min(baseMax, absoluteMax)) / 2),
      ratio: (reductionFactor + maxFactor) / 2,
      projectComplexity: projectComplexity,
      tradeCode: tradeCode,
      reason: `${projectComplexity} Projekt - angepasste Positionsanzahl`
    };
  }
  
  let ratio = tradeConfig.targetPositionsRatio;
  
  const complexityBonus = {
    'SEHR_HOCH': 0.20,
    'HOCH': 0.15,
    'MITTEL': 0.10,
    'EINFACH': 0,
  }[projectComplexity] || 0;
  
  ratio = ratio + complexityBonus;
  
  const complexProjects = ['aufstockung', 'anbau', 'umbau', 'kernsanierung'];
  const description = projectContext?.description?.toLowerCase() || '';
  const matchedTerm = complexProjects.find(term => description.includes(term));
  if (matchedTerm) {
    ratio += 0.15;
    console.log(`[LV-ORIENTATION] "${matchedTerm}" erkannt - erhöhe Positions-Ratio`);
  }
  
  const baseOrientation = Math.round(questionCount * ratio);
  
  const COMPLEXITY_MINIMUMS = {
    'SEHR_HOCH': {
      'SEHR_HOCH': 22,
      'HOCH': 18,
      'MITTEL': 16,
      'EINFACH': 10
    },
    'HOCH': {
      'SEHR_HOCH': 20,
      'HOCH': 18,
      'MITTEL': 16,
      'EINFACH': 10
    },
    'MITTEL': {
      'SEHR_HOCH': 20,
      'HOCH': 18,
      'MITTEL': 16,
      'EINFACH': 8
    },
    'EINFACH': {
      'SEHR_HOCH': 16,
      'HOCH': 14,
      'MITTEL': 10,
      'EINFACH': 8      
    },
    'NIEDRIG': {
      'SEHR_HOCH': 15,
      'HOCH': 13,
      'MITTEL': 10,
      'EINFACH': 6      
    }
  };
  
  const minPositions = COMPLEXITY_MINIMUMS[projectComplexity]?.[tradeConfig.complexity] || 8;
  
  const orientationMin = Math.max(minPositions, baseOrientation);
  
  // FEHLTE: Berechnung von orientationMax!
  let orientationMax = Math.round(orientationMin * 1.3);
  
  // Keine künstliche Begrenzung für komplexe Projekte
  if (projectComplexity === 'EINFACH') {
    orientationMax = Math.min(25, orientationMax);
  } else if (projectComplexity === 'MITTEL') {
    orientationMax = Math.min(35, orientationMax);
  }
  // Bei HOCH und SEHR_HOCH keine Begrenzung nach oben!
  
  // Sicherheitsprüfung
  if (orientationMax <= orientationMin) {
    orientationMax = orientationMin + 10;
  }
  
  console.log(`[LV-ORIENTATION] ${tradeCode}: ${orientationMin}-${orientationMax} positions`);
  console.log(`  Project complexity: ${projectComplexity}, Trade complexity: ${tradeConfig.complexity}`);
  console.log(`  Final ratio: ${ratio.toFixed(2)}, Min positions: ${minPositions}`);
  
  return {
    min: orientationMin,
    max: orientationMax,
    base: baseOrientation,
    ratio: ratio,
    projectComplexity: projectComplexity
  };
}

/**
 * Projektkomplexität bestimmen - VERBESSERTE VERSION
 */
function determineProjectComplexity(projectContext, intakeAnswers = []) {
  let complexityScore = 0;
  
  const combinedText = [
    projectContext.category || '',
    projectContext.sub_category || '',
    projectContext.description || ''
  ].join(' ').toLowerCase();
  
  // TRADE COMPLEXITY DEFINITIONEN (aus deinem Code)
    const TRADE_COMPLEXITY = {
    // Sehr komplexe Gewerke
    DACH:  { complexity: 'SEHR_HOCH', weight: 5, minScore: 13 },
    ELEKT: { complexity: 'SEHR_HOCH', weight: 5, minScore: 12 },
    SAN:   { complexity: 'SEHR_HOCH', weight: 5, minScore: 12 },
    HEI:   { complexity: 'SEHR_HOCH', weight: 5, minScore: 12 },
    KLIMA: { complexity: 'SEHR_HOCH', weight: 5, minScore: 12 },
    ROH:   { complexity: 'SEHR_HOCH', weight: 5, minScore: 10 }, // Kontextabhängig
    
    // Komplexe Gewerke
    TIS:   { complexity: 'HOCH', weight: 3, minScore: 8 },
    FEN:   { complexity: 'HOCH', weight: 3, minScore: 8 },
    FASS:  { complexity: 'HOCH', weight: 4, minScore: 12 },
    SCHL:  { complexity: 'HOCH', weight: 3, minScore: 8 },
    PV:    { complexity: 'HOCH', weight: 4, minScore: 14 },
    ZIMM:  { complexity: 'HOCH', weight: 3, minScore: 7 },
    
    // Mittlere Komplexität
    FLI:   { complexity: 'MITTEL', weight: 2, minScore: 7 },
    ESTR:  { complexity: 'MITTEL', weight: 2 },
    TRO:   { complexity: 'MITTEL', weight: 2, minScore: 7 },
    BOD:   { complexity: 'MITTEL', weight: 2 },
    AUSS:  { complexity: 'MITTEL', weight: 2, minScore: 6 },
    
    // Einfache Gewerke
    MAL:   { complexity: 'EINFACH', weight: 1 },
    GER:   { complexity: 'EINFACH', weight: 0.5 },
    ABBR:  { complexity: 'EINFACH', weight: 1 }
  };
  
  // KATEGORIE-BASIERTE GRUNDBEWERTUNG
  const categoryComplexityMap = {
    'Energetische Sanierung': {
      baseScore: 8,
      minComplexity: 'mittel',
      subCategoryScores: {
        'Komplettsanierung (Dach, Fassade, Fenster, Heizung)': 15,
        'Fassadendämmung': 10,
        'Dachdämmung / Dachsanierung': 12,
        'Fenstertausch': 6,
        'Heizungserneuerung (Wärmepumpe, Gas, Pellet)': 8,
        'Photovoltaik / Solarthermie': 9
      }
    },
    'Sanierung': {
      baseScore: 6,
      minComplexity: 'niedrig',
      subCategoryScores: {
        'Teilsanierung': 6,
        'Kernsanierung': 16,
        'Kellersanierung': 8,
        'Schadstoffsanierung (Asbest/Schimmel)': 14
      }
    },
    'Innenausbau / Renovierung': {
      baseScore: 3,
      minComplexity: 'einfach',
      subCategoryScores: {
        'Badsanierung': 7,
        'Küchensanierung': 7,
        'Wand- und Bodenrenovierung': 3,
        'Türen, Zargen, Deckenverkleidungen': 3,
        'Trockenbau (Raumaufteilung, Schallschutz)': 5
      }
    },
    'Anbau / Umbau / Aufstockung': {
      baseScore: 12,
      minComplexity: 'hoch',
      subCategoryScores: {
        'Anbau (Raumerweiterung, Wintergarten)': 14,
        'Umbau (Grundrissänderungen)': 13,
        'Aufstockung (zusätzlicher Wohnraum)': 18,
        'Dachausbau (Gauben, Dachflächenfenster)': 11
      }
    },
    'Rohbauarbeiten / Statisch relevante Eingriffe': {
      baseScore: 8,
      minComplexity: 'niedrig', // Kann von einfach bis sehr_hoch sein
      subCategoryScores: {
        'Mauer- und Betonarbeiten (Wände / Decken / Stützen)': 12,
        'Fundamentarbeiten': 14,
        'Statische Veränderungen (Wanddurchbrüche)': 6 // Basis niedrig
      }
    },
    'Rückbau / Abbrucharbeiten': {
      baseScore: 8,
      minComplexity: 'mittel',
      subCategoryScores: {
        'Abbrucharbeiten (Teil- oder Komplettabriss)': 14,
        'Entkernung': 16
      }
    },
    'Technische Gebäudeausrüstung (TGA)': {
      baseScore: 7,
      minComplexity: 'mittel',
      subCategoryScores: {
        'Heizung (Neuinstallation/Austausch)': 8,
        'Sanitärinstallation': 8,
        'Elektroinstallation (inkl. Smart Home)': 8,
        'Lüftungs- oder Klimaanlage': 10
      }
    },
    'Außenanlagen / Garten- und Landschaftsbau': {
      baseScore: 3,
      minComplexity: 'einfach',
      subCategoryScores: {
        'Terrasse': 4,
        'Zaunbau / Sichtschutz': 2,
        'Gartenneugestaltung': 3,
        'Wege / Pflasterarbeiten / Einfahrten': 3,
        'Carport / Garage / Gartenhaus': 6
      }
    }
  };
  
  // SCHRITT 1: Kategorie-Basis-Score
  let categoryConfig = categoryComplexityMap[projectContext.category] || { baseScore: 5 };
  complexityScore = categoryConfig.baseScore;
  
  // Unterkategorie berücksichtigen
  if (projectContext.sub_category && categoryConfig.subCategoryScores) {
    const subCategories = projectContext.sub_category.split(',').map(s => s.trim());
    let maxSubScore = 0;
    
    for (const subCat of subCategories) {
      if (categoryConfig.subCategoryScores[subCat]) {
        maxSubScore = Math.max(maxSubScore, categoryConfig.subCategoryScores[subCat]);
      }
    }
    
    if (maxSubScore > complexityScore) {
      complexityScore = maxSubScore;
    }
    
    // Mehrere Unterkategorien = höhere Komplexität
    if (subCategories.length > 2) {
      complexityScore += Math.min(subCategories.length - 1, 3);
    }
  }
  
  // SCHRITT 2: GEWERKE-KOMPLEXITÄT UND -ANZAHL
  const detectedTrades = projectContext.detectedTrades || [];
  const tradeCount = detectedTrades.length;
  
  // Berechne gewichtete Gewerke-Komplexität
  let tradeComplexityScore = 0;
  let maxTradeComplexity = 'EINFACH';
  let hasVeryComplexTrade = false;
  
  detectedTrades.forEach(trade => {
    const tradeConfig = TRADE_COMPLEXITY[trade.code];
    if (tradeConfig) {
      tradeComplexityScore += tradeConfig.weight;
      
      // Track höchste Einzelkomplexität
      if (tradeConfig.complexity === 'SEHR_HOCH') {
        hasVeryComplexTrade = true;
        maxTradeComplexity = 'SEHR_HOCH';
      } else if (tradeConfig.complexity === 'HOCH' && maxTradeComplexity !== 'SEHR_HOCH') {
        maxTradeComplexity = 'HOCH';
      } else if (tradeConfig.complexity === 'MITTEL' && 
                 maxTradeComplexity !== 'SEHR_HOCH' && 
                 maxTradeComplexity !== 'HOCH') {
        maxTradeComplexity = 'MITTEL';
      }
    }
  });
  
  // Kombiniere Gewerke-Anzahl mit Gewerke-Komplexität
  let tradeFactor = 0;
  
  // Basis: Anzahl der Gewerke
  if (tradeCount >= 10) {
    tradeFactor = 8;
  } else if (tradeCount >= 7) {
    tradeFactor = 6;
  } else if (tradeCount >= 5) {
    tradeFactor = 4;
  } else if (tradeCount >= 3) {
    tradeFactor = 3;
  } else if (tradeCount === 2) {
    tradeFactor = 2;
  } else if (tradeCount === 1) {
    tradeFactor = 1;
  }
  
  // Modifiziere basierend auf Gewerke-Komplexität
  if (hasVeryComplexTrade) {
    // Wenn sehr komplexe Gewerke dabei sind, Mindest-Score
    tradeFactor = Math.max(tradeFactor, 5);
    
    // Bei einzelnem sehr komplexen Gewerk (z.B. nur Dach)
    if (tradeCount === 1) {
      tradeFactor = 4; // Nicht zu niedrig bewerten
    }
  }
  
  // Gewichtete Gewerke-Komplexität zur Gesamtwertung
  complexityScore += tradeFactor;
  complexityScore += Math.min(tradeComplexityScore / 2, 8); // Cap bei 8
  
  // SCHRITT 3: KONTEXT-SPEZIFISCHE ANPASSUNGEN
  
  // Wanddurchbruch-Speziallogik
  const isWanddurchbruch = combinedText.includes('wanddurchbruch') || 
                           combinedText.includes('durchbruch') ||
                           projectContext.sub_category?.includes('Wanddurchbrüche');
  
  if (isWanddurchbruch) {
    const isIsolated = tradeCount <= 2 && 
                      !combinedText.includes('umbau') && 
                      !combinedText.includes('sanierung') &&
                      !combinedText.includes('mehrere');
    
    const isPartOfLargerWork = tradeCount >= 5 || 
                               combinedText.includes('komplett') ||
                               combinedText.includes('kernsanierung');
    
    if (isIsolated) {
      // Einzelner Wanddurchbruch ohne Kontext
      complexityScore = Math.min(complexityScore, 6); // Cap bei niedrig
      console.log('[COMPLEXITY] Isolated Wanddurchbruch - capping complexity');
    } else if (isPartOfLargerWork) {
      // Teil größerer Maßnahme
      complexityScore += 2;
      console.log('[COMPLEXITY] Wanddurchbruch in larger context - adding complexity');
    }
  }
  
  // Einzelnes Dach oder Fassade - Mindest-Komplexität
  if (tradeCount <= 2) {
    if (detectedTrades.some(t => t.code === 'DACH')) {
      complexityScore = Math.max(complexityScore, 14); // Mindestens "hoch"
      console.log('[COMPLEXITY] Single DACH trade - ensuring high complexity');
    }
    if (detectedTrades.some(t => t.code === 'FASS')) {
      complexityScore = Math.max(complexityScore, 12); // Mindestens "mittel-hoch"
      console.log('[COMPLEXITY] Single FASS trade - ensuring medium-high complexity');
    }
  }
  
  // SCHRITT 4: INTAKE-ANTWORTEN AUSWERTEN
  let intakeData = { flaechen: {}, stueckzahlen: {} }; // Initialisiere mit leeren Objekten
  if (intakeAnswers && intakeAnswers.length > 0) {
    intakeData = extractCalculationDataFromIntake(intakeAnswers);
    
    // Flächen-basierte Anpassungen
    if (intakeData.flaechen.dachflaeche) {
      const area = parseFloat(intakeData.flaechen.dachflaeche);
      if (area > 300) complexityScore += 2;
      else if (area > 150) complexityScore += 1;
    }
    
    if (intakeData.flaechen.fassadenflaeche) {
      const area = parseFloat(intakeData.flaechen.fassadenflaeche);
      if (area > 400) complexityScore += 2;
      else if (area > 200) complexityScore += 1;
    }
    
    // Geschoss-Anzahl
    if (intakeData.stueckzahlen.geschosse) {
      const floors = parseInt(intakeData.stueckzahlen.geschosse);
      if (floors > 3) complexityScore += 2;
      else if (floors > 2) complexityScore += 1;
    }
    
    // Anzahl der Intake-Fragen als Indikator
    if (intakeAnswers.length > 24) {
      complexityScore += 2;
    } else if (intakeAnswers.length > 20) {
      complexityScore += 1;
    }
  }
  
  // SCHRITT 5: BUDGET
  if (projectContext.budget) {
    const budget = parseFloat(projectContext.budget);
    
    // Spezielle Bewertung für hochkomplexe Einzelgewerke
    if (hasVeryComplexTrade && tradeCount <= 3) {
      if (budget > 80000) complexityScore += 2;
      else if (budget > 40000) complexityScore += 1;
    } else {
      // Standard-Budget-Bewertung
      if (budget > 500000) complexityScore += 4;
      else if (budget > 200000) complexityScore += 3;
      else if (budget > 100000) complexityScore += 2;
      else if (budget > 50000) complexityScore += 1;
    }
  }
  
  // SCHRITT 6: KEYWORD-BONUS (nur additiv)
  const highKeywords = ['kernsanierung', 'komplettsanierung', 'denkmalschutz', 
                        'brandschutz', 'statiker', 'architekt', 'asbest'];
  const mediumKeywords = ['sanierung', 'modernisierung', 'energetisch', 'dämmung'];
  
  const foundHigh = highKeywords.filter(k => combinedText.includes(k));
  const foundMedium = mediumKeywords.filter(k => combinedText.includes(k));
  
  if (foundHigh.length > 0) {
    complexityScore += Math.min(foundHigh.length * 2, 4);
  }
  if (foundMedium.length > 0) {
    complexityScore += Math.min(foundMedium.length, 2);
  }
  
  // FINALE KLASSIFIZIERUNG mit KONTEXT-CAPS
  console.log(`[COMPLEXITY] Raw Score: ${complexityScore}`);
  
  // Spezielle Caps für bestimmte Projekttypen
  const subCat = (projectContext.sub_category || '').toLowerCase();
  
  // === CAPS FÜR BEGRENZTE PROJEKTE ===
  
  // Badsanierung
if (subCat.includes('badsanierung')) {
  // Luxus-Bad oder barrierefrei: KEIN Cap, kann hoch bleiben
  if (combinedText.includes('luxus') || combinedText.includes('barrierefrei')) {
    complexityScore = Math.max(complexityScore, 14); // Mindestens "hoch"
  }
  // Mehrere Bäder: auch komplex
  else if (combinedText.includes('mehrere')) {
    complexityScore = Math.max(complexityScore, 14); // Mindestens "hoch"
  }
  // Standard-Bad mit wenigen Gewerken
  else if (tradeCount <= 4) {
    complexityScore = Math.min(complexityScore, 11); // Mittleres "mittel"
  }
  // Standard-Bad mit mehreren Gewerken
  else if (tradeCount <= 6) {
    complexityScore = Math.min(complexityScore, 13); // Oberes "mittel"
  }
  // Sehr große Badsanierung (>6 Gewerke)
  else {
    complexityScore = Math.min(complexityScore, 16); // Unteres "hoch"
  }
}
  
  // Küchensanierung
  if (subCat.includes('küchensanierung')) {
    if (tradeCount <= 5 && !combinedText.includes('luxus')) {
      complexityScore = Math.min(complexityScore, 14); // Max "hoch"
    }
  }
  
  // Wohnungssanierung
  if ((combinedText.includes('wohnung') && combinedText.includes('sanierung')) ||
      subCat.includes('teilsanierung')) {
    if (tradeCount <= 8 && !combinedText.includes('kernsanierung')) {
      complexityScore = Math.min(complexityScore, 13); // Basis "mittel-hoch"
      
      // Modifikatoren
      if (combinedText.includes('altbau')) complexityScore += 1;
      if (combinedText.includes('komplett')) complexityScore += 1;
      if (intakeData?.flaechen?.wohnflaeche > 120) complexityScore += 1;
    }
  }
  
  // Entkernung Wohnung
  if (subCat.includes('entkernung')) {
    if (combinedText.includes('wohnung') || tradeCount <= 2) {
      complexityScore = Math.min(complexityScore, 10); // Basis "mittel"
      
      if (combinedText.includes('asbest')) complexityScore += 4;
      if (combinedText.includes('tragend')) complexityScore += 2;
    }
  }
  
  // Dachausbau ohne Gauben
  if (subCat.includes('dachausbau')) {
    if (!combinedText.includes('gaube') && !combinedText.includes('aufstockung')) {
      complexityScore = Math.min(complexityScore, 16); // Max "hoch"
    }
  }
  
  // === MINDEST-SCORES FÜR KRITISCHE GEWERKE ===
  
  detectedTrades.forEach(trade => {
    const tradeConfig = TRADE_COMPLEXITY[trade.code];
    if (tradeConfig?.minScore && tradeCount <= 3) {
      // Bei wenigen Gewerken: Mindest-Score durchsetzen
      if (complexityScore < tradeConfig.minScore) {
        complexityScore = tradeConfig.minScore;
        console.log(`[COMPLEXITY] ${trade.code} raised to minimum ${tradeConfig.minScore}`);
      }
    }
  });
  
  // === SPEZIELLE GEWERKE-MODIFIKATOREN ===
  
  // PV-Modifikatoren
  if (detectedTrades.some(t => t.code === 'PV')) {
    if (combinedText.includes('speicher')) complexityScore += 1;
    if (combinedText.includes('wallbox')) complexityScore += 1;
    if (combinedText.includes('notstrom')) complexityScore += 2;
  }
  
  // Klima-Modifikatoren
  if (detectedTrades.some(t => t.code === 'KLIMA')) {
    if (combinedText.includes('zentral')) complexityScore += 2;
    if (combinedText.includes('wärmerückgewinnung')) complexityScore += 1;
  }
  
  // FINALE KLASSIFIZIERUNG
  console.log(`[COMPLEXITY] Final Score: ${complexityScore}`);
  
  let finalComplexity;
  if (complexityScore >= 20) {
    finalComplexity = 'sehr_hoch';
  } else if (complexityScore >= 14) {
    finalComplexity = 'hoch';
  } else if (complexityScore >= 10) {
    finalComplexity = 'mittel';
  } else if (complexityScore >= 6) {
    finalComplexity = 'niedrig';
  } else {
    finalComplexity = 'einfach';
  }
  
  return finalComplexity;
}

/**
 * NEU: Intelligente Intake-Fragenanzahl basierend auf Gewerke-Count
 */
function getIntakeQuestionCount(projectContext) {
  const tradeCount = projectContext.detectedTrades?.length || 0;
  const complexity = determineProjectComplexity(projectContext, []);
  
  // Basis-Ranges für Intake
  const INTAKE_RANGES = {
    SINGLE_TRADE: { min: 14, max: 18 },    // 1 Gewerk
    SMALL_PROJECT: { min: 16, max: 20 },   // 2-3 Gewerke
    MEDIUM_PROJECT: { min: 18, max: 24 },  // 4-5 Gewerke
    LARGE_PROJECT: { min: 22, max: 28 }    // 6+ Gewerke
  };
  
  let range;
  
  // Primär nach Gewerke-Anzahl
  if (tradeCount === 1) {
    range = INTAKE_RANGES.SINGLE_TRADE;
  } else if (tradeCount <= 3) {
    range = INTAKE_RANGES.SMALL_PROJECT;
  } else if (tradeCount <= 5) {
    range = INTAKE_RANGES.MEDIUM_PROJECT;
  } else {
    range = INTAKE_RANGES.LARGE_PROJECT;
  }
  
  // Feintuning basierend auf Komplexität
  let targetCount = range.min;
  
  switch(complexity) {
    case 'SEHR_HOCH':
      targetCount = range.max;
      break;
    case 'HOCH':
      targetCount = Math.round((range.min + range.max) * 0.75 / 2);
      break;
    case 'MITTEL':
      targetCount = Math.round((range.min + range.max) / 2);
      break;
    case 'NIEDRIG':
      targetCount = Math.round((range.min + range.max) * 0.35 / 2);
      break;
    case 'EINFACH':
      targetCount = range.min;
      break;
  }
  
  // Spezialfälle
  if (projectContext.description) {
    const desc = projectContext.description.toLowerCase();
    
    // Weniger Fragen bei sehr spezifischen Einzelmaßnahmen
    if (tradeCount === 1 && (
      desc.includes('nur') || 
      desc.includes('lediglich') || 
      desc.includes('ausschließlich')
    )) {
      targetCount = Math.max(8, targetCount - 2);
    }
    
    // Mehr Fragen bei Koordinationsbedarf
    if (desc.includes('koordination') || 
        desc.includes('gleichzeitig') || 
        desc.includes('bewohnt während')) {
      targetCount = Math.min(range.max, targetCount + 2);
    }
    
    // Mehr Fragen bei besonderen Anforderungen
    if (desc.includes('denkmalschutz') || 
        desc.includes('brandschutz') || 
        desc.includes('schadstoffe')) {
      targetCount = Math.min(range.max + 2, targetCount + 3);
    }
  }
  
  console.log(`[INTAKE] Trade count: ${tradeCount}, Complexity: ${complexity}, Target questions: ${targetCount}`);
  
  return {
    count: targetCount,
    range: range,
    tradeCount: tradeCount,
    complexity: complexity,
    reasoning: `${tradeCount} Gewerk(e) erkannt → ${targetCount} Intake-Fragen`
  };
}

/**
 * Trade-Zuordnung prüfen
 */
async function isTradeAssignedToProject(projectId, tradeId) {
  const result = await query(
    'SELECT 1 FROM project_trades WHERE project_id = $1 AND trade_id = $2',
    [projectId, tradeId]
  );
  return result.rows.length > 0;
}

/**
 * Projekt-Trade Verknüpfung
 */
async function ensureProjectTrade(projectId, tradeId, source = 'unknown') {
  const exists = await isTradeAssignedToProject(projectId, tradeId);
  
  if (!exists) {
    console.log(`[PROJECT_TRADE] Adding trade ${tradeId} to project ${projectId} (source: ${source})`);
    await query(
      `INSERT INTO project_trades (project_id, trade_id)
       VALUES ($1, $2)
       ON CONFLICT (project_id, trade_id) DO NOTHING`,  
      [projectId, tradeId]
    );
  }
}

/**
 * Alle Trades eines Projekts abrufen
 */
async function getProjectTrades(projectId) {
  // FIXED: Lade auch die Flags aus project_trades
  const result = await query(
    `SELECT 
       t.*,
       pt.is_manual,
       pt.is_ai_recommended,
       pt.is_additional
     FROM trades t
     JOIN project_trades pt ON pt.trade_id = t.id
     WHERE pt.project_id = $1
     ORDER BY
       CASE WHEN COALESCE(pt.is_manual, false) THEN 1 ELSE 0 END,
       t.sort_order,
       t.id`,
    [projectId]
  );
  return result.rows;
}

/**
 * Prompt aus DB laden
 */
async function getPromptByName(name) {
  try {
    const result = await query(
      'SELECT content FROM prompts WHERE name = $1 LIMIT 1',
      [name]
    );
    if (result.rows.length === 0) {
      console.warn(`[DB] Prompt "${name}" not found`);
      return '';
    }
    return result.rows[0].content || '';
  } catch (err) {
    console.error(`[DB] Error loading prompt "${name}":`, err);
    return '';
  }
}

/**
 * Prompt für spezifisches Gewerk laden
 */
async function getPromptForTrade(tradeId, type) {
  try {
    const result = await query(
      `SELECT content FROM prompts 
       WHERE trade_id = $1 AND type = $2 
       ORDER BY updated_at DESC LIMIT 1`,
      [tradeId, type]
    );
    if (result.rows.length === 0) {
      console.warn(`[DB] No ${type} prompt found for trade ${tradeId}`);
      return '';
    }
    return result.rows[0].content || '';
  } catch (err) {
    console.error(`[DB] Error loading ${type} prompt for trade ${tradeId}:`, err);
    return '';
  }
}

/**
 * Alle verfügbaren Gewerke laden
 */
async function getAvailableTrades() {
  try {
    const result = await query(
      'SELECT id, code, name, sort_order FROM trades ORDER BY sort_order, id'
    );
    return result.rows;
  } catch (err) {
    console.error('[DB] Failed to load trades:', err);
    return [];
  }
}

/**
 * Gewerke-Erkennung mit LLM
 */
async function detectTrades(project) {
  console.log('[DETECT] Starting trade detection for project:', project);
  
  const masterPrompt = await getPromptByName('master');

// VALIDIERE Masterprompt
if (!masterPrompt) {
  console.error('[DETECT] CRITICAL: Master prompt missing!');
  throw new Error('Master-Prompt fehlt in der Datenbank - Gewerke-Erkennung nicht möglich');
}

if (masterPrompt.length < 500) {
  console.warn(`[DETECT] WARNING: Master prompt suspiciously short: ${masterPrompt.length} chars`);
}

// DEBUG: Prüfe ob wichtige Regeln im Masterprompt sind
const criticalRules = [
  'DACHARBEITEN',
  'ABBRUCH-GEWERK',
  'GERÜST',
  'FENSTER/TÜREN',
  'SANITÄR/HEIZUNG/ELEKTRO',
  'FASSADE vs. PUTZ/MALER',
  'GEWERKEABGRENZUNG'
];

const missingRules = criticalRules.filter(rule => 
  !masterPrompt.includes(rule)
);

if (missingRules.length > 0) {
  console.warn('[DETECT] Master prompt missing critical rules:', missingRules);
  console.warn('[DETECT] This may lead to incorrect trade detection!');
}

console.log(`[DETECT] Master prompt loaded: ${masterPrompt.length} chars, ${criticalRules.length - missingRules.length}/${criticalRules.length} critical rules found`);

// DANN GEHT ES WEITER MIT DEM BESTEHENDEN CODE:
const availableTrades = await getAvailableTrades();
  
if (availableTrades.length === 0) {
  throw new Error('No trades available in database');
}
  
  const tradeList = availableTrades
    .filter(t => t.code !== 'INT') // INT wird separat behandelt
    .map(t => `- ${t.code}: ${t.name}`)
    .join('\n');
  
  const systemPrompt = `${masterPrompt}

Du bist ein erfahrener Baukoordinator für die BYNDL-Plattform.
Analysiere die Projektbeschreibung und erkenne NUR die tatsächlich benötigten Gewerke.

KRITISCHE GEWERKE-ABGRENZUNGEN (IMMER EINHALTEN):

1. DACHARBEITEN:
   - Dachdecker (DACH) übernimmt ALLES am Dach:
     * Rückbau alte Eindeckung und Entsorgung
     * Neue Eindeckung und Abdichtung
     * ALLE Klempnerarbeiten (Rinnen, Fallrohre, Bleche, Kehlen)
     * Dachfenster-Einbau (Abdichtung)
     * Schneefangsysteme
   - NIEMALS Abbruch (ABBR) für Dacharbeiten!
   - NIEMALS Fassade (FASS) für Dachrinnen!
   - NIEMALS Rohbau (ROH) für Rückbauarbeiten am Dach!
   - NIEMALS Schlosser/Metallbau (SCHL) für Dachrinnen und Fallrohre!
   - NIEMALS Fenster/Türen (FEN) für Innentüren! 

2. ABBRUCH-GEWERK (ABBR) - NUR HINZUFÜGEN WENN:
   - Umfangreiche Sanierung mit 3+ anderen Gewerken (Komplettmodernisierung)
   - Schadstoffe wie Asbest erwähnt/vermutet werden (Spezialentsorgung)
   - Komplette Entkernung oder Teilentkernung geplant
   - Mehrere Wände entfernt werden
   - NICHT bei einzelnen Gewerken (Bad, Küche, Dach allein)
   - NICHT wenn nur 1-2 andere Gewerke beteiligt sind

3. SANITÄR/HEIZUNG/ELEKTRO:
   - Sanitär (SAN): Wasser, Abwasser, Sanitärobjekte, eigene Wanddurchbrüche (Kernbohrungen), Rückbau alter Installationen
   - Heizung (HEI): Wärmeerzeugung, Heizkörper, Fußbodenheizung, Rückbau alter Heizungsanlagen
   - Elektro (ELEKT): Strom, Schalter, Smart Home, eigene Schlitze, KOMPLETTER Rückbau alter Elektroinstallationen (Kabel, Dosen, Verteiler)
   - Lüftung/Klima (KLIMA): Lüftungsanlagen, Klimageräte, Luftkanäle, Wärmerückgewinnung, Luftqualität
   - Jedes Gewerk macht EIGENE Rückbauarbeiten, Schlitze und Durchbrüche!
   - KEIN separates Abbruch-Gewerk für TGA-Rückbau!

4. FASSADE vs. PUTZ/MALER:
   - Fassade (FASS): NUR Außen-WDVS, Klinker, vorgehängte Fassaden
   - Maler (MAL): Innenputz, Innenanstriche, einfache Fassadenanstriche
   - Bei reinem Fassadenanstrich: NUR Maler, NICHT Fassade

5. ROHBAU vs. ABBRUCH:
   - Rohbau (ROH): Neue Wände, Decken, Fundamente
   - Abbruch (ABBR): NUR bei Abriss oder (Teil-)Entkernung
   - Wanddurchbrüche: Immer Rohbau (ROH) wegen statischem Eingriff

6. SANITÄR/HEIZUNG/ELEKTRO:
   - Sanitär (SAN): Wasser, Abwasser, Sanitärobjekte, Wanddurchbrüche für Leitungen
   - Heizung (HEI): Wärmeerzeugung, Heizkörper, Fußbodenheizung
   - Elektro (ELEKT): Strom, Schalter, Smart Home, eigene Schlitze
   - Jedes Gewerk macht EIGENE Schlitze und Durchbrüche!

7. TROCKENBAU vs. TISCHLER:
   - Trockenbau (TRO): Rigips- bzw. Gipskartonwände, abgehängte Decken, Vorsatzschalen
   - Tischler (TIS): Türen, Zargen, Holzverkleidungen, Einbaumöbel
   - NIEMALS Türen im Trockenbau!

8. FLIESEN vs. BODENBELAG:
   - Fliesen (FLI): ALLE Fliesenarbeiten, Naturstein in Bad/Küche
   - Bodenbelag (BOD): Parkett, Laminat, Vinyl, Teppich - NIEMALS Fliesen!

9. GERÜSTBAU:
   - Wenn Gerüst (GER) erforderlich immer als eigenes Gewerk → KEINE Gerüstpositionen in anderen Gewerken

10. ESTRICH:
   - Estrich (ESTR): Alle Estricharten, Dämmung unter Estrich
   - NICHT: Oberbeläge (gehören zu FLI oder BOD)

11. FENSTER/TÜREN:
   - Fenster (FEN): Außenfenster, Fenstertüren, Rollläden, Haustüren
   - Tischler (TIS): Innentüren, Zargen
   - Dachdecker (DACH): Dachfenster-Abdichtung

12. AUSSENANLAGEN:
    - Garten (AUSS): Pflaster, Zäune, Terrassen, Gartenbau
    - NICHT Balkonsanierung (gehört zu DACH oder FASS je nach Abdichtung)

13. ZIMMERER vs. TISCHLER vs. FENSTER:
   - Zimmerer (ZIMM): Dachstuhl, tragende Holzkonstruktionen, Holzrahmenbau, Carports, Pergolen
   - Tischler (TIS): Innentüren, Wohnungseingangstüren (nicht Haustüren!), Möbel, nicht-tragende Verkleidungen
   - Fenster (FEN): ALLE Fenster inkl. Holzfenster (außer Dachfenster)
   - Dachdecker (DACH): Dachfenster-Einbau und -Abdichtung
   - NIEMALS Fenster im Zimmerer-Gewerk!
   - NIEMALS Dachstuhl im Tischler-Gewerk!
   - NIEMALS Sockelleisten im Tischler-Gewerk!
   
GENERELLE REGELN:
- Qualität vor Quantität - lieber weniger richtige Gewerke
- Bei Unsicherheit: Hauptgewerk übernimmt Nebenleistungen
- Spezialisierte Gewerke haben Vorrang
- NIEMALS "INT" zurückgeben
- Maximal 7-9 Gewerke pro Projekt (außer Großprojekte)

WICHTIG BEI IMPLIED TRADES:
- Wenn vorgeschlagene Gewerke mit Konfidenz >= 80% übergeben werden, MÜSSEN diese übernommen werden
- Bei Badsanierung IMMER Trockenbau (TRO) für Vorwandinstallation einplanen
- Begründe wenn du ein hochkonfidentes impliedTrade NICHT übernimmst

VERFÜGBARE GEWERKE (NUR DIESE VERWENDEN!):
${tradeList}

OUTPUT FORMAT (NUR valides JSON):
{
  "trades": [
    {"code": "SAN", "name": "Sanitärinstallation"},
    {"code": "ELEKT", "name": "Elektroinstallation"}
  ],
  "confidence": 0.95,
  "reasoning": "Kurze Begründung der Auswahl",
  "projectInfo": {
    "type": "Wohnung/EFH/MFH/Gewerbe",
    "scope": "Neubau/Sanierung/Modernisierung",
    "estimatedDuration": "4-6 Wochen",
    "criticalTrades": ["SAN", "ELEKT"]
  }
}`;

  const userPrompt = `PROJEKTDATEN:
Kategorie: ${project.category || 'Nicht angegeben'}
Unterkategorie: ${project.subCategory || 'Nicht angegeben'}
Beschreibung: ${project.description || 'Keine Beschreibung'}
Zeitrahmen: ${project.timeframe || 'Nicht angegeben'}
Budget: ${project.budget || 'Nicht angegeben'}

${project.extractedData?.impliedTrades?.length > 0 ? `
VORGESCHLAGENE GEWERKE (aus Analyse):
${project.extractedData.impliedTrades.map(t => 
  `- ${t.code}: ${t.reason} (Konfidenz: ${t.confidence}%)`
).join('\n')}

WICHTIG: Übernimm alle Gewerke mit Konfidenz >= 80%!
` : ''}

${project.extractedData?.measures?.length > 0 ? `
Maßnahmen: ${project.extractedData.measures.join(', ')}
` : ''}

${project.extractedData?.rooms?.length > 0 ? `
Räume: ${project.extractedData.rooms.join(', ')}
` : ''}

Analysiere diese Daten und gib die benötigten Gewerke als JSON zurück.`;

  try {
    const llmResponse = await llmWithPolicy('detect', [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], { 
      maxTokens: 3000,
      temperature: 0.3,
      jsonMode: true 
    });
    
    const cleanedResponse = llmResponse
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .trim();
    
    const parsedResponse = JSON.parse(cleanedResponse);
    
    if (!parsedResponse.trades || !Array.isArray(parsedResponse.trades)) {
      throw new Error('Invalid response structure');
    }
    
    const detectedTrades = [];
    const usedIds = new Set();
    
    for (const trade of parsedResponse.trades) {
      if (trade.code === 'INT') continue; // Skip INT
      
      const dbTrade = availableTrades.find(t => 
        t.code === trade.code || 
        t.name.toLowerCase() === trade.name?.toLowerCase()
      );
      
      if (dbTrade && !usedIds.has(dbTrade.id)) {
        usedIds.add(dbTrade.id);
        detectedTrades.push({
          id: dbTrade.id,
          code: dbTrade.code,
          name: dbTrade.name
        });
      }
    }

// ═══════════════════════════════════════════════════════════════
// KERNSANIERUNG-DETECTION MIT GEBÄUDE/WOHNUNGS-DIFFERENZIERUNG
// ═══════════════════════════════════════════════════════════════

const descLower = (project.description || '').toLowerCase();
const categoryLower = (project.category || '').toLowerCase();
const subCategoryLower = (project.subCategory || '').toLowerCase();
const fullText = `${descLower} ${categoryLower} ${subCategoryLower}`;

// 1. Prüfe auf Kernsanierung-Keywords
const hasKernsanierungKeyword = 
  fullText.includes('kernsanierung') || 
  fullText.includes('totalsanierung') ||
  fullText.includes('vollsanierung') ||
  fullText.includes('komplettsanierung') ||
  fullText.includes('komplette sanierung');

if (hasKernsanierungKeyword) {
  console.log('[DETECT] Kernsanierung-Keyword erkannt, analysiere Scope...');
  
  // 2. AUSSCHLUSS: Einzelne Räume (KEINE Kernsanierung)
  const isSingleRoom = 
    fullText.includes('bad') ||
    fullText.includes('badezimmer') ||
    fullText.includes('wc') ||
    fullText.includes('küche') ||
    fullText.includes('wohnzimmer') ||
    fullText.includes('schlafzimmer') ||
    fullText.includes('kinderzimmer') ||
    fullText.includes('arbeitszimmer') ||
    fullText.includes('flur') ||
    fullText.includes('balkon') ||
    fullText.includes('terrasse') ||
    fullText.includes('keller') && !fullText.includes('kellersanierung') ||
    fullText.includes('dachboden') && !fullText.includes('dachausbau') ||
    (fullText.match(/(\d+)\s*m[²2]/) && parseInt(fullText.match(/(\d+)\s*m[²2]/)?.[1] || '0') < 40);
  
  if (isSingleRoom) {
    console.log('[DETECT] Kernsanierung-Keyword, aber nur einzelner Raum - normale Detection');
    // Fahre mit normaler Detection fort (kein Override)
  } else {
    // 3. Unterscheide: Ganzes GEBÄUDE vs. WOHNUNG/ETAGE
    const isFullBuilding = 
      fullText.includes('einfamilienhaus') ||
      fullText.includes('mehrfamilienhaus') ||
      fullText.includes('reihenhaus') ||
      fullText.includes('doppelhaushälfte') ||
      fullText.includes('haus kernsanierung') ||
      fullText.includes('haus komplettsanierung') ||
      fullText.includes('gebäude') && !fullText.includes('wohnung') ||
      fullText.includes('villa') ||
      fullText.includes('bungalow');
    
    const isApartmentOrFloor = 
      fullText.includes('wohnung') ||
      fullText.includes('eigentumswohnung') ||
      fullText.includes('mietwohnung') ||
      fullText.includes('apartment') ||
      fullText.includes('etage') ||
      fullText.includes('stockwerk') ||
      fullText.includes('geschoss') ||
      fullText.includes('penthouse') ||
      fullText.includes('maisonette') ||
      (fullText.match(/(\d+)\s*m[²2]/) && parseInt(fullText.match(/(\d+)\s*m[²2]/)?.[1] || '0') >= 40 && parseInt(fullText.match(/(\d+)\s*m[²2]/)?.[1] || '0') <= 200);
    
    // ═══════════════════════════════════════════════════════════
    // CASE A: GEBÄUDE-KERNSANIERUNG (Haus, Villa, etc.)
    // ═══════════════════════════════════════════════════════════
    if (isFullBuilding) {
      console.log('[DETECT] GEBÄUDE-Kernsanierung erkannt - füge ALLE Gewerke hinzu');
      
      // ALLE Gewerke außer AUSS, PV, KLIMA
      const fullBuildingTrades = ['ABBR', 'ROH', 'ELEKT', 'SAN', 'HEI', 'TRO', 'FLI', 'MAL', 
                                   'GER', 'ZIMM', 'DACH', 'FEN', 'FASS', 'ESTR', 'TIS', 'BOD', 'SCHL'];
      
      for (const tradeCode of fullBuildingTrades) {
        const trade = availableTrades.find(t => t.code === tradeCode);
        if (trade && !usedIds.has(trade.id)) {
          detectedTrades.push({
            id: trade.id,
            code: trade.code,
            name: trade.name
          });
          usedIds.add(trade.id);
          console.log(`[DETECT] Gebäude-Kernsanierung: Added ${trade.code} (required)`);
        }
      }
    }
    
    // ═══════════════════════════════════════════════════════════
    // CASE B: WOHNUNGS/ETAGEN-KERNSANIERUNG
    // ═══════════════════════════════════════════════════════════
    else if (isApartmentOrFloor) {
      console.log('[DETECT] WOHNUNGS-Kernsanierung erkannt');
      
      // INNEN-Gewerke (Required)
      const apartmentRequiredTrades = ['ABBR', 'ELEKT', 'SAN', 'HEI', 'TRO', 'FLI', 
                                        'MAL', 'ESTR', 'TIS', 'BOD'];
      
      // GEBÄUDEHÜLLE-Gewerke (Optional/AI-recommended)
      const apartmentOptionalTrades = ['ROH', 'ZIMM', 'DACH', 'FEN', 'FASS', 'GER', 'SCHL'];
      
      // Füge REQUIRED Gewerke hinzu
      for (const tradeCode of apartmentRequiredTrades) {
        const trade = availableTrades.find(t => t.code === tradeCode);
        if (trade && !usedIds.has(trade.id)) {
          detectedTrades.push({
            id: trade.id,
            code: trade.code,
            name: trade.name
          });
          usedIds.add(trade.id);
          console.log(`[DETECT] Wohnungs-Kernsanierung: Added ${trade.code} (required)`);
        }
      }
      
      // Füge OPTIONAL Gewerke als AI-recommended hinzu
      for (const tradeCode of apartmentOptionalTrades) {
        const trade = availableTrades.find(t => t.code === tradeCode);
        if (trade && !usedIds.has(trade.id)) {
          // Markiere als optional/AI-recommended
          detectedTrades.push({
            id: trade.id,
            code: trade.code,
            name: trade.name,
            isAiRecommended: true,  // Als optional markieren
            reason: 'Kann bei Wohnungssanierung relevant sein (z.B. bei Fenstertausch oder statischen Änderungen)'
          });
          usedIds.add(trade.id);
          console.log(`[DETECT] Wohnungs-Kernsanierung: Added ${trade.code} (ai-recommended)`);
        }
      }
    }
    
    // ═══════════════════════════════════════════════════════════
    // CASE C: Unklar - konservativ ALLE hinzufügen
    // ═══════════════════════════════════════════════════════════
    else {
      console.log('[DETECT] Kernsanierung erkannt, aber Scope unklar - füge ALLE hinzu');
      
      const allKernsanierungTrades = ['ABBR', 'ROH', 'ELEKT', 'SAN', 'HEI', 'TRO', 'FLI', 'MAL', 
                                       'GER', 'ZIMM', 'DACH', 'FEN', 'FASS', 'ESTR', 'TIS', 'BOD', 'SCHL'];
      
      for (const tradeCode of allKernsanierungTrades) {
        const trade = availableTrades.find(t => t.code === tradeCode);
        if (trade && !usedIds.has(trade.id)) {
          detectedTrades.push({
            id: trade.id,
            code: trade.code,
            name: trade.name
          });
          usedIds.add(trade.id);
          console.log(`[DETECT] Kernsanierung (unklar): Added ${trade.code}`);
        }
      }
    }
  }
}
    
    if (detectedTrades.length === 0) {
      throw new Error('No valid trades detected');
    }
    
    // NEU: Automatisch Gerüst hinzufügen wenn nötig
    const needsScaffolding = detectedTrades.some(t => 
      ['DACH', 'FASS', 'FEN'].includes(t.code)
    );
    
    // Oder aus extractedData wenn vorhanden
    const extractedNeedsScaffolding = project.extractedData?.specificDetails?.needsScaffolding;
    
    if ((needsScaffolding || extractedNeedsScaffolding) && 
        !detectedTrades.some(t => t.code === 'GER')) {
      
      // Gerüstbau-Trade aus DB holen
      const scaffoldTrade = availableTrades.find(t => t.code === 'GER');
      if (scaffoldTrade && !usedIds.has(scaffoldTrade.id)) {
        console.log('[DETECT] Auto-adding Gerüstbau for Dach/Fassade/Fenster work');
        detectedTrades.push({
          id: scaffoldTrade.id,
          code: scaffoldTrade.code,
          name: scaffoldTrade.name
        });
      }
    }
    // NEU: Automatisch PV erkennen
const needsPV = project.description?.toLowerCase().includes('pv') || 
                 project.description?.toLowerCase().includes('photovoltaik') ||
                 project.description?.toLowerCase().includes('solar') ||
                 project.description?.toLowerCase().includes('solaranlage');

if (needsPV && !detectedTrades.some(t => t.code === 'PV')) {
  const pvTrade = availableTrades.find(t => t.code === 'PV');
  if (pvTrade && !usedIds.has(pvTrade.id)) {
    console.log('[DETECT] Auto-adding PV for solar/photovoltaik keywords');
    detectedTrades.push({
      id: pvTrade.id,
      code: pvTrade.code,
      name: pvTrade.name
    });
  }
}
    
    console.log('[DETECT] Successfully detected trades:', detectedTrades);
    return detectedTrades;
    
  } catch (err) {
    console.error('[DETECT] Trade detection failed:', err);
    throw new Error('Gewerke-Erkennung fehlgeschlagen');
  }
}

/**
 * PRÄZISE EXTRAKTION VON KALKULATIONSDATEN AUS INTAKE-ANTWORTEN
 * Unterscheidet klar zwischen verschiedenen Dimensionen und Kontexten
 */

function extractCalculationDataFromIntake(intakeAnswers) {
  const knownData = {
    flaechen: {},
    laengen: {},
    breiten: {},
    hoehen: {},
    stueckzahlen: {},
    volumen: {},
    gewichte: {},
    materialien: {},
    rawData: []
  };
  
  intakeAnswers.forEach(item => {
    const question = (item.question_text || '').toLowerCase();
    const answer = (item.answer_text || '').trim();
    
    // Speichere für Debug
    knownData.rawData.push(`${item.question_text}: ${answer}`);
    
    // ========== FLÄCHEN (m²) ==========
    if (question.includes('fläche')) {
      // Unterscheide WELCHE Fläche
      if (question.includes('wohnfläche') || question.includes('gesamtfläche')) {
        knownData.flaechen.wohnflaeche_gesamt = answer;
      }
      else if (question.includes('bad')) {
        knownData.flaechen.badflaeche_gesamt = answer;
      }
      else if (question.includes('dach')) {
        knownData.flaechen.dachflaeche = answer;
      }
      else if (question.includes('fassade')) {
        knownData.flaechen.fassadenflaeche = answer;
      }
      else if (question.includes('garten') || question.includes('grundstück')) {
        knownData.flaechen.grundstueck = answer;
      }
    }
    
    // ========== HÖHEN (m/cm) ==========
    if (question.includes('höhe')) {
      // Unterscheide WELCHE Höhe
      if (question.includes('raum') || question.includes('decke')) {
        knownData.hoehen.raumhoehe = answer;
      }
      else if (question.includes('gebäude') || question.includes('first')) {
        knownData.hoehen.gebaeudehoehe = answer;
      }
      else if (question.includes('keller')) {
        knownData.hoehen.kellerhoehe = answer;
      }
      else if (question.includes('geschoss')) {
        knownData.hoehen.geschosshoehe = answer;
      }
    }
    
    // ========== LÄNGEN (m/cm) ==========
    if (question.includes('länge') || question.includes('lang')) {
      if (question.includes('wand')) {
        knownData.laengen.wandlaenge = answer;
      }
      else if (question.includes('raum')) {
        knownData.laengen.raumlaenge = answer;
      }
      else if (question.includes('flur') || question.includes('gang')) {
        knownData.laengen.flurlaenge = answer;
      }
    }
    
    // ========== BREITEN (m/cm) ==========
    if (question.includes('breite') || question.includes('breit')) {
      if (question.includes('wand')) {
        knownData.breiten.wandbreite = answer;
      }
      else if (question.includes('raum')) {
        knownData.breiten.raumbreite = answer;
      }
      else if (question.includes('fenster')) {
        knownData.breiten.fensterbreite = answer;
      }
      else if (question.includes('tür')) {
        knownData.breiten.tuerbreite = answer;
      }
    }
    
    // ========== SPEZIELLE MASSE ==========
    // Wandstärke (meist in cm)
    if (question.includes('wandstärke') || question.includes('wanddicke') || 
        (question.includes('wand') && question.includes('dick'))) {
      knownData.hoehen.wandstaerke = answer; // Technisch eine "Dicke"
    }
    
    // ========== KOMBINIERTE MASSE (LxBxH) ==========
    if (question.includes('maße') || question.includes('abmessung')) {
      // Versuche zu parsen: "5x3x2,5m" oder "500x300x250cm"
      const match = answer.match(/(\d+(?:[.,]\d+)?)\s*[x×]\s*(\d+(?:[.,]\d+)?)\s*(?:[x×]\s*(\d+(?:[.,]\d+)?))?/i);
      if (match) {
        if (question.includes('bad')) {
          knownData.laengen.bad = match[1];
          knownData.breiten.bad = match[2];
          if (match[3]) knownData.hoehen.bad = match[3];
        }
        else if (question.includes('raum') || question.includes('zimmer')) {
          knownData.laengen.raum = match[1];
          knownData.breiten.raum = match[2];
          if (match[3]) knownData.hoehen.raum = match[3];
        }
      }
    }
    
    // ERWEITERTE STÜCKZAHLEN-ERFASSUNG
    if (question.includes('wie viele') || question.includes('anzahl')) {
      const numberMatch = answer.match(/\d+/);
      if (numberMatch) {
        const count = numberMatch[0];
        
        // Basis-Stückzahlen (wie bisher)
        if (question.includes('fenster') && !question.includes('dachfenster')) {
          knownData.stueckzahlen.fenster = count;
        }
        else if (question.includes('dachfenster')) {
          knownData.stueckzahlen.dachfenster = count;
        }
        else if (question.includes('tür')) {
          knownData.stueckzahlen.tueren = count;
        }
        else if (question.includes('raum') || question.includes('zimmer')) {
          knownData.stueckzahlen.raeume = count;
        }
        else if (question.includes('bad') || question.includes('bäder')) {
          knownData.stueckzahlen.baeder = count;
        }
        else if (question.includes('etage') || question.includes('geschoss') || question.includes('stockwerk')) {
          knownData.stueckzahlen.geschosse = count;
        }
        // NEU: Zusätzliche Stückzahlen
        else if (question.includes('wand') || question.includes('wände')) {
          knownData.stueckzahlen.waende = count;
        }
        else if (question.includes('heizkörper')) {
          knownData.stueckzahlen.heizkoerper = count;
        }
        else if (question.includes('steckdose')) {
          knownData.stueckzahlen.steckdosen = count;
        }
        else if (question.includes('schalter')) {
          knownData.stueckzahlen.schalter = count;
        }
        else if (question.includes('leuchte') || question.includes('lampe')) {
          knownData.stueckzahlen.leuchten = count;
        }
        else if (question.includes('rolladen') || question.includes('rollladen')) {
          knownData.stueckzahlen.rolladen = count;
        }
        // NEU: Gauben
        else if (question.includes('gaube') || question.includes('gauben')) {
          knownData.stueckzahlen.gauben = count;
        }
      }
    }  // <-- DIESE KLAMMER FEHLT! 
    // ========== MATERIALIEN ==========
    if (question.includes('material') || question.includes('ausführung')) {
      if (question.includes('wand')) {
        knownData.materialien.wand = answer;
      }
      else if (question.includes('boden')) {
        knownData.materialien.boden = answer;
      }
      else if (question.includes('dach')) {
        knownData.materialien.dach = answer;
      }
    }
  });
  
  return knownData;
}

/**
 * Generiert klaren Kontext für das LLM
 */
function createCalculationContext(knownData, tradeCode) {
  let context = `
╔════════════════════════════════════════════════════════════════╗
║ BEREITS BEKANNTE KALKULATIONSDATEN (NICHT ERNEUT ERFRAGEN!)   ║
╚════════════════════════════════════════════════════════════════╝
`;
  
  // FLÄCHEN
  if (Object.keys(knownData.flaechen).length > 0) {
    context += `\n▶ FLÄCHEN:\n`;
    Object.entries(knownData.flaechen).forEach(([key, value]) => {
      context += `  • ${key.replace(/_/g, ' ')}: ${value}\n`;
    });
  }
  
  // HÖHEN
  if (Object.keys(knownData.hoehen).length > 0) {
    context += `\n▶ HÖHEN:\n`;
    Object.entries(knownData.hoehen).forEach(([key, value]) => {
      context += `  • ${key.replace(/_/g, ' ')}: ${value}\n`;
    });
  }
  
  // LÄNGEN
  if (Object.keys(knownData.laengen).length > 0) {
    context += `\n▶ LÄNGEN:\n`;
    Object.entries(knownData.laengen).forEach(([key, value]) => {
      context += `  • ${key.replace(/_/g, ' ')}: ${value}\n`;
    });
  }
  
  // BREITEN
  if (Object.keys(knownData.breiten).length > 0) {
    context += `\n▶ BREITEN:\n`;
    Object.entries(knownData.breiten).forEach(([key, value]) => {
      context += `  • ${key.replace(/_/g, ' ')}: ${value}\n`;
    });
  }
  
  // STÜCKZAHLEN
  if (Object.keys(knownData.stueckzahlen).length > 0) {
    context += `\n▶ ANZAHL/STÜCK:\n`;
    Object.entries(knownData.stueckzahlen).forEach(([key, value]) => {
      context += `  • ${key.replace(/_/g, ' ')}: ${value}\n`;
    });
  }
  
  // MATERIALIEN
  if (Object.keys(knownData.materialien).length > 0) {
    context += `\n▶ MATERIALIEN:\n`;
    Object.entries(knownData.materialien).forEach(([key, value]) => {
      context += `  • ${key.replace(/_/g, ' ')}: ${value}\n`;
    });
  }
  
  // GEWERKE-SPEZIFISCHE HINWEISE
  context += `\n═══════════════════════════════════════════════════════════════\n`;
  context += `WICHTIG für ${tradeCode}:\n`;
  
  // Beispiele was NICHT mehr gefragt werden darf
  if (knownData.flaechen.badflaeche_gesamt) {
    context += `NICHT fragen: "Wie groß ist das Bad?" → Bereits bekannt: ${knownData.flaechen.badflaeche_gesamt}\n`;
    context += `ERLAUBT: "Davon Wandfläche zu fliesen?" oder "Davon Bodenfläche?"\n`;
  }
  
  if (knownData.hoehen.raumhoehe) {
    context += `NICHT fragen: "Wie hoch sind die Räume?" → Bereits bekannt: ${knownData.hoehen.raumhoehe}\n`;
    context += `ERLAUBT: Nutze diese Höhe für deine Berechnungen\n`;
  }
  
  if (knownData.stueckzahlen.fenster) {
    context += `NICHT fragen: "Wie viele Fenster?" → Bereits bekannt: ${knownData.stueckzahlen.fenster}\n`;
    context += `ERLAUBT: "Welche Maße haben die einzelnen Fenster?"\n`;
  }
  
  context += `\nREGEL: Frage NUR nach DETAILS die für DEIN Gewerk spezifisch sind!`;
  
  return context;
}

/**
 * Vollständige Gewerke-Validierung aus Intake-Antworten
 * NUR mit existierenden Gewerke-Codes aus dem System
 */

// KOMPLETTE GEWERKE-ZUORDNUNGSREGELN für alle 20 vorhandenen Gewerke
const TRADE_DETECTION_RULES = {
  // EXKLUSIVE Keywords - NUR dieses Gewerk darf diese Begriffe beanspruchen
  // WICHTIG: Keywords müssen AKTION/BEDARF signalisieren, nicht nur Objekte nennen
  exclusive: {
    'DACH': [
      'dach sanieren', 'dach erneuern', 'dach neu eindecken', 'dacheindeckung', 
      'neues dach', 'dach reparieren', 'dachziegel erneuern', 'dachziegel austauschen',
      'dachrinne erneuern', 'neue dachrinne', 'fallrohr erneuern', 'dachrinne montieren',
      'dachfenster einbauen', 'neue dachfenster', 'dachfenster austauschen',
      'dachsanierung', 'dacherneuerung', 'dach abdichten', 'dachabdichtung erneuern',
      'gauben bauen', 'gaube errichten', 'neue gaube', 'gaube sanieren',
      'dachsparren ersetzen', 'sparren aufdoppeln', 'sparren reparieren',
      'dachstuhl sanieren', 'klempnerarbeiten dach', 'schneefang montieren',
      'flachdach sanieren', 'bitumenbahn erneuern', 'dach komplett neu'
    ],
    
    'FASS': [
      'fassade sanieren', 'neues wdvs', 'fassade dämmen', 'fassadensanierung', 'fassadendämmung',
      'wdvs anbringen', 'wärmedämmverbundsystem', 'neue fassade', 'fassade erneuern',
      'außenputz erneuern', 'außenputz sanieren', 'fassade verputzen',
      'klinker verfugen', 'fassade streichen', 'fassadenanstrich', 
      'außendämmung anbringen', 'fassadenverkleidung montieren',
      'hinterlüftete fassade bauen', 'sockelputz erneuern', 'außenwand dämmen',
      'vorgehängte fassade', 'fassade komplett neu'
    ],
    
    'ZIMM': [
      'dachstuhl errichten', 'dachstuhl erneuern', 'neuer dachstuhl', 'dachstuhl bauen',
      'gaube bauen', 'neue gaube', 'gaube konstruieren', 'neue gaube errichten', 'gaube zimmern',
      'carport bauen', 'carport errichten', 'holzkonstruktion bauen',
      'holzrahmenbau errichten', 'aufstockung holz', 'holzaufbau',
      'sparren erneuern', 'neue sparren', 'holzbalken ersetzen',
      'pfetten montieren', 'holzständerbau errichten', 'pergola bauen',
      'holzterrasse überdachen', 'zimmererarbeiten', 'holzbau errichten'
    ],
    
    'ROH': [
      'wand mauern', 'neue wand mauern', 'mauerwerk errichten', 'mauern',
      'wanddurchbruch machen', 'durchbruch schaffen', 'wand durchbrechen',
      'betonieren', 'beton gießen', 'betonarbeiten', 'betondecke gießen',
      'fundament erstellen', 'fundament gießen', 'sturz einbauen', 'sturz setzen',
      'tragende wand errichten', 'decke durchbrechen', 'kernbohrung',
      'stahlbeton gießen', 'bewehrung einbauen', 'schalung bauen',
      'unterfangen', 'ringanker gießen', 'betontreppe bauen', 'maurerarbeiten'
    ],
    
    'TRO': [
      'rigipswand bauen', 'trockenbauwand errichten', 'rigips ziehen',
      'ständerwerk bauen', 'vorwand bauen', 'vorwandinstallation',
      'gipskartonwand errichten', 'ständerwand ziehen',
      'abgehängte decke bauen', 'decke abhängen', 'vorsatzschale bauen',
      'trockenbauwände ziehen', 'installationswand errichten',
      'schallschutzwand bauen', 'brandschutzwand errichten',
      'trockenbau komplett', 'rigips komplett'
    ],
    
    'TIS': [
      'innentüren einbauen', 'neue innentüren', 'türen austauschen', 'türen montieren',
      'zargen einbauen', 'neue zargen', 'zimmertüren erneuern',
      'wohnungseingangstür einbauen', 'wohnungstür montieren', 'neue wohnungstür',
      'einbauschrank bauen', 'schrank einbauen', 'einbauschränke',
      'küche einbauen', 'einbauküche montieren', 'küchenmöbel einbauen',
      'holzverkleidung innen', 'schiebetür einbauen', 'holztreppe bauen',
      'treppengeländer holz montieren', 'tischlerarbeiten'
    ],
    
    'FEN': [
      'fenster austauschen', 'neue fenster', 'fenster erneuern', 'fenster einbauen',
      'haustür einbauen', 'neue haustür', 'haustür austauschen',
      'balkontür einbauen', 'terrassentür montieren', 'neue balkontür',
      'rolladen montieren', 'rolläden einbauen', 'neue rolladen',
      'dreifachverglasung einbauen', 'isolierglas erneuern',
      'kunststofffenster einbauen', 'holzfenster montieren', 'alufenster einbauen',
      'fensterbank montieren', 'schallschutzfenster', 'einbruchschutzfenster',
      'fenster komplett neu', 'fenstertausch'
    ],
    
    'SAN': [
      'bad sanieren', 'badsanierung', 'bad erneuern', 'badezimmer sanieren',
      'neues bad', 'bad komplett neu', 'sanitär erneuern', 'sanitärinstallation',
      'wc austauschen', 'neue toilette', 'waschbecken austauschen', 'neues waschbecken',
      'dusche einbauen', 'neue dusche', 'badewanne einbauen', 'neue badewanne',
      'wasserleitung erneuern', 'wasserleitungen verlegen', 'neue wasserleitungen',
      'abwasserleitungen erneuern', 'abwasser sanieren', 'fallleitung erneuern',
      'armaturen austauschen', 'neue armaturen', 'sanitärobjekte austauschen',
      'hebeanlage einbauen', 'rückstauklappe montieren'
    ],
    
    'ELEKT': [
      'elektroinstallation erneuern', 'elektrik erneuern', 'neue elektroinstallation',
      'stromleitung verlegen', 'kabel verlegen', 'neue leitungen',
      'steckdosen setzen', 'neue steckdosen', 'steckdosen installieren',
      'schalter setzen', 'neue schalter', 'schalter installieren',
      'leuchten installieren', 'lampen anschließen', 'neue leuchten',
      'verteiler erneuern', 'neuer verteiler', 'unterverteiler einbauen',
      'zählerschrank erneuern', 'fi-schalter einbauen', 'neue sicherungen',
      'smart home installieren', 'knx installieren', 'bus-system verlegen',
      'sat-anlage installieren', 'netzwerk verkabeln', 'lan-kabel verlegen',
      'wallbox installieren', 'wallbox montieren', 'elektro komplett neu'
    ],
    
    'HEI': [
      'heizung erneuern', 'neue heizung', 'heizung austauschen', 'heizungsinstallation',
      'wärmepumpe einbauen', 'neue wärmepumpe', 'wärmepumpe installieren',
      'gasheizung einbauen', 'brennwertkessel installieren', 'neuer kessel',
      'heizkörper austauschen', 'neue heizkörper', 'heizkörper montieren',
      'fußbodenheizung verlegen', 'neue fußbodenheizung', 'fußbodenheizung einbauen',
      'heizungsrohre erneuern', 'heizungsrohre verlegen',
      'pelletheizung installieren', 'pufferspeicher einbauen',
      'heizkreisverteiler montieren', 'heizungspumpe austauschen',
      'heizung komplett neu', 'heizungssanierung'
    ],
    
    'KLIMA': [
      'lüftungsanlage einbauen', 'lüftung installieren', 'neue lüftungsanlage',
      'klimaanlage installieren', 'klimaanlage einbauen', 'neue klimaanlage',
      'kontrollierte wohnraumlüftung', 'kwl einbauen', 'kwl-anlage installieren',
      'wärmerückgewinnung installieren', 'luftkanäle verlegen',
      'dezentrale lüftung einbauen', 'badlüfter montieren',
      'dunstabzug installieren', 'klimatechnik installieren',
      'lüftung komplett neu'
    ],
    
    'FLI': [
      'bad fliesen', 'badezimmer fliesen', 'fliesen verlegen',
      'küche fliesen', 'fliesenspiegel legen', 'wandfliesen verlegen',
      'bodenfliesen verlegen', 'neue fliesen', 'fliesen erneuern',
      'naturstein verlegen', 'mosaik verlegen', 'fliesenarbeiten',
      'verfugen', 'fliesen komplett neu', 'großformatfliesen verlegen',
      'badfliesen neu', 'fliesenleger'
    ],
    
    'BOD': [
      'parkett verlegen', 'neues parkett', 'parkett erneuern',
      'laminat verlegen', 'neues laminat', 'laminat austauschen',
      'vinyl verlegen', 'designboden verlegen', 'neuer vinylboden',
      'teppich verlegen', 'neuer teppich', 'teppichboden verlegen',
      'linoleum verlegen', 'kork verlegen', 'pvc-boden verlegen',
      'massivholzdielen verlegen', 'landhausdielen verlegen',
      'bodenbelag erneuern', 'neuer bodenbelag', 'boden komplett neu'
    ],
    
    'MAL': [
      'streichen', 'wände streichen', 'decken streichen', 'anstreichen',
      'neu streichen', 'malerarbeiten', 'innenputz erneuern', 'verputzen',
      'tapezieren', 'tapeten kleben', 'neue tapeten', 'spachteln',
      'lackieren', 'grundierung auftragen', 'wandfarbe auftragen',
      'raufaser tapezieren', 'vliestapete kleben', 'strukturputz auftragen',
      'streichputz auftragen', 'maler beauftragen', 'komplett streichen',
      'malerarbeiten innen'
    ],
    
    'ESTR': [
      'estrich verlegen', 'neuer estrich', 'estrich erneuern',
      'fließestrich verlegen', 'zementestrich verlegen', 'anhydritestrich verlegen',
      'heizestrich verlegen', 'estrich mit dämmung', 'verbundestrich',
      'schwimmender estrich', 'ausgleichsmasse gießen',
      'trittschalldämmung verlegen', 'estrich komplett neu', 'estricharbeiten'
    ],
    
    'GER': [
      'gerüst stellen', 'gerüst aufbauen', 'gerüst mieten',
      'baugerüst aufstellen', 'fassadengerüst stellen', 'arbeitsgerüst',
      'dachgerüst aufbauen', 'einrüsten', 'gerüstbau', 'gerüststellung',
      'schutzgerüst montieren', 'rollgerüst aufstellen'
    ],
    
    'SCHL': [
      'geländer montieren', 'neues geländer', 'geländer erneuern',
      'balkongeländer montieren', 'treppengeländer einbauen',
      'zaun bauen', 'neuer zaun', 'tor montieren', 'neues tor',
      'stahltreppe bauen', 'metalltreppe einbauen', 'schlosserarbeiten',
      'französischer balkon montieren', 'gitter montieren',
      'brandschutztür einbauen', 'metalltür montieren', 'fluchttreppe bauen'
    ],
    
    'AUSS': [
      'pflaster verlegen', 'einfahrt pflastern', 'hofeinfahrt pflastern',
      'terrasse pflastern', 'neue terrasse', 'gehweg pflastern',
      'garten gestalten', 'gartengestaltung', 'außenanlage gestalten',
      'stellplatz pflastern', 'gartenmauer bauen', 'stützmauer errichten',
      'zaun bauen', 'rasen anlegen', 'gabionen setzen',
      'regenwasserversickerung bauen', 'außenanlagen neu'
    ],
    
    'PV': [
      'photovoltaik installieren', 'photovoltaikanlage', 'pv-anlage installieren',
      'solaranlage installieren', 'solar montieren', 'solarmodule montieren',
      'pv montieren', 'solarpanel montieren', 'neue solaranlage',
      'balkonkraftwerk installieren', 'energiespeicher einbauen',
      'wechselrichter installieren', 'wallbox installieren', 'notstrom installieren',
      'pv komplett neu', 'pv-installation'
    ],
    
    'ABBR': [
      'abriss', 'abbruch', 'abbrechen', 'abreißen', 'entkernen', 'entkernung',
      'rückbau', 'teilabbruch', 'komplettabriss', 'gebäude abreißen',
      'schadstoffsanierung', 'asbest entsorgen', 'asbestsanierung',
      'bauschutt entsorgen', 'container bestellen', 'entrümpelung',
      'abbrucharbeiten', 'rückbau komplett'
    ]
  },
  
  // VERBOTENE Zuordnungen - diese Begriffe dürfen NICHT zu diesem Gewerk führen
  forbidden: {
    'TRO': ['wdvs', 'fassade', 'außendämmung', 'außenputz', 'fassadenanstrich', 'gaube'],
    'ROH': ['dach', 'sparren', 'dachstuhl', 'gaube', 'dachrinne', 'eindeckung'],
    'TIS': ['gaube', 'dachfenster', 'außenfenster', 'haustür', 'dachstuhl', 'balkontür'],
    'FEN': ['dachfenster', 'gaube', 'dachsparren'],
    'ZIMM': ['dämmung', 'eindeckung', 'dachziegel', 'dachrinne', 'wdvs'],
    'MAL': ['fassade', 'außenputz', 'wdvs', 'außendämmung'],
    'BOD': ['fliesen', 'naturstein', 'wandfliesen', 'fliesenspiegel'],
    'ELEKT': ['heizung', 'sanitär', 'wasser', 'abwasser', 'klima'],
    'SAN': ['elektro', 'strom', 'heizung', 'heizkörper', 'thermostat'],
    'HEI': ['elektro', 'sanitär', 'klima', 'lüftung', 'bad'],
    'KLIMA': ['heizung', 'sanitär', 'elektro'],
    'FASS': ['innenputz', 'tapete', 'malerarbeiten innen', 'gaube'],
    'DACH': ['wdvs', 'fassadendämmung', 'außenputz'],
    'FLI': ['parkett', 'laminat', 'vinyl', 'teppich'],
    'ESTR': ['fliesen', 'parkett', 'bewehrung', 'bodenbelag'],
    'GER': ['bauarbeiten', 'sanierung', 'renovierung'],
    'ABBR': ['neubau', 'anbau', 'aufstockung'],
    'SCHL': ['holzgeländer', 'holztreppe', 'carport'],
    'AUSS': ['innenausbau', 'bad', 'küche'],
    'PV': ['heizung', 'warmwasser', 'sanitär']
  }
};

/**
 * Hauptfunktion zur Gewerke-Erkennung mit strenger Validierung
 */
function detectAndValidateTradesFromIntake(intakeAnswers, existingTrades = [], projectDescription = '') {
  const detectedTrades = new Map();
  
  // FIX 1: Handle beide Formate (String-Array und Object-Array)
  const existingCodes = new Set(
    existingTrades.map(t => typeof t === 'string' ? t : t.code)
  );
  
  const rejectedTrades = [];
  
  // FIX 2: Sichere toLowerCase() Anwendung
  const fullText = intakeAnswers
    .map(item => {
      const q = item.question || item.question_text || '';
      const a = item.answer || item.answer_text || '';
      return `${q} ${a}`.toLowerCase();
    })
    .concat([projectDescription ? projectDescription.toLowerCase() : ''])
    .join(' ');
  
  console.log('[TRADE-DETECT] Analysiere Text mit', fullText.length, 'Zeichen');
  
  // 1. PHASE: Keyword-Erkennung MIT QUELLEN-TRACKING
for (const [tradeCode, keywords] of Object.entries(TRADE_DETECTION_RULES.exclusive)) {
  if (existingCodes.has(tradeCode)) continue;
  
  const matchedKeywords = [];
  const matchedFromDescription = [];
  const matchedFromIntake = [];
  
  // Separiere Projektbeschreibung von Intake-Antworten
  const descriptionText = (projectDescription || '').toLowerCase();
  const intakeText = intakeAnswers
    .map(item => `${item.question || ''} ${item.answer || ''}`.toLowerCase())
    .join(' ');
  
 for (const keyword of keywords) {
  if (fullText.includes(keyword)) {
    matchedKeywords.push(keyword);
    
    // Track woher das Keyword kommt
    if (descriptionText.includes(keyword)) {
      matchedFromDescription.push(keyword);
    } else if (intakeText.includes(keyword)) {
      matchedFromIntake.push(keyword);
    }
  }
}
    
    if (matchedKeywords.length > 0) {
      // 2. PHASE: Validierung gegen verbotene Begriffe
      const forbidden = TRADE_DETECTION_RULES.forbidden[tradeCode] || [];
      const forbiddenMatches = [];
      
      for (const term of forbidden) {
        if (matchedKeywords.some(kw => kw.includes(term))) {
          forbiddenMatches.push(term);
        }
      }
      
      if (forbiddenMatches.length > 0) {
        rejectedTrades.push({
          code: tradeCode,
          keywords: matchedKeywords,
          reason: `Enthält verbotene Begriffe: ${forbiddenMatches.join(', ')}`
        });
        console.log(`[TRADE-DETECT] ❌ ${tradeCode} abgelehnt: ${forbiddenMatches.join(', ')}`);
        continue;
      }
      
      // 3. PHASE: Konfidenz-Berechnung mit Quellen-Tracking
const confidence = calculateTradeConfidence(tradeCode, matchedKeywords);

// Bestimme Quelle und Kategorie
const source = matchedFromDescription.length > 0 ? 'description' : 'intake';
const category = matchedFromDescription.length > 0 ? 'required' : 'recommended';

detectedTrades.set(tradeCode, {
  confidence,
  keywords: matchedKeywords,
  reason: generateTradeReason(tradeCode, matchedKeywords, intakeAnswers),
  source: source,
  category: category
});

console.log(`[TRADE-DETECT] ✓ ${tradeCode}: ${matchedKeywords.length} Keywords, ${confidence}% Konfidenz, Source: ${source}`);
  }  
}  
  
  // 4. PHASE: Kreuz-Validierung und Korrektur falscher Zuordnungen
  const corrections = new Map();
  
  for (const [code, data] of detectedTrades) {
    let shouldCorrect = false;
    let correctToCode = null;
    
    // Spezifische Korrekturen basierend auf bekannten Fehlern
    for (const keyword of data.keywords) {
      // WDVS/Fassade: TRO → FASS
      if (code === 'TRO' && (keyword.includes('wdvs') || keyword.includes('fassad'))) {
        shouldCorrect = true;
        correctToCode = 'FASS';
        break;
      }
      
      // Dacharbeiten: ROH → DACH
      if (code === 'ROH' && (keyword.includes('dach') || keyword.includes('sparr'))) {
        shouldCorrect = true;
        correctToCode = 'DACH';
        break;
      }
      
      // Gaube: TIS → ZIMM
      if (code === 'TIS' && keyword.includes('gaube')) {
        shouldCorrect = true;
        correctToCode = 'ZIMM';
        break;
      }
      
      // Dachfenster: FEN → DACH
      if (code === 'FEN' && keyword.includes('dachfenster')) {
        shouldCorrect = true;
        correctToCode = 'DACH';
        break;
      }
      
      // Außenputz: MAL → FASS
      if (code === 'MAL' && (keyword.includes('außenputz') || keyword.includes('fassad'))) {
        shouldCorrect = true;
        correctToCode = 'FASS';
        break;
      }
      
      // Fliesen: BOD → FLI
      if (code === 'BOD' && keyword.includes('fliese')) {
        shouldCorrect = true;
        correctToCode = 'FLI';
        break;
      }
    }
    
    if (shouldCorrect && correctToCode) {
      corrections.set(code, correctToCode);
      console.log(`[TRADE-DETECT] ↻ Korrektur: ${code} → ${correctToCode}`);
      
      // Füge korrigiertes Gewerk hinzu wenn noch nicht vorhanden
      if (!detectedTrades.has(correctToCode) && !existingCodes.has(correctToCode)) {
        detectedTrades.set(correctToCode, {
          confidence: data.confidence,
          keywords: data.keywords,
          reason: `${data.reason} (korrigiert von ${code})`
        });
      }
      
      // Entferne falsches Gewerk
      detectedTrades.delete(code);
    }
  }
  
  // 5. PHASE: Abhängigkeiten hinzufügen
  const dependencies = addTradeDependencies(detectedTrades, existingCodes, fullText);
  for (const [code, data] of dependencies) {
    if (!detectedTrades.has(code)) {
      detectedTrades.set(code, data);
      console.log(`[TRADE-DETECT] + Abhängigkeit: ${code} (${data.reason})`);
    }
  }
  
  // 6. PHASE: Finale Liste erstellen MIT SOURCE/CATEGORY
const finalTrades = [];
for (const [code, data] of detectedTrades) {
  finalTrades.push({
    code,
    confidence: data.confidence,
    matchedKeywords: data.keywords,
    reason: data.reason,
    source: data.source || 'description',  // Fallback für Kompatibilität
    category: data.category || 'required'   // Fallback für Kompatibilität
  });
}
  
  console.log(`[TRADE-DETECT] Final: ${finalTrades.length} Gewerke erkannt`);
  
  return {
    trades: finalTrades,
    rejected: rejectedTrades
  };
}

/**
 * Berechnet Konfidenz basierend auf Keyword-Matches
 */
function calculateTradeConfidence(tradeCode, matchedKeywords) {
  // Hochwertige Keywords für ALLE Gewerke - gibt extra Konfidenz
  const highValueKeywords = {
    'DACH': ['dach', 'komplett neu eindecken', 'dachsanierung', 'dacherneuerung', 'dach komplett', 'neue eindeckung'],
    'FASS': ['wdvs', 'wärmedämmverbundsystem', 'fassadendämmung', 'komplettsanierung fassade', 'neue fassade', 'außendämmung komplett'],
    'ZIMM': ['gaube', 'neue gaube', 'dachstuhl', 'sparren', 'holzkonstruktion', 'aufstockung', 'dachstuhl erneuern', 'holzrahmenbau'],
    'ROH': ['tragende wand', 'wanddurchbruch', 'neue wände mauern', 'statisch', 'fundament', 'betonieren', 'stahlbeton'],
    'TRO': ['komplette trockenbauwände', 'vorwandinstallation bad', 'abgehängte decke', 'schallschutzwand', 'brandschutzwand'],
    'TIS': ['innentüren', 'komplette küche', 'wohnungstür', 'wohnungseingangstür', 'einbauküche', 'einbauschränke', 'möbel nach maß', 'innentüren erneuern'],
    'FEN': ['alle fenster neu', 'fenster komplett', 'haustür neu', 'kompletter fenstertausch', 'neue fenster und türen'],
    'SAN': ['bad', 'bad komplett', 'badsanierung', 'sanitär', 'neues bad', 'sanitärinstallation', 'bad kernsanierung'],
    'ELEKT': ['elektroinstallation', 'elektrik', 'neue elektroinstallation', 'smart home', 'knx-installation', 'wallbox', 'elektro komplett neu'],
    'HEI': ['heizung', 'neue heizungsanlage', 'wärmepumpe', 'gasheizung', 'fußbodenheizung', 'heizung komplett erneuern', 'brennwertkessel'],
    'KLIMA': ['lüftungsanlage', 'kontrollierte wohnraumlüftung', 'kwl-anlage', 'klimaanlage', 'wärmerückgewinnung', 'zentrale lüftung'],
    'FLI': ['bad', 'küche', 'fliesen', 'neue fliesen', 'komplett neu fliesen', 'naturstein', 'großformatfliesen', 'fugenfarbe'],
    'BOD': ['neuer parkettboden', 'kompletter bodenbelag', 'alle böden neu', 'designboden', 'massivholzdielen', 'parkett komplett'],
    'MAL': ['streichen', 'alle räume streichen', 'komplette malerarbeiten', 'innenputz neu', 'tapezieren komplett'],
    'ESTR': ['neuer estrich', 'estrich komplett', 'fließestrich', 'heizestrich', 'estrich mit dämmung', 'kompletter estrichaufbau'],
    'GER': ['fassadengerüst', 'kompletteinrüstung', 'dachgerüst', 'gerüst rundherum', 'baugerüst komplett'],
    'SCHL': ['neues geländer', 'balkongeländer', 'stahltreppe', 'metallkonstruktion', 'einbruchschutz', 'neue metallarbeiten'],
    'AUSS': ['neue einfahrt', 'komplette außenanlage', 'terrasse neu', 'pflasterarbeiten', 'gartengestaltung', 'hofpflasterung'],
    'PV': ['photovoltaikanlage', 'solaranlage komplett', 'pv mit speicher', 'balkonkraftwerk', 'wallbox', 'komplette pv-anlage'],
    'ABBR': ['entkernung', 'abriss', 'abbruch', 'teilabbruch', 'asbestsanierung', 'schadstoffsanierung', 'rückbau komplett']
  };
  
  let confidence = 70; // Basis-Konfidenz
  
  // Erhöhe für Anzahl der Keywords
  confidence += Math.min(20, matchedKeywords.length * 5);
  
  // Bonus für hochwertige Keywords
  const tradeHighValue = highValueKeywords[tradeCode] || [];
  const hasHighValue = matchedKeywords.some(kw => 
    tradeHighValue.some(hv => kw.includes(hv))
  );
  
  if (hasHighValue) {
    confidence = Math.min(95, confidence + 10);
  }
  
  return confidence;
}

/**
 * Generiert spezifische Begründung für erkanntes Gewerk
 */
function generateTradeReason(tradeCode, keywords, intakeAnswers) {
  // Fallback-Begründung ohne Kürzung
  const relevantKeywords = keywords.slice(0, 3).join(', ');
  return `Möglicher Bedarf für dieses Gewerk durch folgende Begriffe erkannt: ${relevantKeywords}`;
}

/**
 * Fügt logische Abhängigkeiten hinzu
 */
function addTradeDependencies(detectedTrades, existingCodes, fullText) {
  const dependencies = new Map();
  
  // Bei Badsanierung → TRO für Vorwandinstallation
  if ((detectedTrades.has('SAN') || existingCodes.has('SAN')) && 
      !detectedTrades.has('TRO') && !existingCodes.has('TRO')) {
    if (fullText.includes('bad') || fullText.includes('sanitär')) {
      dependencies.set('TRO', {
        confidence: 85,
        keywords: ['vorwandinstallation'],
        reason: 'Vorwandinstallation für Badsanierung'
      });
    }
  }
  
  // Bei Dach/Fassade → GER für Gerüst
  if ((detectedTrades.has('DACH') || detectedTrades.has('FASS') || 
       existingCodes.has('DACH') || existingCodes.has('FASS')) &&
      !detectedTrades.has('GER') && !existingCodes.has('GER')) {
    dependencies.set('GER', {
      confidence: 90,
      keywords: ['arbeitsgerüst'],
      reason: 'Gerüst für Dach-/Fassadenarbeiten erforderlich'
    });
  }
  
  return dependencies;
}

/**
 * Intelligente Fragengenerierung mit Mengenerfassung
 */
async function generateQuestions(tradeId, projectContext = {}) {
  const tradeResult = await query(
    'SELECT name, code FROM trades WHERE id = $1',
    [tradeId]
  );
  
  if (tradeResult.rows.length === 0) {
    throw new Error(`Trade ${tradeId} not found`);
  }
  
  const { name: tradeName, code: tradeCode } = tradeResult.rows[0];
  const isIntake = tradeCode === 'INT';

  // SPEZIAL-ERKENNUNG: Dachaufstockung
const istDachaufstockung = (projectContext.description || '').toLowerCase().match(
  /dachaufstockung|aufstockung|geschossaufstockung|dach.*aufstocken|stockwerk.*aufbauen|etage.*draufsetzen/
);

if (istDachaufstockung) {
  console.log('[QUESTIONS] Dachaufstockung erkannt - Spezialbehandlung aktiviert');
  projectContext.istDachaufstockung = true;
}
  
  // NEU: Lade extrahierte Projektdaten
  let extractedData = null;
  let knownCalculationData = null; // NEU HINZUFÜGEN
  if (projectContext.projectId) {
    const projectResult = await query(
      'SELECT metadata FROM projects WHERE id = $1',
      [projectContext.projectId]
    );
    if (projectResult.rows[0]?.metadata) {
      const metadata = typeof projectResult.rows[0].metadata === 'string' 
        ? JSON.parse(projectResult.rows[0].metadata)
        : projectResult.rows[0].metadata;
      extractedData = metadata?.extracted || null;
      projectContext.extractedData = extractedData;
    }
  }

  // NEU: Sammle ALLE bereits beantworteten Informationen
const allAnsweredInfo = {
  fromDescription: extractedData || {},
  fromIntake: [],
  fromOtherTrades: []
};

// Lade Intake-Antworten
if (!isIntake && projectContext.projectId) {
  // Lade aus intake_responses (neue Tabelle)
  const intakeResponses = await query(
    `SELECT q.text as question_text, a.answer_text 
     FROM answers a
     JOIN questions q ON q.project_id = a.project_id 
       AND q.trade_id = a.trade_id 
       AND q.question_id = a.question_id
     JOIN trades t ON t.id = a.trade_id
     WHERE a.project_id = $1 
       AND t.code = 'INT'`,
    [projectContext.projectId]
  );
  
  if (intakeResponses.rows.length > 0) {
    allAnsweredInfo.fromIntake = intakeResponses.rows;
    projectContext.intakeData = intakeResponses.rows;
    // NEU: Kalkulationsdaten extrahieren
  knownCalculationData = extractCalculationDataFromIntake(intakeResponses.rows);
  projectContext.knownCalculationData = knownCalculationData;
  
  console.log('[CALC-DATA] Extracted from intake:', {
    flaechen: Object.keys(knownCalculationData.flaechen).length,
    hoehen: Object.keys(knownCalculationData.hoehen).length,
    laengen: Object.keys(knownCalculationData.laengen).length,
    stueck: Object.keys(knownCalculationData.stueckzahlen).length
  });

    // EXTRAHIERE Bauweise bei Dachaufstockung
  if (projectContext.istDachaufstockung) {
    const bauweiseFrage = intakeResponses.rows.find(r => 
      r.question_text?.toLowerCase().includes('bauweise') && 
      r.question_text?.toLowerCase().includes('aufstockung')
    );
    
    if (bauweiseFrage) {
      projectContext.aufstockungsBauweise = bauweiseFrage.answer_text?.toLowerCase().includes('holz') 
        ? 'holzbau' 
        : bauweiseFrage.answer_text?.toLowerCase().includes('massiv') 
        ? 'massivbau'
        : 'offen';
      
      console.log(`[QUESTIONS] Aufstockungsbauweise: ${projectContext.aufstockungsBauweise}`);
    }
  }
    
    // NEU: Extrahiere konkrete Werte für bessere Duplikatserkennung
    projectContext.answeredValues = {};
    intakeResponses.rows.forEach(item => {
      const q = (item.question_text || '').toLowerCase();
      const a = item.answer_text || '';
      
      // Speichere konkrete Maße
      if ((q.includes('abmessung') || q.includes('maße') || q.includes('größe')) && a) {
        const matches = a.match(/(\d+)\s*x\s*(\d+)/);
        if (matches) {
          projectContext.answeredValues.dimensions = matches[0];
        }
      }
      
      // Speichere Wandstärke
      if ((q.includes('stärke') || q.includes('dicke')) && a) {
        const matches = a.match(/(\d+)\s*(cm|mm)/);
        if (matches) {
          projectContext.answeredValues.wallThickness = matches[0];
        }
      }
      
      // Speichere Material
      if (q.includes('material') && a) {
        projectContext.answeredValues.material = a;
      }
      
      // Speichere Flächen
      if (q.includes('fläche') && a) {
        const matches = a.match(/(\d+)\s*(m²|qm)/);
        if (matches) {
          projectContext.answeredValues.area = matches[0];
        }
      }
      
      // Speichere Anzahlen
      if (q.includes('wie viele') || q.includes('anzahl')) {
        const matches = a.match(/\d+/);
        if (matches) {
          // Identifiziere worum es geht
          if (q.includes('fenster')) projectContext.answeredValues.windowCount = matches[0];
          if (q.includes('tür')) projectContext.answeredValues.doorCount = matches[0];
          if (q.includes('raum') || q.includes('zimmer')) projectContext.answeredValues.roomCount = matches[0];
        }
      }
    });
    
  } else {
    // Fallback auf answers Tabelle
    const intTrade = await query(`SELECT id FROM trades WHERE code='INT' LIMIT 1`);
    if (intTrade.rows[0]) {
      const intakeAnswers = await query(
        `SELECT q.text as question_text, a.answer_text 
         FROM answers a
         JOIN questions q ON q.project_id = a.project_id 
           AND q.trade_id = a.trade_id 
           AND q.question_id = a.question_id
         WHERE a.project_id = $1 AND a.trade_id = $2`,
        [projectContext.projectId, intTrade.rows[0].id]
      );
      allAnsweredInfo.fromIntake = intakeAnswers.rows;
      projectContext.intakeData = intakeAnswers.rows;
      }
    }
  }
    
  // NEU: Füge Intake-Kontext zum System-Prompt hinzu
  if (projectContext.intakeContext && !isIntake) {
    console.log('[QUESTIONS] Adding intake context to prompt');
    // Der intakeContext wird später im System-Prompt verwendet
  }
  
  console.log(`[QUESTIONS] Generating for ${tradeName} with context:`, {
  hasExtractedData: !!extractedData,
  extractedQuantities: extractedData?.quantities || {},
  intakeAnswerCount: allAnsweredInfo.fromIntake.length,
  isManuallyAdded: projectContext.isManuallyAdded,
  isAdditional: projectContext.isAdditional,
  isAiRecommended: projectContext.isAiRecommended,
  hasContextAnswer: projectContext.hasContextAnswer
});

// Kontextfrage für manuell/zusätzlich/AI-empfohlene Gewerke (falls noch keine Antwort)
if (
  (projectContext.isManuallyAdded || 
   projectContext.isAdditional || 
   projectContext.isAiRecommended) &&
  !projectContext.hasContextAnswer &&
  !isIntake
) {
  console.log(`[QUESTIONS] ${tradeCode} needs context question (manual/additional/AI-recommended)`);
  
  const tradeTypeText = projectContext.isAdditional ? 'nachträglich hinzugefügt' :
                        projectContext.isManuallyAdded ? 'manuell hinzugefügt' :
                        'als optionales Gewerk ausgewählt';
  
  return [{
    id: `${tradeCode}-CONTEXT`,
    question: `Sie haben das Gewerk ${tradeName} ${tradeTypeText}. Was genau soll in diesem Bereich gemacht werden?`,
    text: `Sie haben das Gewerk ${tradeName} ${tradeTypeText}. Was genau soll in diesem Bereich gemacht werden?`,
    type: 'text',
    required: true,
    category: 'Projektkontext',
    explanation: `Wichtig für die präzise Kalkulation der ${tradeName}-Arbeiten`,
    isContextQuestion: true,
    requiresFollowUp: true,
    uploadHelpful: true,
    uploadHint: "Optional: Fotos, Pläne oder Dokumente zur besseren Einschätzung hochladen"
  }];
}

// Falls Kontextantwort vorhanden: Weiter mit normalem Fragenkatalog
if (projectContext.hasContextAnswer) {
  console.log(`[QUESTIONS] ${tradeCode} has context answer: "${projectContext.contextAnswer?.substring(0, 50)}..." - generating follow-up questions`);
  // Weiter mit normalem Prozess
}
  
  const questionPrompt = await getPromptForTrade(tradeId, 'questions');

// VALIDIERE dass Prompt geladen wurde
if (!questionPrompt && !isIntake) {
  console.error(`[QUESTIONS] ERROR: No question prompt found for ${tradeName} (${tradeCode})`);
  // Ohne Prompt können keine sinnvollen Fragen generiert werden
  throw new Error(`Fragen-Prompt für ${tradeName} fehlt in der Datenbank`);
}

// DEBUG: Prompt-Inhalt prüfen
if (questionPrompt) {
  console.log(`[QUESTIONS] Prompt loaded for ${tradeName}: ${questionPrompt.length} chars`);
  
  // Prüfe ob wichtige Keywords im Prompt sind
  if (tradeCode === 'GER' && !questionPrompt.includes('Gerüstfläche')) {
    console.warn(`[QUESTIONS] WARNING: Gerüst prompt missing 'Gerüstfläche' keyword`);
  }
}
  
  // Intake-Kontext für Gewerke-Fragen laden
  let intakeContext = '';
  let answeredQuestions = [];
  
  if (projectContext.projectId && !isIntake) {
    const intTrade = await query(`SELECT id FROM trades WHERE code='INT' LIMIT 1`);
    if (intTrade.rows.length > 0) {
      const intakeAnswers = await query(
        `SELECT q.text as question, a.answer_text as answer
         FROM answers a
         JOIN questions q ON q.project_id = a.project_id 
           AND q.trade_id = a.trade_id 
           AND q.question_id = a.question_id
         WHERE a.project_id = $1 AND a.trade_id = $2`,
        [projectContext.projectId, intTrade.rows[0].id]
      );
      
      if (intakeAnswers.rows.length > 0) {
        answeredQuestions = intakeAnswers.rows;
        intakeContext = `
BEREITS BEANTWORTETE INTAKE-FRAGEN:
${intakeAnswers.rows.map(a => `- ${a.question}: ${a.answer}`).join('\n')}

WICHTIG: 
- Stelle NUR noch unbeantwortete, gewerkespezifische Fragen
- Fokussiere auf KONKRETE MENGEN und MASSE
- Vermeide jegliche Dopplungen`;
      }
    }
  }
  
  const projectComplexity = determineProjectComplexity(projectContext, answeredQuestions);
  const intelligentCount = getIntelligentQuestionCount(tradeCode, projectContext, answeredQuestions);
  // Bei manuell/zusätzlich/AI-empfohlenen: Erste Frage MUSS Kontextfrage sein
let targetQuestionCount = intelligentCount.count;
let forceContextQuestion = false;

if (projectContext.isManuallyAdded || projectContext.isAdditional || projectContext.isAiRecommended) {  
  forceContextQuestion = true;
  targetQuestionCount = Math.max(15, targetQuestionCount);
  
  const tradeType = projectContext.isManuallyAdded ? 'manually added' :
                    projectContext.isAdditional ? 'additional' :
                    'AI-recommended';
  
  console.log(`[QUESTIONS] Context question required for ${tradeName} - ${tradeType}`);
}

// Spezielle Behandlung für Intake-Fragen basierend auf Gewerke-Anzahl
if (isIntake && projectContext.targetQuestionCount) {
  targetQuestionCount = projectContext.targetQuestionCount;
  console.log(`[QUESTIONS] INT: Using provided targetQuestionCount: ${targetQuestionCount}`);
} else if (isIntake && projectContext.detectedTrades) {
  const tradeCount = projectContext.detectedTrades.length;
  if (tradeCount === 1) {
    targetQuestionCount = 16;
  } else if (tradeCount <= 3) {
    targetQuestionCount = 18;
  } else if (tradeCount <= 5) {
    targetQuestionCount = 21;
  } else {
    targetQuestionCount = 25;
  }
  console.log(`[QUESTIONS] INT: Adjusted to ${targetQuestionCount} questions for ${tradeCount} trades`);
}
  
// Innenprojekt-Erkennung für intelligente Intake-Fragen
let innenprojektText = '';
if (isIntake) {
  const hasInnengewerke = projectContext.detectedTrades?.some(t => 
    ['MAL', 'BOD', 'FLI', 'TIS', 'TRO', 'ELEKT', 'SAN', 'HEI'].includes(t.code)
  );
  const hasAussengewerke = projectContext.detectedTrades?.some(t => 
    ['DACH', 'FASS', 'AUSS', 'GER'].includes(t.code)
  );
  const beschreibung = (projectContext.description || '').toLowerCase();
  const istWohnung = beschreibung.includes('wohnung') || 
                     beschreibung.includes('stock') || 
                     beschreibung.includes('etage');
  
  if ((hasInnengewerke && !hasAussengewerke) || istWohnung) {
    innenprojektText = `
INNENPROJEKT ERKANNT - Stelle zusätzlich diese Fragen:
- In welchem Stockwerk/Geschoss befindet sich die Wohnung?
- Gibt es einen Aufzug? (Falls ja: Maße angeben)
- Kann der Aufzug für Materialtransport genutzt werden?
- Wie breit ist das Treppenhaus?
- Gibt es Engstellen beim Transport?`;
  }
}
// Schadensabfrage basierend auf Gewerken
let schadensfrageText = '';
if (isIntake && projectContext.detectedTrades) {
  const schadensRelevant = [];
  
  // Prüfe welche Gewerke vorhanden sind und sammle relevante Schadensfragen
  projectContext.detectedTrades.forEach(trade => {
    switch(trade.code) {
      case 'FASS':
        schadensRelevant.push('Gibt es sichtbare Schäden an der Fassade (Risse, Abplatzungen, Feuchtigkeit)?');
        break;
      case 'DACH':
        schadensRelevant.push('Gibt es Schäden am Dach (undichte Stellen, fehlende Ziegel, Sturmschäden)?');
        break;
      case 'KEL':
      case 'ABBR':
        schadensRelevant.push('Gibt es Feuchtigkeitsschäden im Keller (nasse Wände, Schimmel, Salzausblühungen)?');
        break;
      case 'SAN':
      case 'HEI':
        schadensRelevant.push('Gibt es Wasserschäden oder Rohrbrüche (Verfärbungen, Feuchtigkeit)?');
        break;
      case 'FEN':
        schadensRelevant.push('Gibt es Schäden an Fensterlaibungen (Risse, Feuchtigkeit, Schimmel)?');
        break;
      case 'MAL':
        schadensRelevant.push('Gibt es Vorschäden an Wänden/Decken (Risse, Feuchtigkeit, Schimmel)?');
        break;
      case 'ELEKT':
        schadensRelevant.push('Gibt es bekannte Elektroschäden (Kurzschlüsse, defekte Leitungen)?');
        break;
    }
  });
  
  // Keller-Check auch über Beschreibung
  const beschreibung = (projectContext.description || '').toLowerCase();
  if (beschreibung.includes('keller') && !schadensRelevant.some(s => s.includes('Keller'))) {
    schadensRelevant.push('Gibt es Feuchtigkeitsprobleme im Keller?');
  }
  
  if (schadensRelevant.length > 0) {
    schadensfrageText = `
SCHADENSABFRAGE - Wichtig für Kalkulation:
${schadensRelevant.map(s => `- ${s}`).join('\n')}
- Falls ja: Bitte Umfang beschreiben (klein/mittel/groß)`;
  }
}

// NEU: Explizite Konzept-Extraktion für bessere Duplikat-Vermeidung
const answeredConcepts = new Set();
const answeredValues = {};

if (allAnsweredInfo.fromIntake && allAnsweredInfo.fromIntake.length > 0) {
  allAnsweredInfo.fromIntake.forEach(item => {
    const q = item.question_text?.toLowerCase() || '';
    const a = item.answer_text?.toLowerCase() || '';
    
    // Extrahiere beantwortete Konzepte und Werte
    if (q.includes('bad') && a.match(/\d+\s*(m²|qm)/)) {
      answeredConcepts.add('badfläche');
      answeredConcepts.add('badgröße');
      answeredConcepts.add('sanitärbereich_fläche');
      answeredValues['badfläche'] = a.match(/\d+\s*(m²|qm)/)[0];
    }
    
    if (q.includes('stock') || q.includes('geschoss') || q.includes('etage')) {
      answeredConcepts.add('stockwerk');
      answeredConcepts.add('etage');
      answeredConcepts.add('geschoss');
      answeredValues['stockwerk'] = a;
    }
    
    if (q.includes('fläche') && !q.includes('bad')) {
      answeredConcepts.add('grundfläche');
      if (a.match(/\d+/)) answeredValues['grundfläche'] = a;
    }
  });
}
  
  const systemPrompt = `Du bist ein erfahrener Experte für ${tradeName} mit 20+ Jahren Berufserfahrung.
${isIntake ? 
`╔══════════════════════════════════════════════════════════════════╗
║                     INTAKE-FRAGEN MODUS                           ║
╚══════════════════════════════════════════════════════════════════╝

WICHTIG: Dies sind ALLGEMEINE INTAKE-FRAGEN zur Erfassung der BAUSTELLENBEDINGUNGEN.

ERKANNTE GEWERKE IM PROJEKT:
${projectContext.detectedTrades ? projectContext.detectedTrades.map(t => `- ${t.code}: ${t.name}`).join('\n') : 'Keine Gewerke übergeben'}

INTELLIGENTE FRAGENAUSWAHL BASIEREND AUF GEWERKEN:

1. IMMER FRAGEN (für alle Projekte):
   - Zufahrt/Zugang (LKW-tauglich bei großen Projekten)
   - Lagerungsmöglichkeiten
   - Arbeitszeiten/Einschränkungen
   - Gewünschter Zeitraum
   - Bewohnt während Bauzeit?

2. BAUSTROM (immer fragen):
   - Alle Gewerke benötigen Strom
   - Bei ELEKT: Auch Leistung/Absicherung erfragen

3. BAUWASSER (NUR fragen bei):
   - ROH, MAL, ESTR, FLI, FASS, DACH, SAN, HEI
   - NICHT bei: ELEKT, TIS, FEN, BOD, TRO

4. DENKMALSCHUTZ (NUR fragen bei):
   - FASS, DACH, FEN, AUSS
   - NICHT bei: Bad-/Innensanierung ohne Außenarbeiten

5. GEBÄUDEHÖHE/STOCKWERKE (NUR fragen bei):
   - GER, DACH, FASS, FEN (wenn Obergeschoss)
   - NICHT bei: reinen Innenarbeiten

6. LÄRMSCHUTZ (NUR fragen bei):
   - ABBR, ROH, ESTR, TRO
   - ODER wenn "bewohnt während Bauzeit" = ja

7. SANITÄRANLAGEN FÜR HANDWERKER (NUR bei):
   - Großprojekten (>3 Gewerke)
   - Oder Projektdauer >4 Wochen

8. MATERIALTRANSPORT BEI INNENPROJEKTEN (NUR fragen bei):
   - Erkannte Innengewerke: MAL, BOD, FLI, TIS, TRO, ELEKT, SAN, HEI
   - Wenn Projektbeschreibung "Wohnung", "Büro", "Innen" enthält
   
   FRAGEN:
   - In welchem Geschoss/Stockwerk befindet sich die Wohnung/das Objekt?
   - Gibt es einen Aufzug? Wenn ja: Maße (B x T x H)?
   - Kann der Aufzug für Materialtransport genutzt werden?
   - Breite der Treppe/Treppenhaus?
   - Gibt es Engstellen (schmale Türen, verwinkelte Flure)?
   - Maximale Transportlänge (z.B. für lange Bretter, Rohre)?

9. SCHUTZ BEI BEWOHNTEN OBJEKTEN (bei "bewohnt während Bauzeit" = ja):
   - Müssen bestimmte Bereiche staubfrei bleiben?
   - Gibt es empfindliche Böden/Treppen die geschützt werden müssen?

BEISPIEL-ANPASSUNG:
- "Wohnungssanierung 3. OG": 
  → Frage nach Aufzug PFLICHT
  → Frage nach Treppenbreite
  → Frage nach Balkonen/Fenstern für Materialtransport
  
- "Kellersanierung":
  → Frage nach Kellerzugang
  → Frage nach Lichtschacht
  → Keine Aufzugfrage

- "Dachgeschoss-Ausbau":
  → Frage nach Dachbodenzugang
  → Maximale Transportlänge für Balken
  → Treppenbreite kritisch
  
ANPASSUNG AN PROJEKTGRÖSSE:
- Kleines Projekt (1-2 Gewerke): 14-19 Fragen
- Mittleres Projekt (3-5 Gewerke): 17-22 Fragen  
- Großes Projekt (>5 Gewerke): 22-28 Fragen

BEISPIELE INTELLIGENTER ANPASSUNG:
- Nur ELEKT: Keine Bauwasser-Frage
- Nur Badsanierung: Kein Denkmalschutz
- Nur MAL innen: Keine Gebäudehöhe
- DACH+FASS: Alle Außen-relevanten Fragen

KEINE FRAGEN ZU:
- Technischen Details (Dämmstärke, Wandstärke, Verglasungsart, U-Werte)
- Spezifischen Materialien oder Produkten
- Detaillierten Maßen (außer grobe Gebäudegröße)
- Gewerkespezifischen Themen
- Anzahl Fenster/Türen (wenn bereits in Beschreibung)
- Generalunternehmer vs. Einzelvergabe (BYNDL ist für Einzelvergabe konzipiert!)
- Bevorzugter Vergabeart
- Ob alles aus einer Hand gewünscht wird

10. SPEZIAL: DACHAUFSTOCKUNG (NUR bei erkannter Aufstockung):
   - Bauweise der Aufstockung (Holzbau vs. Massivbau)
   - Statisches Gutachten vorhanden?
   - Maximale zusätzliche Last bekannt?

${istDachaufstockung ? `
PFLICHTFRAGE BEI DACHAUFSTOCKUNG:
"Welche Bauweise ist für die Aufstockung geplant?"
- Optionen: ["Holzbauweise/Holzrahmenbau (leichter)", "Massivbau (Mauerwerk/Beton)", "Noch offen - Beratung gewünscht"]
- WICHTIG: Diese Antwort bestimmt die weiteren Gewerke-Fragen!
` : ''}

BEISPIELE VERBOTENER INTAKE-FRAGEN:
- "Welche Dämmstärke ist gewünscht?" → GEHÖRT ZU FASS/DACH
- "Welche Putzstruktur?" → GEHÖRT ZU FASS/MAL
- "Welche Fliesenart?" → GEHÖRT ZU FLI
- "Welches Heizsystem?" → GEHÖRT ZU HEI
- "Anzahl Steckdosen?" → GEHÖRT ZU ELEKT

Die Intake-Fragen dienen NUR zur Vorbereitung der Baustelle!
KRITISCH: Stelle NUR relevante Intake-Fragen für die erkannten Gewerke!

Diese Informationen werden für die Vorbemerkungen aller LVs verwendet. 
  
══════════════════════════════════════════════════════════════════════` 
: 
`╔══════════════════════════════════════════════════════════════════╗
║                   GEWERKE-FRAGEN MODUS                            ║
║                     Gewerk: ${tradeName}                          ║
╚══════════════════════════════════════════════════════════════════╝

WICHTIG: Erstelle einen GEZIELTEN Fragenkatalog für ${tradeName}.

${knownCalculationData ? createCalculationContext(knownCalculationData, tradeCode) : ''}

WICHTIG: Berücksichtige alle nachfolgenden Regeln und bereits vorhandene Informationen!`}

${extractedData ? `
BEREITS AUS PROJEKTBESCHREIBUNG EXTRAHIERT (NIEMALS ERNEUT FRAGEN!):
${extractedData.quantities ? Object.entries(extractedData.quantities).map(([key, value]) => 
  `- ${key}: ${value}`).join('\n') : ''}
${extractedData.measures?.length ? `- Maßnahmen: ${extractedData.measures.join(', ')}` : ''}
${extractedData.rooms?.length ? `- Räume: ${extractedData.rooms.join(', ')}` : ''}
${extractedData.specificDetails ? Object.entries(extractedData.specificDetails).map(([key, value]) => 
  `- ${key}: ${value}`).join('\n') : ''}

WICHTIG: Diese Informationen sind DEFINITIV BEKANNT. Stelle KEINE Fragen dazu!
` : ''}

${allAnsweredInfo?.fromIntake?.length > 0 ? `
BEREITS IN INTAKE BEANTWORTET (NIEMALS WIEDERHOLEN!):
${allAnsweredInfo.fromIntake.map(item => 
  `- ${item.question_text}: ${item.answer_text}`
).join('\n')}
` : ''}

UNIVERSELLE REGEL - NUR FRAGEN WAS ERWÄHNT WURDE:
- Wenn Nutzer "Fassadendämmung" sagt → NICHT nach Dachdämmung fragen
- Wenn Nutzer "Bad renovieren" sagt → NICHT nach Küche fragen
- Wenn Nutzer "Parkett verlegen" sagt → NICHT nach Fliesen fragen
- Generell: NUR zu dem fragen, was explizit im Projektumfang erwähnt wurde
- Bei Unklarheiten: Lieber eine offene Frage stellen als Annahmen treffen

${['DACH', 'FASS', 'FEN'].includes(tradeCode) ? `
GERÜST-REGEL FÜR ${tradeName}:
- KEINE Fragen zum Gerüst stellen!
- Gerüst wird als separates Gewerk behandelt
- In LV kommt Vorbemerkung: "Gerüst wird bauseits gestellt"
- Keine Fragen zu Gerüsthöhe, Standzeit, Gerüstart
` : ''}

PROJEKT-KONTEXT:
- Beschreibung: ${projectContext.description || 'Nicht angegeben'}
- Kategorie: ${projectContext.category || 'Nicht angegeben'}
- Budget: ${projectContext.budget || 'Nicht angegeben'}

${innenprojektText}
${schadensfrageText}

KRITISCHE REGELN FÜR LAIENVERSTÄNDLICHE FRAGEN:

0. KURZE ERKLÄRUNGEN SIND PFLICHT:
   - "explanation": NUR 15-20 Wörter! Kernaussage warum die Information benötigt wird
   - Kurze Anleitungen im ersten Schritt
   - Details werden bei Bedarf nachgeladen
   
   Beispiele für KURZE explanation:
   - "Benötigt für präzise Gerüstkalkulation und sichere Arbeitsplanung"
   - "Beeinflusst Materialwahl und Arbeitsaufwand erheblich"  
   - "Wichtig für korrekte Mengenberechnung der Abdichtung"
   - "Bestimmt ob statische Verstärkungen notwendig sind"

1. MASSEINHEITEN IMMER IM FRAGENTEXT ANGEBEN:
   - Bei Zahlenfragen IMMER die Einheit direkt im Text: "Wie groß ist die Fläche in m²?"
   - Niemals nur "Wie groß ist die Fläche?" ohne Einheit
   - Gängige Einheiten: m² (Quadratmeter), m (Meter), cm, mm, m³ (Kubikmeter), Stück, kg
   - Die Einheit MUSS im Fragentext stehen, nicht nur im unit-Feld

2. MEHRFACHAUSWAHL ERMÖGLICHEN:
   - Bei Fragen wo mehrere Antworten sinnvoll sind: "multiSelect": true setzen
   - AUTOMATISCH Mehrfachauswahl bei:
     * Sanitärgegenstände (WC, Waschbecken, Dusche, Badewanne)
     * Gewerke-Auswahl
     * Materialien/Oberflächen
     * Ausstattungsmerkmale
   - Bei Mehrfachauswahl: type = "multiselect" ODER "text" für Freitext
   - Beispiele für Mehrfachauswahl-Fragen:
     * "Welche Sanitärgegenstände sollen installiert werden?"
     * "Welche Räume sollen gestrichen werden?"
     * "Welche Elektroinstallationen sind gewünscht?"  
   
3. FACHBEGRIFFE ERKLÄREN:
   - Bei Fachbegriffen IMMER eine Erklärung in der "explanation" 
   - Beispiel: "Ortgang" → Erklärung: "Der seitliche Dachabschluss am Giebel"
   - Beispiel: "Unterkonstruktion" → Erklärung: "Das Traggerüst unter der sichtbaren Oberfläche"

4. MESSANLEITUNGEN BEI KOMPLEXEN MASSEN:
   - Erkläre WIE gemessen wird
   - Beispiel: "Kranreichweite" → "Abstand vom Kranstandort zum entferntesten Arbeitspunkt"
   - Bei unklaren Mengen: IMMER "unsicher/weiß nicht" als Option

5. KEINE FRAGEN DIE LAIEN NICHT BEANTWORTEN KÖNNEN:
   - NICHT fragen nach: Arbeitsdauer, Kranreichweite, Kubikmeter Schutt, Lastberechnungen
   - NICHT fragen nach: Anzahl Lagen Abdichtung (außer bei Reparatur bekannt)
   - Stattdessen: Sinnvolle Annahmen treffen und in LV einarbeiten

6. INTELLIGENTE ANNAHMEN STATT DOPPELFRAGEN:
   - Wenn nach Dachfläche gefragt → Abdichtungsfläche = Dachfläche + 5%
   - Wenn nach Wandfläche gefragt → Deckenfläche aus Raumgröße ableiten
   - Annahmen klar kommunizieren: "Wir gehen von X aus, basierend auf Y"

7. INTELLIGENTE FRAGENLOGIK:
   - Bereits erfasste Daten NIEMALS erneut abfragen
   - Aus vorhandenen Daten ableiten:
     * Raumhöhe vorhanden → Wandfläche = Umfang × Höhe
     * Grundfläche vorhanden → Deckenfläche = Grundfläche
     * Außenwandfläche → Fassadenfläche = Außenwand - Fenster/Türen
   - Redundanzen vermeiden: Frage NUR was wirklich fehlt

8. PROJEKTKONTEXT BEACHTEN:
   - Bei "Fassadensanierung" + Gewerk "MAL" → Fragen zu AUSSENanstrich
   - Bei "Badsanierung" + Gewerk "MAL" → Fragen zu feuchtraumgeeigneter Farbe
   - ERSTE FRAGE bei manuell hinzugefügtem Gewerk: "Welche Arbeiten sollen in diesem Gewerk ausgeführt werden?"

9. UNSICHER-OPTIONEN & ANNAHMEN:
   - Bei schwer schätzbaren Werten IMMER "unsicher" anbieten
   - Annahmen transparent machen:
     * "Falls unsicher: Wir kalkulieren mit Standardwerten"
     * "Übliche Werte: Raumhöhe 2,50m, Wandstärke 24cm"
   - Validierung anbieten:
     * "Möchten Sie die Standardannahme verwenden?"

10. VERMEIDUNG VON LAIEN-ÜBERFORDERUNG:
   - NICHT fragen nach:
     * Technischen Details (U-Wert, Lastberechnung, Bewehrung)
     * Zeitschätzungen (Arbeitsstunden, Trocknungszeiten)
     * Fachspezifischen Mengen (m³ Beton, kg Bewehrung)
   - STATTDESSEN:
     * Sichtbare/messbare Größen erfragen
     * Aus diesen technische Werte ableiten

11. INTELLIGENTE FRAGE-ABHÄNGIGKEITEN:
   - KRITISCH: Folgefragen MÜSSEN vorherige Antworten berücksichtigen
   - Verwende bedingte Logik in Fragen mit "dependsOn" und "showIf" Feldern
   - Beispiele:
     * Wenn "Trockenbauwände erstellen?" = "Nein" → KEINE Fragen zu Wanddämmung, Wandhöhe, etc.
     * Wenn "Fliesen gewünscht?" = "Nein" → KEINE Fragen zu Fliesenformat, Fugenfarbe, etc.
     * Wenn "Dachsanierung?" = "Teilsanierung" → NUR Fragen zum betroffenen Bereich
   - Struktur für bedingte Fragen:
     {
       "id": "TRO-02",
       "question": "Sollen die Trockenbauwände gedämmt werden?",
       "dependsOn": "TRO-01",
       "showIf": "ja",
       "type": "select",
       "options": ["ja", "nein"]
     }
   - Bei Verneinung: Überspringe alle abhängigen Detailfragen
   - Bei Unsicherheit: Stelle Basisfragen, aber keine Detailfragen

12. GEWERKEABGRENZUNG & SCHNITTSTELLENKLARHEIT:
   - KEINE Doppelungen zwischen Gewerken
   - Hierarchie: Spezialgewerk > Hauptgewerk > Nebengewerk
   
   KRITISCHE ZUORDNUNGEN (IMMER EINHALTEN):
   * Fliesenarbeiten: AUSSCHLIESSLICH Gewerk FLI (Fliesenarbeiten), NIEMALS BOD (Bodenbelagsarbeiten)
   * Innentüren/Zargen: AUSSCHLIESSLICH Gewerk TIS (Tischlerarbeiten), NIEMALS TRO (Trockenbau) oder FEN (Fenster/Türen)
   * Rigips/Gipskartonwände: AUSSCHLIESSLICH Gewerk TRO (Trockenbau), NIEMALS ROH (Rohbau)
   * Putzqualitäten Q1-Q3: NUR bei Innenputz im Gewerk MAL (Malerarbeiten), NIEMALS bei FASS (Fassade)
   * Fassadenputz: Nur Struktur (Glattputz, Kratzputz, Scheibenputz) und Körnung bei FASS
   * Durchbrüche: NUR Abbruch ODER Rohbau, nie beide
   * Gerüst: NUR Gerüstbau ODER einmalig in anderem Gewerk
   * Entsorgung: Beim verursachenden Gewerk
   * Elektroschlitze: NUR bei ELEKT, nicht bei ROH oder ABBR
   * Sanitärschlitze: NUR bei SAN, nicht bei ROH oder ABBR
   * Fenster: Nur im Gewerk FEN, Dachfenster nur im Gewerk DACH
   * Elektrische Fußbodenheizung: NUR bei ELEKT oder FLI, NIEMALS bei SAN
   * Elektrischer Handtuchheizkörper: Gerät bei SAN, Stromanschluss bei ELEKT
   * Warmwasser-Fußbodenheizung: NUR bei HEI (Heizung), nicht bei SAN
   * Vorwandinstallation: NUR bei TRO (Trockenbau), nicht bei SAN
   * Abdichtungen Bad: NUR bei FLI (unter Fliesen), nicht bei SAN
   * Dämmung Dach: NUR bei DACH oder ZIMM (je nach Konstruktion), nicht bei FASS
   * Sockeldämmung: NUR bei FASS (Teil des WDVS), nicht separat
   
   GEWERK-SPEZIFISCHE REGELN:
   - FLI (Fliesenarbeiten): 
     * Fliesen, Mosaikarbeiten, Natursteinbeläge in Bad/Küche
     * Abdichtungen unter Fliesen (Verbundabdichtung)
     * Elektrische Fußbodenheizung (optional, alternativ ELEKT)
     * Gefälleestrich in Duschen
   
   - BOD (Bodenbelagsarbeiten): 
     * Parkett, Laminat, Vinyl, Teppich, PVC, Linoleum
     * KEINE Fliesen oder Naturstein!
     * Sockelleisten passend zum Bodenbelag
   
   - TIS (Tischlerarbeiten): 
     * Innentüren und Zargen (IMMER)
     * Einbaumöbel, Holzarbeiten
     * Holztreppen (nicht Beton)
     * KEINE Fenster oder Außentüren
   
   - TRO (Trockenbau): 
     * Rigipswände, Gipskarton, Metallständerwerk
     * Abgehängte Decken
     * Vorwandinstallationen für Sanitär
     * Schachtverkleidungen
     * KEINE tragenden Wände!
   
   - ROH (Rohbau): 
     * Mauerwerk, Beton, Stahlbeton
     * Tragende Konstruktionen
     * Ringanker, Stürze, Decken
     * KEINE Leichtbauwände oder Holzkonstruktionen!
   
   - MAL (Malerarbeiten): 
     * Innenputz mit Q1-Q3 Qualitäten
     * Anstriche, Tapeten, Spachteltechniken
     * Grundierungen
     * KEINE Fassadenarbeiten!
   
   - FASS (Fassade): 
     * Außenputz mit Struktur/Körnung
     * WDVS komplett inkl. Sockeldämmung
     * Fassadenanstrich
     * KEINE Q-Stufen, nur Strukturangaben!
   
   - ELEKT (Elektroarbeiten):
     * Alle Elektroinstallationen
     * Schlitze für Elektroleitungen (IMMER)
     * Elektrische Fußbodenheizung (Anschluss/komplett)
     * FI-Schutzschalter, Potentialausgleich
     * PV-AC-Seite, Wallbox
     * Smart Home Verkabelung
   
   - SAN (Sanitär):
     * Sanitärobjekte (WC, Waschbecken, Dusche, Wanne)
     * Wasser-/Abwasserleitungen
     * Elektrische Handtuchheizkörper (Gerät)
     * Armaturen
     * KEINE Vorwandinstallation (→ TRO)
     * KEINE elektrische Fußbodenheizung (→ ELEKT/FLI)
   
   - HEI (Heizung):
     * Heizkessel, Wärmepumpe, Brennwertgerät
     * Warmwasser-Fußbodenheizung
     * Heizkörper (wasserbetrieben)
     * Heizungsverrohrung
     * KEINE elektrischen Heizsysteme
   
   - ZIMM (Zimmerer):
     * Dachstuhl, Holzkonstruktionen
     * Holzbalkendecken
     * Gauben (Holzkonstruktion)
     * Carport, Holzständerwerk
     * Bei Holzbau: auch Dämmung
   
   - DACH (Dachdecker):
     * Dacheindeckung, Dachziegel
     * Dachrinnen, Fallrohre
     * Dachfenster (IMMER, nicht FEN)
     * Dachdämmung (bei Massivbau)
     * Flachdachabdichtung
   
   WICHTIGE SCHNITTSTELLEN-MATRIX:
   
   - Bad-Sanierung: 
     SAN/ELEKT/HEI (Rohinstallation) → TRO (Vorwand) → FLI (Abdichtung + Fliesen) → MAL (Anstrich) → SAN/ELEKT/HEI (Endmontage)
     
   - Dachausbau: 
     ZIMM/DACH (Konstruktion) → ELEKT/SAN/HEI (Leitungen) → TRO (Verkleidung) → MAL/BOD/FLI (Finish) → SAN/ELEKT/HEI (Endmontage)
     
   - Fassade mit WDVS: 
     GER (Gerüst) → FASS (WDVS + Dämmung) → FASS (Putz + Anstrich)
   
   - Heizungstausch: 
     HEI (Heizung) → ELEKT (Stromanschluss) → MAL (Anstrich Heizungsraum)
   
   - Kernsanierung Wohnung:
     ABBR (Entkernung) → ELEKT/SAN (Grundleitungen) → ROH (Wanddurchbrüche) → TRO (neue Raumaufteilung) → ESTR (Estrich) → FLI/BOD (Bodenbeläge) → TIS (Türen) → MAL (Komplettanstrich)
   
   - Kellersanierung (feucht):
     ABBR (Putz entfernen) → ROH (Abdichtung) → SAN/ELEKT (neue Leitungen) → TRO/MAL (Wandaufbau) → BOD (Bodenbelag)
   
   - Energetische Komplettsanierung:
     GER (Gerüst) → DACH (Dachdämmung) → FEN (Fenstertausch) → FASS (Fassadendämmung) → HEI (neue Heizung) → PV (Solaranlage)
   
   - Aufstockung:
     ROH (Verstärkung Bestand) → ZIMM (Holzaufbau) → DACH (Eindeckung) → FEN (Fenster) → ELEKT/SAN/HEI (Installation) → TRO (Innenausbau) → MAL/BOD/FLI (Finish) → SAN/ELEKT/HEI (Endmontage)   
   
   - Küchensanierung:
     ELEKT/SAN (Anschlüsse verlegen) → FLI (Fliesenspiegel) → TIS (Küchenmontage) → ELEKT (E-Geräte anschließen)
   
   - Balkon-/Terrassensanierung:
     ABBR (Altbelag entfernen) → ROH (Gefälle/Abdichtung) → FLI (Belag + Randabschluss) → SCHL (Geländer)
   
   - Altbau-Deckensanierung:
     ABBR (Fehlboden öffnen) → ZIMM (Balkenverstärkung) → TRO (Schallschutz + Verkleidung) → MAL (Stuck + Anstrich)
   
   - Wanddurchbruch mit Sturz:
     ROH (Statik + Durchbruch + Sturz) → MAL (Putz + Anstrich)
   
   - Dachterrasse neu:
     DACH (Abdichtung) → FLI (Plattenbelag) → SCHL (Geländer) → ELEKT (Außenbeleuchtung)
   
   - Smart-Home-Nachrüstung:
     ELEKT (KNX/Bus-Leitungen) → TRO (Kabelkanäle verkleiden) → MAL (Spachtel + Anstrich) → ELEKT (Endgeräte)
   
   - Schimmelsanierung:
     ABBR (befallene Teile entfernen) → ROH (Ursache beheben) → MAL (Spezialgrundierung) → TRO/MAL (Neuaufbau)
   
   - Barrierefreier Umbau:
     ROH (Türverbreiterung) → SAN (bodengleiche Dusche) → FLI (rutschfeste Fliesen) → TIS (breite Türen) → ELEKT (Notrufsystem)
   
   - PV-Installation Bestand:
     DACH (Dachhaken) → PV (Module + DC) → ELEKT (AC + Zähler + Speicher) → ELEKT (Wallbox)
   
   - Wintergarten-Anbau:
     ROH (Fundament + Bodenplatte) → FEN (Wintergarten-Konstruktion) → ELEKT/HEI (Anschlüsse) → FLI/BOD (Bodenbelag)
   
   REIHENFOLGE-PRINZIPIEN:
   1. Abbruch/Rückbau immer zuerst
   2. Rohbau/Statik vor Ausbau
   3. Installationen (ELEKT/SAN/HEI) vor Verkleidung
   4. Trockenbau vor Nassarbeiten wo möglich
   5. Bodenbeläge nach Wänden
   6. Malerarbeiten als Finish
   7. Endmontage Sanitär/Elektro ganz zum Schluss
   
13. MANUELL HINZUGEFÜGTE UND DURCH KI-EMPFOHLENE GEWERKE:
   - ERSTE FRAGE MUSS IMMER SEIN: "Welche konkreten ${tradeName}-Arbeiten sollen durchgeführt werden?"
   - Type: "text", required: true
   - Zweite Frage: "In welchem Umfang?" mit Mengenerfassung
   - Weitere Fragen basierend auf Projektkontext
   - ID der ersten Frage: "${tradeCode}-CONTEXT"

14. INTELLIGENTE FELDTYP-AUSWAHL:
   - Bei Fragen nach mehreren Objekten/Gegenständen: 
     * Verwende "type": "text" für freie Eingabe ODER
     * Verwende "type": "multiselect" mit "multiSelect": true
   - Erkennungsmuster für Mehrfachauswahl:
     * Frage enthält "Welche" (Plural)
     * Frage nach Gegenständen/Objekten im Plural
     * Sanitär-, Elektro-, Ausstattungsfragen
   - NIE nur Dropdown bei offensichtlichen Mehrfachauswahl-Szenarien
   
  ${tradeCode === 'FEN' ? `
15. SPEZIELLE FENSTER-REGELN:
   PFLICHTFRAGEN für Fenster-Gewerk:
   
   - Frage 1: "Wie viele Fenster insgesamt?"
   
   - Frage 2: "Welche EXAKTEN MAßE haben die EINZELNEN Fenster?"
     * MUSS für JEDES Fenster einzeln erfassen:
       - Breite x Höhe in cm
       - Raumbezeichnung/Position
     * Format: "Fenster 1 (Wohnzimmer): 150x140cm"
     * NIEMALS nur Gesamtfläche oder Durchschnittswerte!
   
   - Frage 3: "Welche ÖFFNUNGSART pro Fenster?"
     * Optionen: Dreh-Kipp, Fest verglast, Kipp, Dreh, Schiebe, Hebe-Schiebe
     * MUSS für jeden Fenstertyp spezifiziert werden
   
   - Frage 4: "Welches RAHMENMATERIAL?"
     * Optionen: Kunststoff, Holz, Holz-Aluminium, Aluminium
     * Preisunterschied bis zu 100% zwischen Kunststoff und Holz-Alu!
   
   - Frage 5: "Welche VERGLASUNG/ENERGETIK?"
     * PFLICHT: 2-fach, 3-fach Standard, 3-fach Premium
     * Mit Uw-Werten: 2-fach (~1.3), 3-fach (~1.0), 3-fach Premium (~0.8)
     * Beeinflusst Preis um 15-35%
   
   - Frage 6: "Welche SICHERHEITSANFORDERUNGEN?"
     * Optionen: Keine, RC1, RC2, RC2N, RC3
     * RC2 = Standard Einbruchschutz (+25-35% Preis)
     * RC3 = Erhöhter Einbruchschutz (+45% Preis)
     * WICHTIG für Erdgeschoss und zugängliche Fenster
   
   - Frage 7: "Sollen alte Fenster DEMONTIERT werden?"
     * Inkl. Entsorgung oder nur Demontage?

    ABSOLUT KRITISCHE MATERIAL-REGEL:
   ═══════════════════════════════════════
   Das vom Nutzer gewählte Rahmenmaterial ist VERBINDLICH und MUSS 
   1:1 in ALLEN Fenster-Positionen verwendet werden:
   
   ⚠️ MATERIAL-ANTWORT → LV-POSITIONEN:
   ════════════════════════════════════════
   "Holz" → NUR HOLZFENSTER im gesamten LV!
   "Kunststoff" oder "PVC" → NUR KUNSTSTOFFFENSTER im gesamten LV!
   "Aluminium" oder "Alu" → NUR ALUMINIUMFENSTER im gesamten LV!
   "Holz-Aluminium" → NUR HOLZ-ALU-FENSTER im gesamten LV!
   
   ❌ ABSOLUT VERBOTEN:
   - Nutzer wählt "Holz" → LV hat Kunststofffenster = FALSCH!
   - Nutzer wählt "Kunststoff" → LV hat Holzfenster = FALSCH!
   - Material eigenmächtig ändern wegen "Erfahrung" = FALSCH!
   - Verschiedene Materialien mischen = FALSCH!
   
   ✅ KORREKT:
   - Nutzer wählt "Holz" → ALLE Positionen: "Holzfenster"
   - Nutzer wählt "Kunststoff" → ALLE Positionen: "Kunststofffenster"
   - Nutzer wählt "Aluminium" → ALLE Positionen: "Aluminiumfenster"
   - Nutzer wählt "Holz-Alu" → ALLE Positionen: "Holz-Alu-Fenster"
   
   BEISPIEL KORREKTE POSITION bei Material "Holz":
   "Lieferung und Montage HOLZFENSTER 150x140cm, 3-fach Verglasung..."
   
   BEISPIEL FALSCHE POSITION bei Material "Holz":
   "Lieferung und Montage Kunststofffenster..." → MATERIAL FALSCH!
   
   WICHTIGER HINWEIS - GEWERK-ABGRENZUNG:
   ════════════════════════════════════════
   NICHT ins Fenster-Gewerk gehören:
   ❌ Leibungsverputz/Laibungsverputz → gehört zu MALER (innen) oder FASSADE (außen)
   ❌ Malerarbeiten an Leibungen → gehört zu MALER
   ❌ Außenputzarbeiten → gehört zu FASSADE
   
   NUR diese Arbeiten gehören ins Fenster-Gewerk:
   ✅ Fensterlieferung und -montage
   ✅ Abdichtung/Anschlussarbeiten direkt am Fenster
   ✅ Fensterbänke (innen/außen)
   ✅ Rollläden/Jalousien
   ✅ Demontage alter Fenster
   
   KRITISCHE REGEL FÜR LV-ERSTELLUNG:
   ════════════════════════════════════
   JEDES Fenster im LV MUSS enthalten:
   1. EXAKTE Einzelmaße (BxH in cm) - KEINE Typen oder Durchschnitte!
   2. Rahmenmaterial (exakt wie vom Nutzer gewählt!)
   3. Verglasungsart (2-fach/3-fach mit Uw-Wert)
   4. Öffnungsart (Dreh-Kipp, Fest, etc.)
   5. Sicherheitsklasse wenn angegeben (RC2, RC3)
   
   BEISPIEL KORREKTE LV-POSITION:
   "Lieferung und Montage Holzfenster 150x140cm, 3-fach Verglasung Uw 0.8, 
    Dreh-Kipp, RC2, inkl. Montage und Abdichtung"
   
   BEISPIEL FALSCHE LV-POSITION:
   "5 Stk. Fenster Typ A" → KEINE Typisierung!
   "Leibungsverputz" → GEHÖRT NICHT INS FENSTER-GEWERK!
   "Fenster verschiedene Größen" → JEDES einzeln aufführen!
` : ''}

${tradeCode === 'HEI' ? `
16. SPEZIELLE HEIZUNGS-REGELN:
   ERSTE FRAGE: "Liegt bereits eine Heizlastberechnung vor?"
   - Optionen: ["Ja, liegt vor", "Nein, wird noch erstellt", "Unsicher"]
   
   WENN JA: 
   - "Welche Heizkörpergrößen/Leistungen wurden berechnet?"
   - "Bitte Typ, Abmessungen oder Leistung in Watt angeben"
   
   WENN NEIN:
   - "Wie viele Räume sollen beheizt werden?"
   - "Welche Raumgrößen haben die zu beheizenden Räume?"
   - Im LV dann: "Heizkörper gemäß Heizlastberechnung"
   
   KEINE FRAGEN nach:
   - Genauen Heizkörpermaßen ohne Berechnung
   - Erfundenen Standardgrößen
` : ''}

${tradeCode === 'TIS' ? `
17. SPEZIELLE TÜREN-REGELN:
   PFLICHTFRAGEN für Innentüren:
   - "Wie viele Innentüren werden benötigt?"
   - "Welche Türmaße werden benötigt?"
     * Standard: 86x198,5cm, 96x198,5cm, 86x211cm, 96x211cm
     * "Bitte für jede abweichende Größe: Anzahl und Maße angeben"
     * WICHTIG: Bei Maßen über 100cm Breite oder 215cm Höhe: "SONDERMASS" vermerken
   - "Gibt es Türen mit Sondermaßen (z.B. breiter als 100cm oder höher als 215cm)?"
     * Falls ja: "Bitte genaue Maße und Anzahl angeben"
     * Hinweis: "Sondermaße sind deutlich teurer (30-100% Aufpreis)"
   - "Mit oder ohne Zargen?"
   - "Welche Ausführung?" (Weißlack, Echtholz, etc.)
` : ''}

${tradeCode === 'SAN' ? `
18. SPEZIELLE SANITÄR-REGELN:
   Bei Sanitärobjekten:
   - "Welche Sanitärobjekte sollen installiert werden?" 
     * type: "multiselect" mit multiSelect: true
     * Optionen: ["WC", "Waschbecken", "Dusche", "Badewanne", "Bidet"]
   - Für jedes Objekt: "Standardmaß oder Sondermaß?"
   - Nur bei Sondermaß: Nach konkreten Maßen fragen
` : ''}

${tradeCode === 'FASS' ? `
SPEZIELLE REGEL FÜR DÄMMSTÄRKEN-FRAGE:
- Frage nach EINER konkreten Dämmstärke, NICHT nach Bereichen!
- FALSCH: "Welche Dämmstärke (12-14 cm, 16-18 cm, 18-20 cm)?"
- RICHTIG: "Welche Dämmstärke in cm? (12, 14, 16, 18, 20, 22, 24)"
- Der Nutzer soll EINE Zahl wählen oder eingeben
- Options-Array: [12, 14, 16, 18, 20, 22, 24, 26] als einzelne Werte
` : ''}

${tradeCode === 'ROH' ? `
19. SPEZIELLE ROHBAU-REGELN:
   
   GRUNDREGEL: Rohbau macht Massivbauarbeiten!
   
   STANDARD-ABGRENZUNG (gilt immer):
   ================================
   ROHBAU MACHT:
   - Mauerwerk (Ziegel, Kalksandstein, Porenbeton)
   - Betonarbeiten (Wände, Decken, Stützen)
   - Stahlbetonarbeiten
   - Durchbrüche und Kernbohrungen
   - Ringanker und Stürze
   
   ROHBAU MACHT NICHT:
   - Trockenbau/Leichtbauwände (→ gehört zu TRO)
   - Holzkonstruktionen (→ gehört zu ZIMM)
   - Verputzarbeiten (→ gehört zu MAL/FASS)
   - Dämmarbeiten (→ gehört zu jeweiligem Gewerk)
   
   ${projectContext.istDachaufstockung ? `
   ╔══════════════════════════════════════════════════════════════════╗
   ║ SONDERFALL: DACHAUFSTOCKUNG - BEDINGTE AKTIVIERUNG               ║
   ╚══════════════════════════════════════════════════════════════════╝
   
   ${projectContext.aufstockungsBauweise === 'massivbau' ? `
   MASSIVBAUWEISE GEWÄHLT → Rohbau ist AKTIV:
   ✓ Komplette Massivwände der Aufstockung
   ✓ Ringanker/Ringbalken für Dachauflage
   ✓ Ggf. Betonstützen oder Stahlbetonwände
   ✓ Neue Geschossdecke falls nötig
   
   PFLICHTFRAGEN bei Massivbau-Aufstockung:
   - "Welches Mauerwerk für die Aufstockung (Ziegel, Kalksandstein, Porenbeton)?"
   - "Welche Wandstärke für die Aufstockungswände?"
   - "Wie viele m² Wandfläche in Massivbauweise?"
   - "Wird eine neue Geschossdecke benötigt?"
   ` : projectContext.aufstockungsBauweise === 'holzbau' ? `
   HOLZBAUWEISE GEWÄHLT → Rohbau NUR für Sonderarbeiten:
   ⚠️ Aufstockungswände macht der Zimmerer!
   
   Rohbau NUR falls zusätzlich benötigt:
   - Verstärkung bestehender Decke
   - Abbrucharbeiten am Bestand
   - Anpassungen am Treppenhaus
   
   Stelle NUR Fragen zu diesen Zusatzarbeiten!
   ` : `
   BAUWEISE NOCH OFFEN → Stelle bedingte Fragen:
   - "Falls Massivbauweise: Welches Mauerwerk?"
   - "Falls Massivbauweise: Welche Wandstärke?"
   - "Unabhängig: Sind Verstärkungen am Bestand nötig?"
   `}
   
   WICHTIG: Bei Holzbau-Aufstockung ist Rohbau meist NICHT beteiligt!
   ` : ''}
   
   GENERELLE ABGRENZUNG:
   - Leichte Bauweise = Zimmerer/Trockenbau
   - Schwere Bauweise = Rohbau
   ${projectContext.istDachaufstockung ? '- Bei Aufstockung: Bauweise entscheidet über Zuständigkeit!' : ''}
` : ''}

${tradeCode === 'ZIMM' ? `
18. SPEZIELLE ZIMMERER-REGELN:
   
   GRUNDREGEL: Zimmerer macht NUR Holzkonstruktionen!
   
   STANDARD-ABGRENZUNG (gilt immer):
   ================================
   ZIMMERER MACHT:
   - Dachstuhl / Holztragwerk
   - Holzkonstruktionen
   - Sparren, Pfetten, First
   - Gauben-Holzkonstruktion
   
   ZIMMERER MACHT NICHT (gehört zum Dachdecker):
   - Dachdämmung
   - Dampfbremse/Dampfsperre
   - Dacheindeckung/Ziegel
   - Unterspannbahn
   - Dachrinnen
   
   ${projectContext.istDachaufstockung ? `
   ╔══════════════════════════════════════════════════════════════════╗
   ║ SONDERFALL: DACHAUFSTOCKUNG - ERWEITERTE REGELN                  ║
   ╚══════════════════════════════════════════════════════════════════╝
   
   ${projectContext.aufstockungsBauweise === 'holzbau' ? `
   HOLZBAUWEISE → Zimmerer macht ZUSÄTZLICH:
   ✓ Komplette Holzrahmenwände der Aufstockung
   ✓ Ständerwerk-Konstruktion der Wände
   ✓ Beplankung (OSB, Gipskarton)
   ✓ Wanddämmung im Holzrahmen
   ✓ PLUS den normalen Dachstuhl obendrauf
   
   ZUSÄTZLICHE PFLICHTFRAGEN bei Holzbau-Aufstockung:
   - "Welche Wandhöhe soll die Aufstockung haben?"
   - "Wie viele m² Wandfläche in Holzrahmenbauweise?"
   - "Welche Beplankung gewünscht (OSB, Gipskarton, etc.)?"
   ` : projectContext.aufstockungsBauweise === 'massivbau' ? `
   MASSIVBAUWEISE → Zimmerer macht NUR Dachstuhl:
   ✗ KEINE Wände (macht Rohbau in Massivbauweise)
   ✓ NUR Standard-Dachstuhl auf der Massiv-Aufstockung
   
   Fokussiere NUR auf Dachstuhl-Fragen!
   ` : `
   BAUWEISE NOCH OFFEN → Stelle bedingte Fragen:
   - "Falls Holzbauweise gewählt: [Wandfragen]"
   - "Falls Massivbauweise: [nur Dachfragen]"
   - "In beiden Fällen: [Dachstuhl-Details]"
   `}` : ''}
   
   MERKE: Bei normalen Dachprojekten arbeiten Zimmerer und Dachdecker nacheinander.
   ${projectContext.istDachaufstockung ? 'Bei Aufstockungen kommt ggf. noch Rohbau (Massivbau) oder erweiterter Zimmerer-Umfang (Holzbau) dazu.' : ''}
` : ''}

${['FEN', 'TIS', 'SAN', 'HEI', 'FLI'].includes(tradeCode) ? `
ALLGEMEINE MAß-REGEL für ${tradeName}:
- IMMER nach konkreten Einzelmaßen fragen
- NIE nur Gesamtflächen oder pauschale Angaben
- Format: "Anzahl x Maß" für jeden unterschiedlichen Typ
- Bei Unsicherheit: "Maße vor Ort aufnehmen" als Option
` : ''}

   FRAGENANZAHL: ${targetQuestionCount} Fragen
- Vollständigkeit: ${intelligentCount.completeness}%
- Fehlende Info: ${intelligentCount.missingInfo.join(', ') || 'keine'}
- Bei hoher Vollständigkeit: WENIGER Fragen stellen als vorgegeben!

OUTPUT als JSON-Array mit genau ${targetQuestionCount} Fragen.
Jede Frage muss einen klaren Mehrwert für die LV-Erstellung bieten!
   
FRAGENANZAHL: ${targetQuestionCount} Fragen
- Vollständigkeit: ${intelligentCount.completeness}%
- Fehlende Info: ${intelligentCount.missingInfo.join(', ') || 'keine'}
- Bei Vollständigkeit >80%: Reduziere auf ${Math.floor(targetQuestionCount * 0.6)} Fragen
- Bei Vollständigkeit 50-80%: Reduziere auf ${Math.floor(targetQuestionCount * 0.8)} Fragen
- Bei Vollständigkeit <50%: Stelle alle ${targetQuestionCount} Fragen

╔══════════════════════════════════════════════════════════════════╗
║                   DATEI-UPLOAD UNTERSTÜTZUNG                      ║
╚══════════════════════════════════════════════════════════════════╝

Bei JEDER Frage musst du entscheiden: Würde ein Datei-Upload dem Nutzer helfen?

UPLOAD IST HILFREICH (uploadHelpful: true) bei:

1. LISTEN MIT VIELEN ELEMENTEN:
   ✓ Fenster/Türenlisten (>3 verschiedene Größen)
   ✓ Sanitärobjekte in mehreren Räumen
   ✓ Heizkörper-Übersicht
   ✓ Elektroausstattung pro Raum
   ✓ Raumlisten mit Flächen
   ✓ Materialspezifikationen
   
2. VISUELLE BEWERTUNGEN:
   ✓ Zustandsbewertung (Risse, Schäden, Verschmutzung)
   ✓ Farbauswahl (Muster, Referenzbilder)
   ✓ Materialerkennung (Putzstruktur, Bodenbelag)
   ✓ Bestandsaufnahme (vorhandene Installation)
   
3. TECHNISCHE DOKUMENTE:
   ✓ Pläne, Grundrisse, Schnitte
   ✓ Bestehende Angebote/LVs zum Vergleich
   ✓ Technische Datenblätter
   ✓ Heizlastberechnungen
   ✓ Statische Gutachten
   ✓ Energieausweise
   
4. MAßE UND ABMESSUNGEN:
   ✓ Aufmaß-Listen (Excel/PDF)
   ✓ Vermessungsdaten
   ✓ CAD-Zeichnungen

UPLOAD IST NICHT HILFREICH (uploadHelpful: false) bei:

✗ Einzelne Zahlenwerte (z.B. "Wie groß ist die Fläche?")
✗ Ja/Nein-Fragen
✗ Einfache Auswahlfelder
✗ Zeitangaben (Startdatum, Dauer)
✗ Textfragen (Beschreibungen, Namen)
✗ Einfache Mengen bis 3 Items

UPLOAD-HINTS - STRIKTE REGELN:

1. IMMER mit "Optional:" beginnen
2. MAXIMAL 15 Wörter
3. Konkret benennen WAS hochgeladen werden kann
4. Mehrere Optionen mit "oder" trennen
5. NUR wenn uploadHelpful=true, sonst null

BEISPIELE FÜR GUTE UPLOAD-HINTS:

✓ "Optional: Excel-Liste mit Fenstermaßen oder Fotos der Fenster"
✓ "Optional: Raumliste mit Flächen als Excel/PDF"
✓ "Optional: Fotos des aktuellen Zustands für Schadensanalyse"
✓ "Optional: Grundriss-PDF oder Bauplan zur Maßermittlung"
✓ "Optional: Bestehende Angebote oder LVs zum Vergleich"
✓ "Optional: Heizlastberechnung als PDF falls vorhanden"
✓ "Optional: Excel mit Sanitärobjekten pro Raum"
✓ "Optional: Produktdatenblätter oder Spezifikationen"

BEISPIELE FÜR SCHLECHTE UPLOAD-HINTS:

✗ "Sie können hier eine Datei hochladen" (zu allgemein)
✗ "Optional: Alle relevanten Dokumente" (nicht konkret)
✗ "Bitte Dateien anhängen wenn vorhanden" (zu lang)
✗ "Fotos, Pläne, Excel, PDFs möglich" (zu viele Optionen)

TRADE-SPEZIFISCHE UPLOAD-EMPFEHLUNGEN:

FEN (Fenster):
- Bei Frage nach Einzelmaßen: uploadHelpful=true
- Hint: "Optional: Excel-Liste mit Fenstermaßen oder Fotos"

TIS (Türen):
- Bei Frage nach Türliste: uploadHelpful=true
- Hint: "Optional: Excel-Liste mit Türmaßen pro Raum"

SAN (Sanitär):
- Bei Objektauswahl: uploadHelpful=true
- Hint: "Optional: Raumplan mit Sanitärobjekten oder Fotos"

HEI (Heizung):
- Bei Heizkörpern: uploadHelpful=true
- Hint: "Optional: Heizlastberechnung oder Raumliste mit Größen"

ELEKT (Elektro):
- Bei Ausstattung: uploadHelpful=true
- Hint: "Optional: Raumplan mit Steckdosen/Schalter-Positionen"

MAL/FLI/BOD (Flächen):
- Bei Raumliste: uploadHelpful=true
- Hint: "Optional: Raumliste mit Flächen als Excel"

DACH/FASS:
- Bei Zustand: uploadHelpful=true
- Hint: "Optional: Fotos für Zustandsbewertung"

GER (Gerüst):
- Bei Fassadenmaßen: uploadHelpful=true
- Hint: "Optional: Grundriss oder Fotos der Fassaden"

ROH/ABBR:
- Bei Durchbrüchen: uploadHelpful=true
- Hint: "Optional: Grundriss mit markierten Durchbrüchen"

OUTPUT (NUR valides JSON-Array):
[
  {
    "id": "string",
    "category": "string", 
    "question": "Verständliche Frage MIT EINHEIT bei Zahlen",
    "explanation": "15-20 Wörter kurzer Hinweis - nur Kerninfo!",
    "type": "text|number|select|multiselect",
    "required": boolean,
    "unit": "m²|m|cm|Stück|null",
    "options": ["Option1", "Option2", "unsicher/weiß nicht"],
    "multiSelect": boolean,
    "defaultAssumption": "Falls 'unsicher': Diese Annahme wird getroffen",
    "measurementGuide": "Optional: Detaillierte Schritt-für-Schritt Messanleitung",
    "productExamples": "Optional: Konkrete Produkte mit Preisen für Standard/Gehoben/Premium",
    "visualHint": "Optional: Visuelle Erkennungsmerkmale",
    "commonMistakes": "Optional: Häufige Fehler die vermieden werden sollten",
    "defaultRecommendation": "Optional: Unsere Standard-Empfehlung mit Begründung",
    "dependsOn": "ID der Vorfrage oder null",
    "showIf": "Antwort die gegeben sein muss oder null",
    "uploadHelpful": boolean,
    "uploadHint": "string|null"
  }
]

KRITISCH: 
- uploadHelpful und uploadHint MÜSSEN in JEDER Frage gesetzt sein!
- Bei uploadHelpful=false → uploadHint=null
- Bei uploadHelpful=true → uploadHint MUSS gesetzt sein (max 15 Wörter)
- Upload-Hints IMMER mit "Optional:" beginnen

ERKLÄRUNG:
- "explanation": MAXIMAL 15-20 Wörter - nur das Wichtigste!
- "uploadHelpful": true/false - Entscheidung ob Upload sinnvoll
- "uploadHint": Konkreter Hinweis WAS hochgeladen werden kann
- Keine strukturierten Teile mehr
- Nur Kernaussage warum die Info benötigt wird

Beispiele für kurze explanation:
- "Bestimmt Gerüstkosten und Sicherheitsanforderungen bei Höhenarbeiten"
- "Beeinflusst Materialauswahl und Arbeitsaufwand erheblich"
- "Wichtig für präzise Mengenkalkulation der Abdichtungsflächen"

${projectContext.intakeContext && !isIntake ? `
WICHTIGER KONTEXT aus der Vorbefragung:
${projectContext.intakeContext}
Berücksichtige diese Informationen bei der Fragenerstellung.` : ''}

${projectContext.isAiRecommended && !isIntake ? `
HINWEIS: Dieses Gewerk wurde aufgrund der Vorbefragung empfohlen. 
Stelle spezifische Fragen zu den relevanten Punkten aus der Vorbefragung.` : ''}`; // Ende des GESAMTEN Template-Strings

// HIER NEUE ERGÄNZUNG EINFÜGEN:
// Zusätzliche Anpassung für AI-empfohlene Gewerke
let finalSystemPrompt = systemPrompt;
if (projectContext.isAiRecommended && !isIntake) {
  finalSystemPrompt += `

KRITISCHE ERGÄNZUNG FÜR AI-EMPFOHLENES GEWERK:
- Dies ist ein VOLLSTÄNDIGER Fragenkatalog, KEINE reduzierte Version
- ALLE gewerkespezifischen Regeln MÜSSEN angewendet werden
- Ziel: ${targetQuestionCount} detaillierte Fragen
- Bei Fenstern: JEDES einzelne Fenster mit Maßen
- Bei Türen: JEDE einzelne Tür mit Maßen
- Qualität wie bei erforderlichen Gewerken!`;
}

// HIER KOMMT DIE NEUE ERGÄNZUNG:
finalSystemPrompt += `

KRITISCH FÜR OUTPUT:
Beginne deine Antwort DIREKT mit [
KEIN Text oder Überschrift vor dem JSON-Array!
Erste Zeile: [
Letzte Zeile: ]`;
  
  const userPrompt = `Erstelle ${targetQuestionCount} LAIENVERSTÄNDLICHE Fragen für ${tradeName}.

PROJEKTKONTEXT:
- Beschreibung: ${projectContext.description || 'Keine'}
- Kategorie: ${projectContext.category || 'Nicht angegeben'}
- Vollständigkeit: ${intelligentCount.completeness}%

${projectContext.isManuallyAdded ? 
`WICHTIG: Dieses Gewerk wurde MANUELL HINZUGEFÜGT oder von der KI EMPFOHLEN!
ERSTE FRAGE MUSS SEIN: "Welche ${tradeName}-Arbeiten sollen im Rahmen der ${projectContext.category || 'Arbeiten'} ausgeführt werden?"` : ''}

FEHLENDE INFOS: ${intelligentCount.missingInfo.join(', ') || 'keine'}

${questionPrompt ? `Template-Basis:\n${questionPrompt.substring(0, 3000)}...\n` : ''}

BEACHTE:
- Fachbegriffe MÜSSEN erklärt werden
- Keine Fragen die Laien nicht beantworten können  
- Bei Mengen/Maßen: "unsicher" Option anbieten
- Sinnvolle Annahmen statt Detailfragen
- Wenn Info vorhanden: WENIGER Fragen stellen!

KRITISCH: Erstelle EXAKT ${targetQuestionCount} Fragen - zähle nach!
NOCHMAL: Es MÜSSEN ${targetQuestionCount} Objekte im JSON-Array sein!
Beginne direkt mit [`;  // ← Nur diese 3 Zeilen am ENDE hinzufügen

  try {
  console.log(`[QUESTIONS] Generating ${targetQuestionCount} questions for ${tradeName}`);
  
  const response = await llmWithPolicy(isIntake ? 'intake' : 'questions', [
    { role: 'system', content: finalSystemPrompt }, 
    { role: 'user', content: userPrompt }
  ], { 
    maxTokens: 10000,
    temperature: 0.35,
    jsonMode: true 
  });

console.log(`[QUESTIONS] Raw response length BEFORE cleaning: ${response.length}`);
    
  // Bereinige die Response
  let cleanedResponse = response
    .replace(/```json\n?/g, '')
    .replace(/```\n?/g, '')
    .trim();

  console.log(`[QUESTIONS] Response length AFTER cleaning: ${cleanedResponse.length}`);
    
  // Entferne alles vor dem ersten [
  const jsonStart = cleanedResponse.indexOf('[');
  if (jsonStart > 0) {
    console.warn(`[QUESTIONS] Removing ${jsonStart} chars before JSON`);
    cleanedResponse = cleanedResponse.substring(jsonStart);
  } else if (jsonStart === -1) {
    throw new Error('No JSON array found in response');
  }
  
  // NEU - VERBESSERTE TRUNCATION-REPARATUR:
if (!cleanedResponse.endsWith(']')) {
  console.warn('[QUESTIONS] Response truncated, attempting fix...');
  
  try {
    // Plan A: Versuche einfaches Schließen (falls nur ']' fehlt)
    const testResponse = cleanedResponse + ']';
    const testParse = JSON.parse(testResponse);
    cleanedResponse = testResponse;
    console.log(`[QUESTIONS] Fixed by adding ']' - recovered ${testParse.length} questions`);
    
  } catch (e) {
    // Plan B: Finde letztes vollständiges Objekt
    let lastValidJson = null;
    let lastValidPosition = -1;
    
    // Gehe rückwärts und finde letztes valides JSON
    for (let i = cleanedResponse.length - 1; i > 0; i--) {
      if (cleanedResponse[i] === '}') {
        try {
          const testJson = cleanedResponse.substring(0, i + 1) + ']';
          const parsed = JSON.parse(testJson);
          lastValidJson = testJson;
          lastValidPosition = i;
          console.log(`[QUESTIONS] Found valid JSON at position ${i} with ${parsed.length} questions`);
          break;
        } catch (parseErr) {
          continue;
        }
      }
    }
    
    if (lastValidJson) {
      cleanedResponse = lastValidJson;
      console.log(`[QUESTIONS] Fixed truncation at position ${lastValidPosition}`);
    } else {
      console.error('[QUESTIONS] Could not fix truncated response');
    }
  }
}
  
  // Parse die Fragen (NUR EINMAL!)
  let questions;
  try {
    questions = JSON.parse(cleanedResponse);
  } catch (parseError) {
    console.error('[QUESTIONS] Failed to parse response:', parseError.message);
    console.log('[QUESTIONS] Raw response length:', cleanedResponse?.length || 0);
    console.log('[QUESTIONS] Raw response first 500 chars:', cleanedResponse?.substring(0, 500) || 'EMPTY');
    
    const detailedError = new Error(`JSON Parse fehlgeschlagen: ${parseError.message}`);
    detailedError.originalError = parseError;
    detailedError.responseSnippet = cleanedResponse?.substring(0, 200);
    throw detailedError;
  }

// ═══════════════════════════════════════════════════════════════
// HIER EINFÜGEN: Upload-Felder Validierung
// ═══════════════════════════════════════════════════════════════

console.log(`[QUESTIONS] Validating upload fields for ${questions.length} questions`);

questions = questions.map(q => {
  // 1. uploadHelpful muss gesetzt sein
  if (q.uploadHelpful === undefined) {
    console.warn(`[QUESTIONS] Missing uploadHelpful in: ${q.question}`);
    q.uploadHelpful = false;
  }
  
  // 2. Bei uploadHelpful=true muss uploadHint gesetzt sein
  if (q.uploadHelpful && !q.uploadHint) {
    console.warn(`[QUESTIONS] Missing uploadHint despite uploadHelpful=true: ${q.question}`);
    q.uploadHint = "Optional: Relevante Dateien hochladen";
  }
  
  // 3. Bei uploadHelpful=false muss uploadHint null sein
  if (!q.uploadHelpful && q.uploadHint !== null) {
    console.warn(`[QUESTIONS] uploadHint set despite uploadHelpful=false: ${q.question}`);
    q.uploadHint = null;
  }
  
  // 4. uploadHint muss mit "Optional:" beginnen
  if (q.uploadHint && !q.uploadHint.startsWith('Optional:')) {
    console.warn(`[QUESTIONS] uploadHint doesn't start with 'Optional:': ${q.uploadHint}`);
    q.uploadHint = 'Optional: ' + q.uploadHint;
  }
  
  return q;
});
    
// SPEZIELLE INTAKE-VALIDIERUNG: Entferne gewerkespezifische Fragen
if (tradeCode === 'INT') {
  const vorherAnzahl = questions.length;
  
  questions = questions.filter(q => {
    const qText = (q.question || '').toLowerCase();

    // NEU: Baustellenbedingungen IMMER behalten
    const baustellenKeywords = [
      'lager', 'lagern', 'lagerung', 'lagerplatz', 'lagerfläche',
      'material.*lager', 'baumaterial.*lager',
      'zugang', 'zufahrt', 'transport', 'anlieferung',
      'baustrom', 'bauwasser', 'sanitär.*handwerker',
      'arbeitszeit', 'lärmschutz', 'staubschutz',
      'gerüst', 'kran', 'aufzug',
      'nachbar', 'genehmigung'
    ];
    
    // Wenn Baustellenbedingung → behalten, egal was sonst im Text steht
    if (baustellenKeywords.some(keyword => qText.match(new RegExp(keyword)))) {
      console.log(`[INT-FILTER] Behalten (Baustellenbedingung): "${q.question.substring(0,60)}..."`);
      return true;
    }
    
    // VERBOTENE technische Details (für alle Gewerke)
    const technischeDetails = [
      // Spezifische Stärken
      /\d+\s*(cm|mm)\s*(dick|stark|stärke)/,
      /dämmstärke|wandstärke|deckenstärke/,
      
      // SPEZIFISCHE FLÄCHEN
      /fassadenfläche|fassade.*m²|m².*fassade/,
      /dachfläche|dach.*m²|m².*dach/,
      /wandfläche|wand.*m²|m².*wand/,
      /bodenfläche|boden.*m²|m².*boden/,
      /deckenfläche|decke.*m²|m².*decke/,
      /fensterfläche|fenster.*m²/,
      /türfläche|tür.*m²/,
      /zu dämmende.*fläche/,
      /zu fliesen.*fläche/,
      /zu streichen.*fläche/,
      
      // ANZAHLEN/STÜCKZAHLEN (NEU)
      /wie viele.*fenster|anzahl.*fenster|fenster.*anzahl/,
      /wie viele.*türen|anzahl.*türen|türen.*anzahl/,
      /wie viele.*heizkörper|anzahl.*heizkörper/,
      /wie viele.*steckdosen|anzahl.*steckdosen/,
      /wie viele.*schalter|anzahl.*schalter/,
      /wie viele.*leuchten|anzahl.*leuchten/,
      /wie viele.*räume.*streichen/,
      /wie viele.*wände/,
      /stückzahl|stück.*fenster|stück.*türen/,
      // ERLAUBT bleiben: Anzahl Geschosse/Etagen, Anzahl Räume (allgemein)
      
      // Materialauswahl
      /material.*auswahl|welches.*material/,
      /dämmmaterial|putzmaterial|fugenmaterial/,
      
      // Farben
      /farbe|farbton|ral/,
      
      // Oberflächendetails
      /struktur|körnung|oberfläche/,
      /putzstruktur|kratzputz|rillenputz/,
      
      // Qualitätsstufen
      /qualität|ausführung.*variant/,
      /q1|q2|q3|q4/,
      
      // Produktspezifika
      /produkt|hersteller|marke/,
      
      // Technische Kennwerte
      /dämmwert|u-wert|kennwert|lambda/,
      
      // Detailmaße
      /format|maße.*einzel/,
      /fenster.*\d+.*\d+|tür.*\d+.*\d+/,
      
      // Ausführungsdetails
      /verlegeart|einbauart|montage.*art/
    ];
    
    const istTechnisch = technischeDetails.some(pattern => qText.match(pattern));
    
    // NEU: Ausnahme für wichtige offene Intake-Fragen
    const istOffeneFrage = qText.includes('weitere') && 
                       (qText.includes('wünsche') || 
                        qText.includes('bedenken') || 
                        qText.includes('anmerkungen') ||
                        qText.includes('informationen'));

if (istTechnisch && !istOffeneFrage) {  // ← Ausnahme hinzugefügt
  console.log(`[INT-FILTER] Entfernt (technisches Detail): "${q.question.substring(0,60)}..."`);
  return false;
}
    
    // ALLES ANDERE IST ERLAUBT!
    // ✓ Wohnfläche, Nutzfläche, Gesamtfläche
    // ✓ Anzahl Geschosse/Etagen (allgemein)
    // ✓ Baujahr, Budget, Gebäudetyp
    // ✓ Bauweise bei Aufstockung
    // ✓ Konkrete Arbeiten/Projektumfang
    // ✓ Baustellenbedingungen
    
    return true;
  });
  
  if (vorherAnzahl !== questions.length) {
    console.log(`[INT-FILTER] ${vorherAnzahl - questions.length} gewerkespezifische Fragen aus Intake entfernt`);
  }
}

// Zähle Fragen vor Validierung
const beforeValidation = questions.length;

// Gewerke-Validierung NUR für Nicht-Intake Fragen
if (tradeCode !== 'INT') {
  questions = validateTradeQuestions(tradeCode, questions, projectContext);
  console.log(`[QUESTIONS] After trade validation: ${questions.length} questions (removed ${beforeValidation - questions.length})`);
} else {
  console.log(`[QUESTIONS] INT: Skipping trade validation for intake questions`);
}

// SPEZIAL-VALIDIERUNG bei Dachaufstockung
if (projectContext.istDachaufstockung) {
  if (tradeCode === 'ROH' && projectContext.aufstockungsBauweise === 'holzbau') {
    // Bei Holzbau sollte Rohbau minimal oder gar keine Fragen stellen
    questions = questions.filter(q => {
      const qText = q.question.toLowerCase();
      if (qText.includes('aufstockung') || qText.includes('wand') || qText.includes('mauerwerk')) {
        console.log(`[AUFSTOCKUNG] ROH-Frage entfernt bei Holzbau: ${q.question}`);
        return false;
      }
      return true;
    });
  }
  
  if (tradeCode === 'ZIMM' && projectContext.aufstockungsBauweise === 'massivbau') {
    // Bei Massivbau macht Zimmerer nur Dachstuhl
    questions = questions.filter(q => {
      const qText = q.question.toLowerCase();
      if (qText.includes('wand') || qText.includes('holzrahmen') || qText.includes('beplankung')) {
        console.log(`[AUFSTOCKUNG] ZIMM-Wandfrage entfernt bei Massivbau: ${q.question}`);
        return false;
      }
      return true;
    });
  }
}
    
// HIER: VERBESSERTER FILTER mit konkreten Werten
if (projectContext.answeredValues) {
  const afterAnswerFilter = questions.filter(q => {
    const qText = (q.question || '').toLowerCase();
    
    // Filtere bereits beantwortete Fragen
    if (projectContext.answeredValues.dimensions && 
        (qText.includes('abmessung') || qText.includes('maße'))) {
      console.log('[FILTER] Removed dimension question - already answered');
      return false;
    }
    
    if (projectContext.answeredValues.area && 
        qText.includes('fläche')) {
      console.log('[FILTER] Removed area question - already answered');
      return false;
    }
    
    // MATERIAL NUR FÜR INTAKE FILTERN
    if (projectContext.answeredValues.material && 
        qText.includes('material') && 
        tradeCode === 'INT') {  // <- NUR für Intake!
      console.log('[FILTER] Removed material question - already answered in intake');
      return false;
    }
    
    return true;
  });
  
  console.log(`[FILTER] Removed ${questions.length - afterAnswerFilter.length} answered questions`);
  questions = afterAnswerFilter;
}

// Zähle Fragen vor Duplikat-Filter
const beforeDuplicates = questions.length;

// Post-Processing Filter anwenden
console.log(`[DEBUG] tradeCode: "${tradeCode}", questions before duplicate filter: ${questions.length}`);
if (tradeCode !== 'INT') {
  questions = filterDuplicateQuestions(questions, allAnsweredInfo.fromIntake);
} else {
  console.log(`[QUESTIONS] INT: Skipping duplicate filter for intake questions`);
}
console.log(`[QUESTIONS] After duplicate filter: ${questions.length} questions (removed ${beforeDuplicates - questions.length})`);
console.log(`[DEBUG] Final question count: ${questions.length}`);

return Array.isArray(questions) ? questions : [];

// Entferne problematische Zeichen die Claude manchmal einfügt
cleanedResponse = cleanedResponse
  .replace(/[\u0000-\u001F\u007F-\u009F]/g, '') // Kontrolzeichen entfernen
  .replace(/\r\n/g, '\n')  // Windows line endings normalisieren
  .replace(/\\n/g, ' ')    // Escaped newlines durch Leerzeichen ersetzen
  .replace(/\\"/g, '"')    // Escaped quotes fixen
  .replace(/\\\\/g, '\\'); // Double backslashes fixen

// NEU: Zusätzliche Bereinigung - Entferne alles vor dem ersten [ und nach dem letzten ]
const arrayStart = cleanedResponse.indexOf('[');
const arrayEnd = cleanedResponse.lastIndexOf(']');

if (arrayStart !== -1 && arrayEnd !== -1 && arrayEnd > arrayStart) {
  cleanedResponse = cleanedResponse.substring(arrayStart, arrayEnd + 1);
} else {
  console.error('[QUESTIONS] No valid array brackets found in response');
  console.error('[QUESTIONS] Response snippet:', cleanedResponse.substring(0, 200));
  throw new Error('Invalid JSON structure - no array found');
}

// Entferne trailing commas (häufiger Claude-Fehler)
cleanedResponse = cleanedResponse
  .replace(/,(\s*[}\]])/g, '$1');  // Trailing commas entfernen

// Debug-Ausgabe
console.log(`[QUESTIONS] Raw response length: ${response.length}`);
console.log(`[QUESTIONS] Cleaned response starts with: ${cleanedResponse.substring(0, 100)}`);
    
try {
  questions = JSON.parse(cleanedResponse);
} catch (parseError) {
  console.error('[QUESTIONS] Parse error, attempting recovery:', parseError.message);
  console.error('[QUESTIONS] Failed response preview:', cleanedResponse.substring(0, 300));
  
  // Versuche das JSON zu reparieren
  try {
    // Entferne trailing commas und andere häufige JSON-Fehler
    let fixedResponse = cleanedResponse
      .replace(/,\s*}/g, '}')     // Entferne trailing commas vor }
      .replace(/,\s*\]/g, ']')     // Entferne trailing commas vor ]
      .replace(/}\s*{/g, '},{')   // Füge fehlende Kommas zwischen Objekten hinzu
      .replace(/"\s*\n\s*"/g, '","'); // Fixe fehlende Kommas zwischen Strings
    
    questions = JSON.parse(fixedResponse);
    console.log('[QUESTIONS] Recovery successful with fixed JSON');
  } catch (recoveryError) {
    console.error('[QUESTIONS] Recovery failed:', recoveryError);
    
    // Letzter Versuch: Extrahiere einzelne JSON-Objekte
    try {
      const objectMatches = cleanedResponse.match(/\{[^{}]*\}/g);
      if (objectMatches && objectMatches.length > 0) {
        questions = objectMatches.map(match => {
          try {
            return JSON.parse(match);
          } catch (e) {
            return null;
          }
        }).filter(q => q !== null);
        
        if (questions.length > 0) {
          console.log('[QUESTIONS] Recovered', questions.length, 'questions via object extraction');
        } else {
          throw new Error('No valid objects could be parsed');
        }
      } else {
        throw new Error('No JSON objects found');
      }
    } catch (finalError) {
      console.error('[QUESTIONS] Final recovery attempt failed:', finalError);
      throw new Error('Fehler bei der Fragengenerierung - bitte versuchen Sie es erneut');
    }
  }
}
    
    if (!Array.isArray(questions)) {
      console.error('[QUESTIONS] Response is not an array, using fallback');
      throw new Error('Fehler bei der Fragengenerierung - bitte versuchen Sie es erneut');
    }
    
    if (questions.length === 0) {
      console.error('[QUESTIONS] Empty questions array, using fallback');
      throw new Error('Fehler bei der Fragengenerierung - bitte versuchen Sie es erneut');
    }
    
    // NEU - füge multiSelect hinzu:
let processedQuestions = questions.slice(0, targetQuestionCount).map((q, idx) => ({
  id: q.id || `${tradeCode}-${String(idx + 1).padStart(2, '0')}`,
  category: q.category || 'Allgemein',
  question: q.question || q.text || q.q || `Frage ${idx + 1}`,
  explanation: q.explanation || q.hint || '',
  type: q.type || 'text',
  multiSelect: q.multiSelect || false,  // NEU: Mehrfachauswahl-Flag
  required: q.required !== undefined ? q.required : true,
  unit: q.unit || null,
  options: Array.isArray(q.options) ? q.options : null,
  defaultValue: q.defaultValue || null,
  validationRule: q.validationRule || null,
  tradeId,
  tradeName
}));
    
    console.log(`[QUESTIONS] Successfully generated ${processedQuestions.length} questions for ${tradeName}`);
    if (tradeCode === 'FEN') {
  console.log('[QUESTIONS] Ensuring ALL critical window questions...');
  
  // PFLICHT-CHECKS für Fenster
const hasMaßfrage = processedQuestions.some(q => 
  q.question.toLowerCase().includes('maße')
);

const hasMaterialFrage = processedQuestions.some(q => 
  q.question.toLowerCase().includes('material') || 
  q.question.toLowerCase().includes('rahmen')
);

const hasÖffnungsFrage = processedQuestions.some(q => 
  q.question.toLowerCase().includes('öffnung') || 
  q.question.toLowerCase().includes('dreh')
);

// NEU: Sicherheit und Verglasung
const hasSicherheitsFrage = processedQuestions.some(q => 
  q.question.toLowerCase().includes('sicherheit') || 
  q.question.toLowerCase().includes('einbruch') ||
  q.question.toLowerCase().includes('rc2') ||
  q.question.toLowerCase().includes('rc3')
);

const hasVerglasungsFrage = processedQuestions.some(q => 
  q.question.toLowerCase().includes('verglasung') || 
  q.question.toLowerCase().includes('2-fach') ||
  q.question.toLowerCase().includes('3-fach') ||
  q.question.toLowerCase().includes('u-wert')
);

// FÜGE FEHLENDE FRAGEN HINZU
let insertPos = 1;

if (!hasMaterialFrage) {
  processedQuestions.splice(insertPos++, 0, {
    id: 'FEN-MATERIAL',
    category: 'Material',
    question: 'Welches Rahmenmaterial wünschen Sie für die Fenster?',
    explanation: 'Das Material bestimmt bis zu 40% des Preises!',
    type: 'select',
    options: ['Kunststoff', 'Holz', 'Holz-Aluminium', 'Aluminium'],
    required: true,
    multiSelect: false,
    unit: null,
    tradeId: tradeId,
    tradeName: tradeName
  });
}

if (!hasMaßfrage) {
  processedQuestions.splice(insertPos++, 0, {
    id: 'FEN-MASSE',
    category: 'Abmessungen',
    question: 'Welche Maße haben die einzelnen Fenster? Bitte für jedes Fenster: Breite x Höhe in cm, Anzahl Flügel, Öffnungsart',
    explanation: 'Beispiel: "Fenster 1: 120x140cm, 2-flügelig, Dreh-Kipp" oder "3 Stück 80x100cm, 1-flügelig, Kipp"',
    type: 'text',
    required: true,
    multiSelect: false,
    unit: null,
    tradeId: tradeId,
    tradeName: tradeName
  });
}

// NEU: Sicherheitsanforderung
if (!hasSicherheitsFrage) {
  processedQuestions.splice(insertPos++, 0, {
    id: 'FEN-SICHERHEIT',
    category: 'Sicherheit',
    question: 'Welche Sicherheitsanforderungen haben Sie für die Fenster?',
    explanation: 'RC2 ist Standard für EG, RC3 für erhöhte Sicherheit. Beeinflusst den Preis um 15-45%',
    type: 'select',
    options: ['Keine besonderen Anforderungen', 'RC1 (Grundschutz)', 'RC2 (Standard Einbruchschutz)', 'RC2N (ohne Sicherheitsverglasung)', 'RC3 (Erhöhter Einbruchschutz)'],
    required: true,
    multiSelect: false,
    unit: null,
    tradeId: tradeId,
    tradeName: tradeName
  });
}

// NEU: Verglasung/Energetik
if (!hasVerglasungsFrage) {
  processedQuestions.splice(insertPos++, 0, {
    id: 'FEN-VERGLASUNG',
    category: 'Verglasung',
    question: 'Welche Verglasung wünschen Sie?',
    explanation: 'Moderne 3-fach Verglasung spart langfristig Heizkosten. Uw-Wert = Wärmedurchgang des gesamten Fensters',
    type: 'select',
    options: [
      '2-fach Verglasung (Uw ~1.3)', 
      '3-fach Verglasung Standard (Uw ~1.0)', 
      '3-fach Verglasung Premium (Uw ~0.8)', 
      '3-fach Passivhaus (Uw ~0.6-0.7)',
      '4-fach Verglasung (Uw ~0.5)'
    ],
    required: true,
    multiSelect: false,
    unit: null,
    tradeId: tradeId,
    tradeName: tradeName
  });
}

console.log('[QUESTIONS] Window questions verified - Material, Maße, Öffnung, Sicherheit, Verglasung checked');
}
    
// INTELLIGENTE GEWERKE-VALIDIERUNG basierend auf Kontext
processedQuestions = processedQuestions.map((q, idx) => {
  const qLower = q.question.toLowerCase();
  
  // Regel 1: Wenn ein anderes Gewerk explizit im Projekt ist, keine Fragen dazu
  const otherTradesInProject = projectContext.trades || [];
  
  // Prüfe ob Frage zu anderem Gewerk gehört
  const belongsToOtherTrade = otherTradesInProject.some(otherTrade => {
    if (otherTrade.code === tradeCode) return false; // Eigenes Gewerk ok
    
    // Mapping von Keywords zu Gewerken
    const tradeIndicators = {
      'FEN': ['fenster', 'verglasung', 'öffnungsart', 'rahmen', 'fensterbank'],
      'FASS': ['fassade', 'wdvs', 'dämmung außen', 'außenputz'],
      'DACH': ['dach', 'ziegel', 'dachrinne', 'dachfenster', 'first', 'traufe'],
      'SAN': ['sanitär', 'waschbecken', 'wc', 'dusche', 'abwasser'],
      'ELEKT': ['steckdose', 'schalter', 'kabel', 'verteiler', 'strom'],
      'HEI': ['heizung', 'heizkörper', 'thermostat', 'heizkessel']
    };
    
    const indicators = tradeIndicators[otherTrade.code] || [];
    return indicators.some(indicator => qLower.includes(indicator));
  });
  
  if (belongsToOtherTrade) {
    console.log(`[GEWERKE-INTELLIGENCE] Question belongs to other trade: "${q.question}"`);
    return null; // Markiere zum Entfernen
  }
  
  return q;
}).filter(q => q !== null);

if (tradeCode === 'FASS') {
  // Pflichtfrage 1: Fassadenfläche
  if (!extractedData?.quantities?.flaeche) {
    const hasAreaQuestion = processedQuestions.some(q => 
      q.question.toLowerCase().includes('fläche') || 
      q.question.toLowerCase().includes('m²')
    );
    
    if (!hasAreaQuestion) {
      processedQuestions.unshift({
        id: 'FASS-01',
        category: 'Mengenermittlung',
        question: 'Wie groß ist die zu dämmende Fassadenfläche in m²?',
        explanation: 'Bitte messen Sie alle Außenwandflächen, die gedämmt werden sollen (ohne Fenster/Türen)',
        type: 'number',
        required: true,
        unit: 'm²'
      });
    }
  }
  
  // Pflichtfrage 2: Dämmstoffstärke
  const hasDaemmstaerkeQuestion = processedQuestions.some(q => 
    q.question.toLowerCase().includes('dämmstärke') || 
    q.question.toLowerCase().includes('dämmstoffstärke') ||
    q.question.toLowerCase().includes('dicke') && q.question.toLowerCase().includes('dämm')
  );
  
  if (!hasDaemmstaerkeQuestion) {
    processedQuestions.splice(1, 0, {
      id: 'FASS-02',
      category: 'Dämmung',
      question: 'Welche Dämmstoffstärke ist geplant (in cm)?',
      explanation: 'Empfehlung für optimale Energieeffizienz: 14-16 cm. Mindestens 12 cm für EnEV-Anforderungen, 16-20 cm für KfW-Förderung.',
      type: 'select',
      options: ['12 cm', '14 cm', '16 cm (Empfehlung)', '18 cm', '20 cm', 'Unsicher - bitte beraten'],
      required: true,
      defaultValue: '16 cm (Empfehlung)'
    });
  }
}

if (tradeCode === 'PV') {
  // Pflichtfrage 1: Verfügbare Dachfläche
  const hasDachflaecheQuestion = processedQuestions.some(q => 
    q.question.toLowerCase().includes('dachfläche') || 
    (q.question.toLowerCase().includes('fläche') && q.question.toLowerCase().includes('dach'))
  );
  
  if (!hasDachflaecheQuestion) {
    processedQuestions.unshift({
      id: 'PV-01',
      category: 'Flächenermittlung',
      question: 'Wie groß ist die für PV belegbare Dachfläche in m²?',
      explanation: 'Nur unverschattete Süd-, Ost- oder Westflächen. Abzüglich Dachfenster, Schornsteine, Gauben.',
      type: 'number',
      required: true,
      unit: 'm²'
    });
  }
  
  // Pflichtfrage 2: Gewünschte Leistung
  const hasLeistungQuestion = processedQuestions.some(q => 
    q.question.toLowerCase().includes('kwp') || 
    q.question.toLowerCase().includes('kilowatt') ||
    q.question.toLowerCase().includes('leistung')
  );
  
  if (!hasLeistungQuestion) {
    processedQuestions.splice(1, 0, {
      id: 'PV-02',
      category: 'Anlagenleistung',
      question: 'Welche PV-Anlagenleistung wünschen Sie (in kWp)?',
      explanation: 'Faustregel: Pro kWp werden ca. 5-7 m² Dachfläche benötigt. Ein 4-Personen-Haushalt benötigt typisch 6-10 kWp.',
      type: 'select',
      options: ['4-6 kWp', '6-8 kWp', '8-10 kWp (Empfehlung)', '10-12 kWp', '12-15 kWp', 'Maximal möglich', 'Unsicher - bitte beraten'],
      required: true,
      defaultValue: '8-10 kWp (Empfehlung)'
    });
  }
}
    
if (tradeCode === 'GER') {
  // Sicherstellen dass Gerüstfläche erfragt wird
  const hasCorrectAreaQuestion = processedQuestions.some(q => 
    q.question.toLowerCase().includes('gerüstfläche') || 
    q.question.toLowerCase().includes('m²')
  );
  
  if (!hasCorrectAreaQuestion) {
    // Füge Pflichtfrage hinzu
    processedQuestions.unshift({
      id: 'GER-01',
      category: 'Mengenermittlung',
      question: 'Wie groß ist die benötigte Gerüstfläche in m²?',
      explanation: 'Berechnung: (Länge aller einzurüstenden Fassadenseiten) x (Höhe bis Arbeitsebene + 2m Überstand)',
      type: 'number',
      required: true,
      unit: 'm²',
      tradeId: tradeId,
      tradeName: tradeName
    });
  }
}   
    // VERBESSERTER FILTER: Entferne Duplikate basierend auf allen Informationsquellen
let filteredQuestions = processedQuestions;

// Erstelle Liste aller bereits bekannten Informationen
const knownInfo = [];

// Aus extrahierten Daten
if (extractedData) {
  if (extractedData.quantities?.fenster) {
    knownInfo.push('anzahl fenster', 'wie viele fenster', 'fensteranzahl');
  }
  if (extractedData.quantities?.tueren) {
    knownInfo.push('anzahl türen', 'wie viele türen', 'türenanzahl', 'haustür');
  }
  if (extractedData.quantities?.flaeche) {
    knownInfo.push('fläche', 'quadratmeter', 'qm', 'größe');
  }
  if (extractedData.quantities?.raeume) {
    knownInfo.push('anzahl zimmer', 'wie viele zimmer', 'räume');
  }
  if (extractedData.measures?.includes('WDVS Fassadendämmung')) {
    knownInfo.push('fassadendämmung', 'wdvs', 'dämmung fassade');
  }
  if (extractedData.measures?.includes('Fensteraustausch')) {
    knownInfo.push('fenster austauschen', 'fenster erneuern', 'neue fenster');
  }
  if (extractedData.measures?.includes('Badsanierung')) {
    knownInfo.push('bad sanierung', 'bad renovieren');
  }
}

// Aus Intake-Antworten
if (allAnsweredInfo?.fromIntake?.length > 0) {
  allAnsweredInfo.fromIntake.forEach(item => {
    const questionLower = item.question_text.toLowerCase();
    // Füge die komplette Frage als bekannt hinzu
    knownInfo.push(questionLower);
    // Extrahiere auch Schlüsselwörter
    if (questionLower.includes('baustrom')) knownInfo.push('strom', 'baustrom');
    if (questionLower.includes('bauwasser')) knownInfo.push('wasser', 'bauwasser');
    if (questionLower.includes('zufahrt')) knownInfo.push('zufahrt', 'zugang');
    if (questionLower.includes('gerüst')) knownInfo.push('gerüst', 'arbeitsgerüst');
  });
}

// Filtere Fragen
filteredQuestions = processedQuestions.filter(newQ => {
  const questionLower = (newQ.question || '').toLowerCase();
  
  // Prüfe ob Frage bereits beantwortet wurde
  const isDuplicate = knownInfo.some(known => {
    if (questionLower.includes(known)) {
      console.log(`[QUESTIONS] Filtered duplicate: "${newQ.question}" (matches: ${known})`);
      return true;
    }
    return false;
  });
  
  // UNIVERSELLE REGEL: Frage nur nach erwähnten Dingen
  if (!isIntake && extractedData) {
    // Bei Fenster-Gewerk: Wenn keine Türen erwähnt, keine Tür-Fragen
    if (tradeCode === 'FEN' && !extractedData.quantities?.tueren && 
        !projectContext.description?.toLowerCase().includes('tür')) {
      if (questionLower.includes('haustür') || questionLower.includes('eingangstür')) {
        console.log(`[QUESTIONS] Filtered: Tür-Frage obwohl keine Türen erwähnt`);
        return false;
      }
    }
    
    // Bei Boden-Gewerk: Wenn nur Parkett erwähnt, keine Fliesen-Fragen
    if (tradeCode === 'BOD' && projectContext.description) {
      const desc = projectContext.description.toLowerCase();
      if (desc.includes('parkett') && !desc.includes('fliesen')) {
        if (questionLower.includes('fliesen')) {
          console.log(`[QUESTIONS] Filtered: Fliesen-Frage obwohl nur Parkett erwähnt`);
          return false;
        }
      }
    }
  }
  
  // Gerüst-Filter für betroffene Gewerke
  if (['DACH', 'FASS', 'FEN'].includes(tradeCode)) {
    if (questionLower.includes('gerüst') || questionLower.includes('arbeitsgerüst')) {
      console.log(`[QUESTIONS] Filtered: Gerüst-Frage in ${tradeCode}`);
      return false;
    }
  }
  
  return !isDuplicate;
});

console.log(`[QUESTIONS] Filtered ${processedQuestions.length - filteredQuestions.length} duplicate/irrelevant questions`);

// INTELLIGENTER FILTER FÜR FENSTER-GEWERK
if (tradeCode === 'FEN') {
  const descLower = (projectContext.description || '').toLowerCase();
  const haustuerErwaehnt = descLower.includes('haustür') || 
                           descLower.includes('eingangstür') || 
                           descLower.includes('haustüre') ||
                           descLower.includes('hauseingangstür');
  
  if (!haustuerErwaehnt) {
    // NUR wenn NICHT erwähnt, dann filtern
    filteredQuestions = filteredQuestions.filter(q => {
      const qLower = q.question.toLowerCase();
      if (qLower.includes('haustür') || qLower.includes('eingangstür')) {
        console.log(`[FEN] Removed door question - not mentioned in project: "${q.question}"`);
        return false;
      }
      return true;
    });
  } else {
    // Wenn erwähnt, SICHERSTELLEN dass danach gefragt wird
    const hasDoorQuestion = filteredQuestions.some(q => 
      q.question.toLowerCase().includes('tür')
    );
    
    if (!hasDoorQuestion) {
      filteredQuestions.unshift({
        id: 'FEN-DOOR-01',
        category: 'Türen',
        question: 'Welche Art von Haustür wünschen Sie?',
        type: 'select',
        options: ['Kunststoff', 'Aluminium', 'Holz', 'Stahl'],
        required: true
      });
      console.log('[FEN] Added door question - was mentioned in project');
    }
  }
}
 
return filteredQuestions;   
    
 } catch (err) {
    console.error('[QUESTIONS] Generation failed:', err.message);
    console.error('[QUESTIONS] Error details:', err);
    if (err.responseSnippet) {
      console.error('[QUESTIONS] Response snippet:', err.responseSnippet);
    }
    throw err;
  }
}  

/**
 * Filtert duplizierte Fragen basierend auf Intake-Antworten
 */
function filterDuplicateQuestions(questions, intakeAnswers) {
  if (!intakeAnswers || intakeAnswers.length === 0) return questions;
  
  // Extrahiere bekannte Kalkulationsdaten
  const knownData = extractCalculationDataFromIntake(intakeAnswers);
  
  return questions.filter(q => {
    const qText = (q.question || q.text || '').toLowerCase();
    
    // ============ FLÄCHEN ============
    if (knownData.flaechen.badflaeche_gesamt && 
        qText.includes('bad') && 
        (qText.includes('wie groß') || qText.includes('fläche')) &&
        !qText.includes('wandfläche') && 
        !qText.includes('bodenfläche') &&
        !qText.includes('zu fliesen')) {
      console.log('[FILTER] Removed: Bad-Gesamtfläche bereits bekannt');
      return false;
    }
    
    if (knownData.flaechen.wohnflaeche_gesamt && 
        qText.includes('wohnfläche') &&
        !qText.includes('davon')) {
      console.log('[FILTER] Removed: Wohnfläche bereits bekannt');
      return false;
    }
    
    if (knownData.flaechen.dachflaeche && 
        qText.includes('dachfläche') &&
        !qText.includes('davon') &&
        !qText.includes('teilfläche')) {
      console.log('[FILTER] Removed: Dachfläche bereits bekannt');
      return false;
    }
    
    if (knownData.flaechen.fassadenflaeche && 
        qText.includes('fassade') && 
        qText.includes('fläche')) {
      console.log('[FILTER] Removed: Fassadenfläche bereits bekannt');
      return false;
    }
    
    // NEU: Bodenfläche (wichtig für Estrich, Bodenbelag, Fliesen)
    if (knownData.flaechen.bodenflaeche && 
        qText.includes('boden') && 
        (qText.includes('fläche') || qText.includes('wie groß')) &&
        !qText.includes('teilfläche') &&
        !qText.includes('welcher raum')) {
      console.log('[FILTER] Removed: Bodenfläche bereits bekannt');
      return false;
    }
    
    // Estrichfläche spezifisch
    if (knownData.flaechen.estrichflaeche && 
        qText.includes('estrich') && 
        qText.includes('fläche')) {
      console.log('[FILTER] Removed: Estrichfläche bereits bekannt');
      return false;
    }
    
    // ============ HÖHEN ============
    if (knownData.hoehen.raumhoehe && 
        (qText.includes('raumhöhe') || 
         qText.includes('deckenhöhe') || 
         (qText.includes('wie hoch') && qText.includes('raum')))) {
      console.log('[FILTER] Removed: Raumhöhe bereits bekannt');
      return false;
    }
    
    if (knownData.hoehen.wandstaerke && 
        (qText.includes('wandstärke') || 
         qText.includes('wanddicke') || 
         (qText.includes('dick') && qText.includes('wand')))) {
      console.log('[FILTER] Removed: Wandstärke bereits bekannt');
      return false;
    }
    
    if (knownData.hoehen.gebaeudehoehe && 
        (qText.includes('gebäudehöhe') || 
         qText.includes('firsthöhe') || 
         (qText.includes('hoch') && qText.includes('gebäude')))) {
      console.log('[FILTER] Removed: Gebäudehöhe bereits bekannt');
      return false;
    }
    
    // ============ LÄNGEN ============
    if (knownData.laengen.wandlaenge && 
        qText.includes('wand') && 
        (qText.includes('länge') || qText.includes('lang'))) {
      console.log('[FILTER] Removed: Wandlänge bereits bekannt');
      return false;
    }
    
    if (knownData.laengen.raumlaenge && 
        qText.includes('raum') && 
        (qText.includes('länge') || qText.includes('lang'))) {
      console.log('[FILTER] Removed: Raumlänge bereits bekannt');
      return false;
    }
    
    // ============ BREITEN ============
    if (knownData.breiten.raumbreite && 
        qText.includes('raum') && 
        (qText.includes('breite') || qText.includes('breit'))) {
      console.log('[FILTER] Removed: Raumbreite bereits bekannt');
      return false;
    }
    
    if (knownData.breiten.fensterbreite && 
        qText.includes('fenster') && 
        (qText.includes('breite') || qText.includes('breit')) &&
        !qText.includes('einzelne')) {
      console.log('[FILTER] Removed: Fensterbreite bereits bekannt');
      return false;
    }
    
    // ============ STÜCKZAHLEN - ERWEITERT ============
    
    // Fenster
    if (knownData.stueckzahlen.fenster && 
        ((qText.includes('wie viele') && qText.includes('fenster')) ||
         (qText.includes('anzahl') && qText.includes('fenster')))) {
      console.log('[FILTER] Removed: Fensteranzahl bereits bekannt');
      return false;
    }
    
    // Türen
    if (knownData.stueckzahlen.tueren && 
        ((qText.includes('wie viele') && qText.includes('tür')) ||
         (qText.includes('anzahl') && qText.includes('tür')))) {
      console.log('[FILTER] Removed: Türenanzahl bereits bekannt');
      return false;
    }
    
    // Räume
    if (knownData.stueckzahlen.raeume && 
        ((qText.includes('wie viele') && (qText.includes('raum') || qText.includes('räume') || qText.includes('zimmer'))) ||
         (qText.includes('anzahl') && (qText.includes('raum') || qText.includes('räume') || qText.includes('zimmer'))))) {
      console.log('[FILTER] Removed: Raumanzahl bereits bekannt');
      return false;
    }
    
    // Bäder
    if (knownData.stueckzahlen.baeder && 
        ((qText.includes('wie viele') && (qText.includes('bad') || qText.includes('bäder'))) ||
         (qText.includes('anzahl') && (qText.includes('bad') || qText.includes('bäder'))))) {
      console.log('[FILTER] Removed: Bäderanzahl bereits bekannt');
      return false;
    }
    
    // Geschosse/Etagen
    if (knownData.stueckzahlen.geschosse && 
        ((qText.includes('wie viele') && (qText.includes('geschoss') || qText.includes('etage') || qText.includes('stockwerk'))) ||
         (qText.includes('anzahl') && (qText.includes('geschoss') || qText.includes('etage') || qText.includes('stockwerk'))))) {
      console.log('[FILTER] Removed: Geschossanzahl bereits bekannt');
      return false;
    }
    
    // ZUSÄTZLICHE STÜCKZAHLEN die aus den Antworten extrahiert werden könnten:
    
    // Wände (Intake könnte fragen: "Wie viele Wände sollen verputzt werden?")
    if (knownData.stueckzahlen.waende && 
        ((qText.includes('wie viele') && qText.includes('wand')) ||
         (qText.includes('anzahl') && qText.includes('wand')))) {
      console.log('[FILTER] Removed: Wandanzahl bereits bekannt');
      return false;
    }
    
    // Heizkörper
    if (knownData.stueckzahlen.heizkoerper && 
        ((qText.includes('wie viele') && qText.includes('heizkörper')) ||
         (qText.includes('anzahl') && qText.includes('heizkörper')))) {
      console.log('[FILTER] Removed: Heizkörperanzahl bereits bekannt');
      return false;
    }
    
    // Steckdosen
    if (knownData.stueckzahlen.steckdosen && 
        ((qText.includes('wie viele') && qText.includes('steckdose')) ||
         (qText.includes('anzahl') && qText.includes('steckdose')))) {
      console.log('[FILTER] Removed: Steckdosenanzahl bereits bekannt');
      return false;
    }
    
    // Schalter
    if (knownData.stueckzahlen.schalter && 
        ((qText.includes('wie viele') && qText.includes('schalter')) ||
         (qText.includes('anzahl') && qText.includes('schalter')))) {
      console.log('[FILTER] Removed: Schalteranzahl bereits bekannt');
      return false;
    }
    
    // Dachfenster
    if (knownData.stueckzahlen.dachfenster && 
        ((qText.includes('wie viele') && qText.includes('dachfenster')) ||
         (qText.includes('anzahl') && qText.includes('dachfenster')))) {
      console.log('[FILTER] Removed: Dachfensteranzahl bereits bekannt');
      return false;
    }
    
    // NEU: Gauben
    if (knownData.stueckzahlen.gauben && 
        ((qText.includes('wie viele') && (qText.includes('gaube') || qText.includes('gauben'))) ||
         (qText.includes('anzahl') && (qText.includes('gaube') || qText.includes('gauben'))))) {
      console.log('[FILTER] Removed: Gaubenanzahl bereits bekannt');
      return false;
    }
    
    // ============ MATERIALIEN ============
// DEAKTIVIERT: Intake fragt nicht mehr nach Material-Details (wird dort gefiltert)
// Gewerke-Fragen MÜSSEN nach spezifischen Materialien fragen können
/*
if (knownData.materialien.wand && 
    qText.includes('wand') && 
    qText.includes('material') &&
    !qText.includes('oberfläche') &&
    !qText.includes('beschichtung')) {
  console.log('[FILTER] Removed: Wandmaterial bereits bekannt');
  return false;
}

if (knownData.materialien.boden && 
    qText.includes('boden') && 
    qText.includes('material') &&
    !qText.includes('neuer') &&
    !qText.includes('gewünscht')) {
  console.log('[FILTER] Removed: Bodenmaterial bereits bekannt');
  return false;
}

if (knownData.materialien.dach && 
    qText.includes('dach') && 
    qText.includes('material')) {
  console.log('[FILTER] Removed: Dachmaterial bereits bekannt');
  return false;
}
*/
    
    // ============ KOMBINIERTE MASSE (LxBxH) ============
    if ((knownData.laengen.bad && knownData.breiten.bad) &&
        qText.includes('bad') && 
        (qText.includes('maße') || qText.includes('abmessung'))) {
      console.log('[FILTER] Removed: Badmaße bereits bekannt');
      return false;
    }
    
    if ((knownData.laengen.raum && knownData.breiten.raum) &&
        qText.includes('raum') && 
        (qText.includes('maße') || qText.includes('abmessung')) &&
        !qText.includes('welcher raum') &&
        !qText.includes('einzelne')) {
      console.log('[FILTER] Removed: Raummaße bereits bekannt');
      return false;
    }
    
    // ============ VOLUMEN ============
    if (knownData.volumen && Object.keys(knownData.volumen).length > 0) {
      // Prüfe Volumen-bezogene Fragen
      if (qText.includes('kubikmeter') || qText.includes('m³') || qText.includes('volumen')) {
        const volumenKeys = Object.keys(knownData.volumen);
        for (const key of volumenKeys) {
          if (qText.includes(key)) {
            console.log(`[FILTER] Removed: ${key}-Volumen bereits bekannt`);
            return false;
          }
        }
      }
    }
    
    // Frage ist OK - wird beibehalten
    return true;
  });
}

/**
 * Validiert und filtert Fragen basierend auf Gewerke-Zuständigkeit
 * Berücksichtigt gemeinsame und exklusive Begriffe
 */
function validateTradeQuestions(tradeCode, questions, projectContext = {}) {
  // INTAKE-FRAGEN NIEMALS FILTERN!
  if (tradeCode === 'INT') {
    console.log('[VALIDATION] INT: Keine Filterung bei Intake-Fragen');
    return questions; // Alle Fragen durchlassen
  }  
  // GEMEINSAME Begriffe - mehrere Gewerke dürfen danach fragen
  const SHARED_KEYWORDS = {
    'bad': ['SAN', 'FLI', 'MAL', 'ELEKT', 'TRO'],  // Badezimmer betrifft viele
    'küche': ['TIS', 'FLI', 'ELEKT', 'SAN'],        // Küche betrifft viele
    'wand': ['ROH', 'FLI', 'MAL', 'TRO', 'ELEKT'],  // Wände betrifft viele
    'boden': ['FLI', 'BOD', 'ESTR', 'MAL'],         // Böden betrifft viele
    'decke': ['MAL', 'TRO', 'ROH', 'ELEKT'],        // Decken betrifft viele
    'gaube': ['ZIMM', 'DACH'],                      // Zimmerer baut Holzkonstruktion der Gaube, Dachdecker deckt sie ein
    'raum': ['MAL', 'TRO', 'BOD', 'FLI', 'ELEKT'],  // Räume betrifft viele
    'tür': ['TIS', 'MAL', 'TRO', 'FEN'],             // Türbereiche betrifft mehrere
    'fläche': ['FLI', 'MAL', 'BOD', 'FASS', 'ESTR'], // Flächen allgemein
    'material': ['ALLE'],                            // Material kann jedes Gewerk fragen
    'farbe': ['MAL', 'FASS', 'TIS', 'FEN'],         // Farben betrifft mehrere
    'montage': ['ALLE'],                             // Montage betrifft alle
    'demontage': ['ALLE'],                           // Demontage betrifft alle
    'estrich': ['ESTR', 'ABBR'],                     // Beide dürfen generell
    'heizestrich': ['ESTR', 'HEI'],                   // Beide relevant
    'estrich vorbereiten': ['BOD', 'FLI'],           // Beide bereiten vor
    'ausgleichsmasse': ['ESTR', 'BOD', 'FLI'],       // Alle drei
  };

  // NUR EXKLUSIVE Begriffe - nur DIESES Gewerk darf fragen
  const STRICTLY_EXCLUSIVE = {
    'ELEKT': ['schalter', 'leuchte', 'sicherung', 'verteiler', 'fi-schalter'],
    'HEI': ['thermostat', 'warmwasser', 'kessel', 'brenner', 'radiator'],
    'KLIMA': ['klima', 'luftwechsel', 'abluft', 'zuluft', 'klimaanlage', 'wärmerückgewinnung'],
    'TRO': ['rigips', 'trockenbau', 'ständerwerk', 'vorwand', 'gipskarton'],
    'FLI': ['verfugen', 'mosaik', 'naturstein', 'feinsteinzeug', 'bodenfliesen', 'wandfliesen'],
    'MAL': ['streichen', 'innenputz', 'tapezieren', 'verputzen', 'spachteln', 'lackieren', 'grundierung'],
    'BOD': ['parkett', 'laminat', 'vinyl', 'teppich', 'linoleum', 'kork', 'designboden'],
    'ROH': ['durchbruch', 'beton', 'maurerarbeiten', 'sturz', 'kalksandstein'],
    'SAN': ['wc', 'waschbecken', 'dusche', 'badewanne', 'abfluss', 'wasserhahn', 'armatur'],
    'FEN': ['verglasung', 'haustür', 'rolladen', 'jalousie', 'außentür', 'terrassentür', 'isolierglas'],
    'TIS': ['innentür', 'zarge', 'einbauschrank', 'wohnungseingangstür', 'arbeitsplatte'],
    'DACH': ['dachziegel', 'dachrinne', 'schneefang', 'gauben', 'eindeckung', 'dampfbremse', 'unterspannbahn'],
    'FASS': ['fassade', 'wdvs', 'außenputz', 'verblendung', 'klinker', 'fassadenfarbe'],
    'GER': ['gerüst', 'baugerüst', 'arbeitsgerüst', 'fassadengerüst', 'rollgerüst', 'dachgerüst'],
    'ZIMM': ['holzbau', 'dachstuhl', 'gaube', 'carport', 'holzkonstruktion', 'fachwerk'],
    'ESTR': ['fließestrich', 'zementestrich', 'anhydritestrich', 'trockenestrich', 'ausgleichsmasse'],
    'SCHL': ['geländer', 'metallbau', 'stahltreppe', 'schlosserarbeiten'],
    'AUSS': ['pflaster', 'einfahrt', 'außenanlage', 'randstein', 'gartenzaun', 'rasen'],
    'PV': ['solar', 'photovoltaik', 'solaranlage', 'wechselrichter', 'batterie', 'einspeisung'],
    'ABBR': ['abriss', 'abbruch', 'entkernung', 'rückbau']
  };

  const filteredQuestions = [];
  const blockedQuestions = [];

  for (const question of questions) {
    const questionText = (question.question || question.text || '').toLowerCase();
    let isValid = true;
    let blockReason = '';

    // Prüfe EXKLUSIVE Keywords anderer Gewerke
    for (const [code, keywords] of Object.entries(STRICTLY_EXCLUSIVE)) {
      if (code !== tradeCode) {
        for (const keyword of keywords) {
          if (questionText.includes(keyword)) {
            // Prüfe ob es nicht ein gemeinsamer Begriff ist
            const isShared = Object.entries(SHARED_KEYWORDS).some(([sharedWord, allowedTrades]) => 
              questionText.includes(sharedWord) && 
              (allowedTrades.includes(tradeCode) || allowedTrades.includes('ALLE'))
            );
            
            if (!isShared) {
              blockReason = `Exklusiv-Begriff "${keyword}" gehört nur zu ${code}`;
              isValid = false;
              break;
            }
          }
        }
      }
      if (!isValid) break;
    }

    // SPEZIALREGELN für bekannte Probleme
    if (isValid) {
      // Fenster darf nicht nach Dachfenstern fragen
      if (tradeCode === 'FEN' && questionText.includes('dachfenster')) {
        blockReason = 'Dachfenster gehören zu DACH, nicht zu FEN';
        isValid = false;
      }
      
      // Zimmerer darf nicht nach Dämmung fragen
      else if (tradeCode === 'ZIMM' && 
               (questionText.includes('dämmung') || 
                questionText.includes('dampfsperre') || 
                questionText.includes('isolierung'))) {
        blockReason = 'Dämmung gehört zu DACH, nicht zu ZIMM';
        isValid = false;
      }
      
      // Bodenleger darf nicht nach Fliesen fragen
      else if (tradeCode === 'BOD' && 
               (questionText.includes('fliese') || 
                questionText.includes('naturstein'))) {
        blockReason = 'Fliesen gehören zu FLI, nicht zu BOD';
        isValid = false;
      }
    }

    if (isValid) {
      filteredQuestions.push(question);
    } else {
      blockedQuestions.push({ question: questionText, reason: blockReason });
    }
  }

  // Logging nur wenn Fragen blockiert wurden
  if (blockedQuestions.length > 0) {
    console.log(`[VALIDATION] ${tradeCode}: ${blockedQuestions.length} Fragen blockiert`);
    blockedQuestions.forEach(b => {
      console.log(`  ❌ "${b.question.substring(0, 60)}..." → ${b.reason}`);
    });
  } else {
    console.log(`[VALIDATION] ${tradeCode}: Alle ${filteredQuestions.length} Fragen valide`);
  }

  return filteredQuestions;
}

/**
 * Generiert adaptive Folgefragen basierend auf Kontext-Antwort
 */
async function generateContextBasedQuestions(tradeId, projectId, contextAnswer, flags = {}) {
  const trade = await query('SELECT name, code FROM trades WHERE id = $1', [tradeId]);
  const project = await query('SELECT * FROM projects WHERE id = $1', [projectId]);
  
  if (trade.rows.length === 0 || project.rows.length === 0) {
    throw new Error('Trade or Project not found');
  }
  
  // Lade Intake-Kontext
  const intakeAnswers = await query(
    `SELECT q.text as question, a.answer_text as answer
     FROM answers a
     JOIN questions q ON q.project_id = a.project_id 
       AND q.trade_id = a.trade_id 
       AND q.question_id = a.question_id
     JOIN trades t ON t.id = a.trade_id
     WHERE a.project_id = $1 AND t.code = 'INT'`,
    [projectId]
  );
  
  // Bestimme Fragenanzahl basierend auf BESTEHENDER Komplexitätslogik
  const projectContext = {
    description: project.rows[0].description,
    category: project.rows[0].category,
    budget: project.rows[0].budget,
    intakeData: intakeAnswers.rows
  };
  
  const complexity = determineProjectComplexity(projectContext, intakeAnswers.rows);
  const intelligentCount = getIntelligentQuestionCount(trade.rows[0].code, projectContext, intakeAnswers.rows);
  
  // Lade das BESTEHENDE Prompt-Template für dieses Gewerk
  const questionPrompt = await getPromptForTrade(tradeId, 'questions');
  
  const systemPrompt = `Du bist ein Experte für ${trade.rows[0].name}.

╔══════════════════════════════════════════════════════════════════╗
║          FOLGEFRAGEN NACH KONTEXTANTWORT                          ║
╚══════════════════════════════════════════════════════════════════╝

DER NUTZER HAT BEREITS ANGEGEBEN:
"${contextAnswer}"

AUFGABE: Erstelle ${intelligentCount.count} DETAILLIERTE Folgefragen zu dieser Angabe.

KRITISCHE REGELN:
1. KEINE erneute Kontextfrage ("Was soll gemacht werden?")
2. NUR spezifische Detail-Fragen zu den vom Nutzer genannten Arbeiten
3. Komplexität: ${complexity}

PFLICHTFELDER FÜR JEDE FRAGE:
- "explanation": 15-20 Wörter - warum diese Info benötigt wird
  Beispiele:
  * "Benötigt für präzise Materialkalkulation und Arbeitsaufwand"
  * "Bestimmt Qualität und Preis der Ausführung erheblich"
  * "Wichtig für korrekte Mengenberechnung"

- "uploadHelpful": true/false - ob Datei-Upload sinnvoll ist
  true bei: Listen, Maßen, Plänen, Fotos zur Zustandsbewertung
  false bei: einfachen Ja/Nein-Fragen, Texteingaben

- "uploadHint": "Optional: ..." wenn uploadHelpful=true
  Format: "Optional: [Was kann hochgeladen werden]"
  Beispiele:
  * "Optional: Foto der Türöffnung für präzise Maßermittlung"
  * "Optional: Excel-Liste mit Fenstermaßen"
  * "Optional: Grundriss-PDF für Flächenberechnung"
  Wenn uploadHelpful=false → uploadHint=null

BEISPIEL FÜR KONTEXTANTWORT "${contextAnswer}":
${generateContextSpecificExample(contextAnswer, trade.rows[0].code)}

${questionPrompt ? `\nGEWERKE-SPEZIFISCHE REGELN:\n${questionPrompt.substring(0, 3000)}\n` : ''}

AUSGABE-FORMAT (NUR valides JSON-Array):
[
  {
    "id": "${trade.rows[0].code}-1",
    "question": "Konkrete, laienverständliche Frage",
    "explanation": "15-20 Wörter warum benötigt",
    "type": "text|number|select|multiselect",
    "required": true,
    "unit": "m²|m|Stk|null",
    "uploadHelpful": true,
    "uploadHint": "Optional: Beschreibung was hochgeladen werden kann",
    "options": ["Option 1", "Option 2"] // nur bei select/multiselect
  }
]

WICHTIG: 
- Erstelle EXAKT ${intelligentCount.count} Fragen
- JEDE Frage muss explanation UND uploadHelpful haben
- Antworte NUR mit dem JSON-Array, kein Text davor/danach`;

  try {
    const response = await llmWithPolicy('questions', [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: `Erstelle ${intelligentCount.count} detaillierte Folgefragen für: "${contextAnswer}"` }
    ], { 
      maxTokens: 10000, 
      temperature: 0.35,
      jsonMode: true
    });
    
    // Robustere Bereinigung
    let cleaned = response
      .replace(/```json\n?/gi, '')
      .replace(/```\n?/gi, '')
      .replace(/^json\s*\n?/i, '')
      .trim();
    
    // Entferne trailing commas
    cleaned = cleaned.replace(/,(\s*[}\]])/g, '$1');
    
    // Finde das JSON Array
    const startIdx = cleaned.indexOf('[');
    const endIdx = cleaned.lastIndexOf(']');
    
    if (startIdx !== -1 && endIdx !== -1 && startIdx < endIdx) {
      cleaned = cleaned.substring(startIdx, endIdx + 1);
    }
    
    let questions;
    try {
      questions = JSON.parse(cleaned);
    } catch (parseError) {
      console.error('[CONTEXT] Parse failed:', parseError.message);
      console.error('[CONTEXT] First 500 chars:', cleaned.substring(0, 500));
      
      // Retry mit strikterem Prompt
      console.log('[CONTEXT] Retrying with stricter prompt...');
      
      const retryResponse = await llmWithPolicy('questions', [
  { 
    role: 'system', 
    content: 'KRITISCH: Erstelle NUR ein valides JSON-Array!\nKeine Markdown-Blöcke, keine Erklärungen, NUR das Array.\nBeginne direkt mit [ und ende mit ]'
  },
        { role: 'user', content: systemPrompt }
      ], { 
        maxTokens: 10000, 
        temperature: 0.3,  
        jsonMode: true
      });
      
      const retryCleaned = retryResponse
        .replace(/```json\n?/gi, '')
        .replace(/```\n?/gi, '')
        .trim();
      
      questions = JSON.parse(retryCleaned);
    }
    
    if (!Array.isArray(questions) || questions.length === 0) {
      throw new Error('Keine Fragen generiert');
    }
    
    // Füge trade info zu jeder Frage hinzu
    questions = questions.map((q, idx) => ({
      ...q,
      id: q.id || `${trade.rows[0].code}-${idx + 1}`,
      tradeId: parseInt(tradeId),
      trade_id: parseInt(tradeId),
      tradeName: trade.rows[0].name,
      trade_name: trade.rows[0].name,
      trade_code: trade.rows[0].code,
      uploadHelpful: q.uploadHelpful !== undefined ? q.uploadHelpful : false,
      uploadHint: q.uploadHint || null
    }));
    
    console.log(`[CONTEXT] Generated ${questions.length} questions for ${trade.rows[0].code}`);
    
    // Verwende BESTEHENDE Validierungslogik
    questions = validateTradeQuestions(trade.rows[0].code, questions, projectContext);
    questions = filterDuplicateQuestions(questions, intakeAnswers.rows);
    
    console.log(`[CONTEXT] After validation: ${questions.length} questions`);
    
    return Array.isArray(questions) ? questions : [];
    
  } catch (err) {
    console.error('[CONTEXT] Complete failure:', err);
    throw err;
  }
}

// Hilfsfunktion für kontextspezifische Beispiele
function generateContextSpecificExample(contextAnswer, tradeCode) {
  const lower = contextAnswer.toLowerCase();
  
  if (lower.includes('tür')) {
    return `RICHTIGE Folgefragen:
- "Welche Maße hat die Türöffnung (Breite x Höhe in cm)?"
  explanation: "Benötigt für Bestellung der passenden Tür und Zarge"
  uploadHelpful: true
  uploadHint: "Optional: Foto der Türöffnung für präzise Maßermittlung"

- "Welche Ausführung wünschen Sie (CPL, Echtholz, lackiert)?"
  explanation: "Beeinflusst Preis und Haltbarkeit der Tür erheblich"
  uploadHelpful: false
  uploadHint: null

❌ FALSCH: "Welche Tischlerarbeiten sollen durchgeführt werden?" (= Kontextfrage!)`;
  }
  
  if (lower.includes('fenster')) {
    return `RICHTIGE Folgefragen:
- "Wie viele Fenster sollen insgesamt ausgetauscht werden?"
  explanation: "Bestimmt Gesamtaufwand und Materialbedarf"
  uploadHelpful: false
  
- "Welche Maße haben die einzelnen Fenster (Breite x Höhe)?"
  explanation: "Jedes Fenster muss einzeln kalkuliert werden"
  uploadHelpful: true
  uploadHint: "Optional: Excel-Liste mit Fenstermaßen oder Fotos"

FALSCH: "Sollen auch Türen getauscht werden?" (nicht genannt!)`;
  }
  
  if (lower.includes('streichen') || lower.includes('maler')) {
    return `RICHTIGE Folgefragen:
- "Welche Fläche soll gestrichen werden (in m²)?"
  explanation: "Benötigt für Materialkalkulation und Zeitplanung"
  uploadHelpful: true
  uploadHint: "Optional: Grundriss-PDF für Flächenberechnung"

- "Wie ist der aktuelle Zustand der Wände?"
  explanation: "Bestimmt ob Spachtel- oder Grundierarbeiten nötig sind"
  uploadHelpful: true
  uploadHint: "Optional: Fotos der zu streichenden Wände"`;
  }
  
  return `Erstelle spezifische Fragen zu "${contextAnswer}".
Keine allgemeinen Fragen, nur Details zu den genannten Arbeiten.`;
}

/**
 * Parst Fenster-Maßangaben aus Nutzer-Antwort
 */
function parseFensterMaße(antwortText) {
  const fensterTypen = [];
  
  // Pattern: "120x140" oder "120 x 140" oder "3 Stück 120x140"
  const matches = antwortText.matchAll(/(\d+)?\s*(?:stück|stk|x)?\s*(\d+)\s*x\s*(\d+)/gi);
  
  for (const match of matches) {
    const anzahl = match[1] ? parseInt(match[1]) : 1;
    const breite = parseInt(match[2]);
    const höhe = parseInt(match[3]);
    
    if (breite && höhe) {
      fensterTypen.push({
        anzahl,
        breite,
        höhe,
        beschreibung: `${breite} x ${höhe} cm`
      });
    }
  }
  
  // Fallback wenn keine Maße gefunden
  if (fensterTypen.length === 0) {
    console.log('[LV] Keine Fenstermaße in Antwort gefunden:', antwortText);
  }
  
  return fensterTypen;
}
async function generateDetailedLV(projectId, tradeId) {
  const project = (await query('SELECT * FROM projects WHERE id=$1', [projectId])).rows[0];
  if (!project) throw new Error('Project not found');
  
  const trade = (await query('SELECT id, name, code FROM trades WHERE id=$1', [tradeId])).rows[0];
  if (!trade) throw new Error('Trade not found');
  
  const tradeCode = trade.code;

  // NEU: Lade Projekt-Komplexität aus Metadata
  const projectMetadata = project.metadata ? 
    (typeof project.metadata === 'string' ? JSON.parse(project.metadata) : project.metadata) 
    : {};
  
  const projectComplexity = projectMetadata.complexity?.level || 
    determineProjectComplexity(project, []);
  
  console.log(`[LV] Project complexity for ${trade.code}: ${projectComplexity}`);
  
  // Lade alle relevanten Antworten
  const intTrade = (await query(`SELECT id FROM trades WHERE code='INT' LIMIT 1`)).rows[0];
  const intakeAnswers = intTrade
  ? (await query(
      `SELECT 
         q.text as question, 
         q.question_id, 
         COALESCE(a.llm_context, a.answer_text) as answer,  
         a.assumption
       FROM answers a
       JOIN questions q ON q.project_id = a.project_id 
         AND q.trade_id = a.trade_id 
         AND q.question_id = a.question_id
       WHERE a.project_id=$1 AND a.trade_id=$2
         AND (a.answer_text IS NOT NULL OR a.llm_context IS NOT NULL)  
       ORDER BY q.question_id`,
      [projectId, intTrade.id]
    )).rows
  : [];

  const intakeUploadData = intTrade ? await query(
  `SELECT 
    question_id,
    file_name,
    file_type,
    document_type,
    confidence,
    analysis_result
   FROM file_uploads
   WHERE project_id = $1 AND trade_id = $2`,
  [projectId, intTrade.id]
) : { rows: [] };

const enrichedIntakeAnswers = intakeAnswers.map(answer => {
  const upload = intakeUploadData.rows.find(u => u.question_id === answer.question_id);
  
  if (upload) {
    return {
      ...answer,
      hasUpload: true,
      uploadFileName: upload.file_name,
      uploadType: upload.document_type || upload.file_type
    };
  }
  
  return answer;
});
  
  const tradeAnswers = (await query(
    `SELECT 
       q.text as question, 
       q.question_id, 
       CASE 
         WHEN q.text ILIKE '%m²%' OR q.text ILIKE '%quadratmeter%' THEN 'm²'
         WHEN q.text ILIKE '%meter%' OR q.text ILIKE '% m %' THEN 'm'
         WHEN q.text ILIKE '%stück%' OR q.text ILIKE '%anzahl%' THEN 'Stk'
         WHEN q.text ILIKE '%stunde%' THEN 'h'
         WHEN q.text ILIKE '%kilogramm%' OR q.text ILIKE '% kg %' THEN 'kg'
         ELSE NULL
       END as unit,
       COALESCE(a.llm_context, a.answer_text) as answer, 
       a.assumption
     FROM answers a
     JOIN questions q ON q.project_id = a.project_id 
       AND q.trade_id = a.trade_id 
       AND q.question_id = a.question_id
     WHERE a.project_id=$1 AND a.trade_id=$2
       AND (a.answer_text IS NOT NULL OR a.llm_context IS NOT NULL)
     ORDER BY q.question_id`,
    [projectId, tradeId]
  )).rows;

console.log(`[LV-DEBUG] Loaded ${tradeAnswers.length} answers from database for ${trade.code}`);
if (tradeAnswers.length > 0) {
  console.log(`[LV-DEBUG] First 3 answers:`, tradeAnswers.slice(0, 3).map(a => ({
    question_id: a.question_id,
    answer: a.answer ? a.answer.substring(0, 50) : 'null'
  })));
}
  
// KONTEXT-ANTWORT FÜR MANUELL/ZUSÄTZLICH HINZUGEFÜGTE GEWERKE LADEN
let manualTradeContext = '';
let contextAnswer = null;

if (projectMetadata.isManual || projectMetadata.isAiRecommended) {
  // Suche nach Kontextantwort (ID enthält CONTEXT)
  contextAnswer = tradeAnswers.find(a => 
    a.question_id && a.question_id.includes('CONTEXT')
  );
  
  if (contextAnswer && contextAnswer.answer) {
    const userScope = contextAnswer.answer.trim();
    
    manualTradeContext = `
╔══════════════════════════════════════════════════════════════════╗
║  MANUELL/ZUSÄTZLICH HINZUGEFÜGTES GEWERK - STRENGE EINSCHRÄNKUNG ║
╚══════════════════════════════════════════════════════════════════╝

DER NUTZER HAT EXPLIZIT NUR FOLGENDES GEWÜNSCHT:
"${userScope}"

KRITISCHE REGEL - NUR ERSTELLEN WAS ERWÄHNT WURDE:
Diese Antwort definiert den KOMPLETTEN Projektumfang für ${trade.name}.

ABSOLUT VERBOTEN:
- Positionen die NICHT in dieser Beschreibung vorkommen
- "Typische" Arbeiten dieses Gewerks hinzufügen
- "Üblicherweise gehört auch..." - NEIN, nur das Genannte!
- Ergänzungen ohne explizite Erwähnung
- "Sinnvolle Ergänzungen" - NEIN!
- Standard-Annahmen über weitere Leistungen

BEISPIELE WAS VERBOTEN IST:
- Nutzer sagt "Badezimmertür": KEINE Möbel, Spiegel, Schränke
- Nutzer sagt "Fenster tauschen": KEINE Fensterbänke ohne Erwähnung
- Nutzer sagt "Parkett verlegen": KEINE Sockelleisten ohne Erwähnung
- Nutzer sagt "Wand verputzen": KEINE Malerarbeiten ohne Erwähnung

NUR ERLAUBT:
✓ Explizit genannte Arbeiten/Objekte
✓ Zwingend notwendige Nebenleistungen zu diesen Arbeiten:
  - Demontage/Entsorgung von Altmaterial (wenn Austausch)
  - Kleinmaterial und Befestigung (für die genannten Arbeiten)
  - Anfahrt und Koordination
  - Vorbereitung/Nachbereitung (für die genannten Arbeiten)
✓ Bei Unsicherheit: WENIGER ist besser als zu viel

VALIDIERUNGS-CHECK VOR JEDER POSITION:
1. Wurde dieses Element/diese Arbeit explizit genannt? → JA = erstellen
2. Ist es eine zwingende Nebenleistung zu Genanntem? → JA = erstellen  
3. Sonst → NICHT ERSTELLEN!

KONKRETE BEISPIELE FÜR DIESEN FALL:
Nutzer-Angabe: "${userScope}"

${generateScopeExamples(userScope, trade.code)}

WENN DU UNSICHER BIST OB EINE POSITION PASST → LASS SIE WEG!
Lieber 3 korrekte Positionen als 10 mit falschen Annahmen.
`;
    
    console.log(`[LV] Manual/Additional trade context loaded for ${trade.code}:`);
    console.log(`[LV] User scope: "${userScope}"`);
    console.log(`[LV] Context validation will be applied in post-processing`);
    
  } else {
    // KRITISCH: Manuelles Gewerk aber keine Kontextantwort!
    console.error(`[LV] CRITICAL: Manual/Additional trade ${trade.code} WITHOUT context answer!`);
    manualTradeContext = `
╔══════════════════════════════════════════════════════════════════╗
║  ⚠️ KRITISCH: MANUELLES GEWERK OHNE KONTEXTANTWORT              ║
╚══════════════════════════════════════════════════════════════════╝

NOTFALL-MODUS - MINIMALE POSITIONSERSTELLUNG:

Da keine Kontextantwort vorliegt, erstelle NUR:
- Maximal 3-5 absolute BASIS-Positionen
- NUR was 100% zum Gewerk ${trade.name} gehört
- KEINE spekulativen Annahmen
- KEINE "typischen" Ergänzungen

Bei fehlendem Kontext: Besser zu wenig als zu viel!
`;
  }
}

// Hilfsfunktion für Scope-Beispiele
function generateScopeExamples(userScope, tradeCode) {
  const scopeLower = userScope.toLowerCase();
  
  // Extrahiere Hauptobjekte
  const examples = [];
  
  if (scopeLower.includes('tür')) {
    examples.push('ERSTELLEN: Demontage Alttür, Lieferung+Montage neue Tür, Zarge, Türdrücker');
    examples.push('NICHT: Fensterbank, Spiegel, Möbel (nicht genannt!)');
  }
  if (scopeLower.includes('parkett') || scopeLower.includes('laminat') || scopeLower.includes('boden')) {
    examples.push('ERSTELLEN: Untergrundvorbereitung, Lieferung+Verlegung Bodenbelag');
    examples.push('NICHT: Sockelleisten, Türschwellen (außer explizit genannt)');
  }
  if (scopeLower.includes('möbel') || scopeLower.includes('schrank') || scopeLower.includes('einbau')) {
    examples.push('ERSTELLEN: Die explizit genannten Möbelstücke');
    examples.push('NICHT: Weitere Möbel "die üblicherweise dazu gehören"');
  }
  
  // FEN - Fensterarbeiten
  if (scopeLower.includes('fenster')) {
    examples.push('ERSTELLEN: Demontage Altfenster, Lieferung+Montage neue Fenster');
    examples.push('NICHT: Rollläden, Fensterbänke, Außenfensterbank (außer explizit genannt)');
  }
  
  // SAN - Sanitär
  if (scopeLower.includes('bad') || scopeLower.includes('sanitär')) {
    examples.push('ERSTELLEN: Die explizit genannten Sanitärobjekte');
    examples.push('NICHT: Komplett-Bad wenn nur "WC erneuern" gesagt wurde');
  }
  if (scopeLower.includes('wc') || scopeLower.includes('toilette')) {
    examples.push('ERSTELLEN: WC-Demontage, neues WC, Anschluss, Spülkasten');
    examples.push('NICHT: Waschbecken, Dusche, Armaturen (nicht genannt!)');
  }
  if (scopeLower.includes('waschbecken') || scopeLower.includes('waschtisch')) {
    examples.push('ERSTELLEN: Waschbecken, Armatur, Siphon, Anschluss');
    examples.push('NICHT: WC, Dusche, Badmöbel (nicht genannt!)');
  }
  if (scopeLower.includes('dusche')) {
    examples.push('ERSTELLEN: Duschwanne/bodengleich, Armatur, Ablauf, Anschlüsse');
    examples.push('NICHT: Badewanne, WC, Komplettbad (nicht genannt!)');
  }
  
  // ELEKT - Elektro
  if (scopeLower.includes('steckdose')) {
    examples.push('ERSTELLEN: Neue Steckdosen, Unterputzdosen, Leitungen, Anschluss');
    examples.push('NICHT: Beleuchtung, Schalter, Verteiler (außer genannt)');
  }
  if (scopeLower.includes('licht') || scopeLower.includes('lampe') || scopeLower.includes('leuchte')) {
    examples.push('ERSTELLEN: Lichtauslässe, Schalter, Leitungen');
    examples.push('NICHT: Steckdosen, Verteiler, Smart Home (außer genannt)');
  }
  if (scopeLower.includes('verteiler') || scopeLower.includes('sicherung')) {
    examples.push('ERSTELLEN: Verteiler, Sicherungen, FI-Schalter');
    examples.push('NICHT: Rauminstallation, Leuchten (außer genannt)');
  }
  
  // MAL - Malerarbeiten
  if (scopeLower.includes('streichen') || scopeLower.includes('anstrich')) {
    examples.push('ERSTELLEN: Untergrundvorbereitung, Grundierung, Anstrich der genannten Flächen');
    examples.push('NICHT: Tapezieren, Spachteln ganzer Räume (außer genannt)');
  }
  if (scopeLower.includes('tapete') || scopeLower.includes('tapezieren')) {
    examples.push('ERSTELLEN: Alte Tapete entfernen, Untergrund, neue Tapete');
    examples.push('NICHT: Anstrich, Stuck, Deckengestaltung (außer genannt)');
  }
  if (scopeLower.includes('wand') && !scopeLower.includes('alle')) {
    examples.push('ERSTELLEN: NUR die genannte(n) Wand/Wände');
    examples.push('NICHT: Automatisch alle Wände im Raum');
  }
  
  // FLI - Fliesenarbeiten
  if (scopeLower.includes('fliese')) {
    examples.push('ERSTELLEN: Alte Fliesen entfernen, Untergrund, neue Fliesen der genannten Bereiche');
    examples.push('NICHT: Komplettes Bad wenn nur "Duschbereich" genannt');
  }
  if (scopeLower.includes('dusch') && scopeLower.includes('fliese')) {
    examples.push('ERSTELLEN: Abdichtung, Fliesen NUR im Duschbereich');
    examples.push('NICHT: Bodenfliesen, Wandfliesen Rest-Bad (außer genannt)');
  }
  
  // HEI - Heizung
  if (scopeLower.includes('heizkörper')) {
    examples.push('ERSTELLEN: Alte Heizkörper ab, neue Heizkörper, Anschluss');
    examples.push('NICHT: Heizkessel, Rohrleitungen, Thermostate (außer genannt)');
  }
  if (scopeLower.includes('heizung') && scopeLower.includes('tausch')) {
    examples.push('ERSTELLEN: Heizkessel Demontage, neuer Kessel, Anschluss');
    examples.push('NICHT: Alle Heizkörper, Fußbodenheizung (außer genannt)');
  }
  
  // DACH - Dacharbeiten
  if (scopeLower.includes('dach') && !scopeLower.includes('fenster')) {
    examples.push('ERSTELLEN: Die genannten Dacharbeiten (Eindeckung/Dämmung/etc.)');
    examples.push('NICHT: Dachfenster, Gauben, Dachrinnen (außer genannt)');
  }
  if (scopeLower.includes('dachfenster')) {
    examples.push('ERSTELLEN: Dachfenster Einbau, Eindeckrahmen, Anschluss');
    examples.push('NICHT: Dacheindeckung, Dämmung (außer genannt)');
  }
  
  // FASS - Fassade
  if (scopeLower.includes('fassade') || scopeLower.includes('dämmung')) {
    examples.push('ERSTELLEN: WDVS/Dämmung der genannten Flächen, Putz, Anstrich');
    examples.push('NICHT: Alle Fassaden wenn nur "Südseite" genannt');
  }
  if (scopeLower.includes('sockel')) {
    examples.push('ERSTELLEN: Sockeldämmung, Sockelputz der genannten Bereiche');
    examples.push('NICHT: Komplette Fassadendämmung (außer genannt)');
  }
  
  // TRO - Trockenbau
  if (scopeLower.includes('wand') || scopeLower.includes('rigips')) {
    examples.push('ERSTELLEN: Trockenbau-Wand wie beschrieben, Ständerwerk, Beplankung');
    examples.push('NICHT: Deckenabhängung, weitere Wände (außer genannt)');
  }
  if (scopeLower.includes('decke') || scopeLower.includes('abhäng')) {
    examples.push('✓ ERSTELLEN: Deckenabhängung wie beschrieben, Unterkonstruktion, Beplankung');
    examples.push('❌ NICHT: Wände, Vorwandinstallation (außer genannt)');
  }
  
  // GER - Gerüst
  if (scopeLower.includes('gerüst')) {
    examples.push('ERSTELLEN: Gerüst für die genannten Fassadenseiten/Bereiche');
    examples.push('NICHT: Gerüst um gesamtes Haus wenn nur "Südseite" genannt');
  }
  
  // ROH - Rohbau
  if (scopeLower.includes('durchbruch')) {
    examples.push('ERSTELLEN: Die genannten Durchbrüche, Sturz, Statik');
    examples.push('NICHT: Weitere Durchbrüche, Mauerwerk (außer genannt)');
  }
  if (scopeLower.includes('wand') && scopeLower.includes('neu')) {
    examples.push('ERSTELLEN: Neue Wand wie beschrieben, Mauerwerk, Mörtel');
    examples.push('NICHT: Verputzen, Estrich, weitere Wände (außer genannt)');
  }
  
  // SCHL - Schlosserarbeiten
  if (scopeLower.includes('geländer')) {
    examples.push('ERSTELLEN: Geländer wie beschrieben, Material, Montage');
    examples.push('NICHT: Treppenrenovierung, weitere Geländer (außer genannt)');
  }
  
  // BOD - Bodenbeläge
  if (scopeLower.includes('vinyl') || scopeLower.includes('designboden')) {
    examples.push('ERSTELLEN: Untergrund, Vinyl/Designboden der genannten Räume');
    examples.push('NICHT: Sockelleisten, weitere Räume (außer genannt)');
  }
  
  // Fallback wenn keine spezifischen Keywords
  if (examples.length === 0) {
    examples.push('ERSTELLEN: Nur was in der Beschreibung vorkommt');
    examples.push('NICHT: Standard-Annahmen über weitere Arbeiten');
    examples.push(`Für ${tradeCode}: Prüfe JEDE Position ob sie explizit genannt wurde`);
  }
  
  return examples.join('\n');
}
  
// ═══════════════════════════════════════════════════════════════
// LADE UPLOAD-DATEN
// ═══════════════════════════════════════════════════════════════

console.log('[LV] Loading upload data...');

const uploadData = await query(
  `SELECT 
    question_id,
    file_name,
    file_type,
    document_type,
    confidence,
    analysis_result,
    extracted_data
   FROM file_uploads
   WHERE project_id = $1 AND trade_id = $2
   ORDER BY created_at DESC`,
  [projectId, tradeId]
);

console.log(`[LV] Found ${uploadData.rows.length} uploaded files`);

// Reichere Antworten mit Upload-Daten an
const enrichedAnswers = tradeAnswers.map(answer => {
  const upload = uploadData.rows.find(u => u.question_id === answer.question_id);
  
  if (upload) {
    // Parse JSON fields
    let analysisResult = null;
    let extractedData = null;
    
    try {
      analysisResult = typeof upload.analysis_result === 'string' 
        ? JSON.parse(upload.analysis_result) 
        : upload.analysis_result;
    } catch (e) {
      console.warn(`[LV] Could not parse analysis_result for question ${answer.question_id}`);
    }
    
    try {
      extractedData = typeof upload.extracted_data === 'string' 
        ? JSON.parse(upload.extracted_data) 
        : upload.extracted_data;
    } catch (e) {
      // Kein Problem wenn extracted_data nicht existiert
    }
    
    return {
      ...answer,
      hasUpload: true,
      uploadMetadata: {
        fileName: upload.file_name,
        fileType: upload.file_type,
        documentType: upload.document_type,
        confidence: parseFloat(upload.confidence) || 0.7
      },
      extractedAnswer: analysisResult?.answer || null,
      structuredData: extractedData || null
    };
  }
  
  return {
    ...answer,
    hasUpload: false
  };
});

console.log(`[LV-DEBUG] Created ${enrichedAnswers.length} enriched answers from ${tradeAnswers.length} trade answers`);
console.log(`[LV-DEBUG] Question IDs in enrichedAnswers:`, enrichedAnswers.map(a => a.question_id).sort());
  
const uploadCount = enrichedAnswers.filter(a => a.hasUpload).length;
console.log(`[LV] Enriched ${uploadCount} answers with upload data`);

// Debug: Prüfe ob wichtige Antworten vorhanden sind
const materialAnswer = enrichedAnswers.find(a => a.question_id === 'FEN-3');
const fensterBankInnen = enrichedAnswers.find(a => a.question_id === 'FEN-17');
const leibungAnswer = enrichedAnswers.find(a => a.question_id === 'FEN-23');

console.log('[LV-DEBUG] Critical answers check:');
console.log('  Material (FEN-3):', materialAnswer ? materialAnswer.answer : 'MISSING!');
console.log('  Fensterbänke innen (FEN-17):', fensterBankInnen ? fensterBankInnen.answer : 'MISSING!');
console.log('  Leibungsverputz (FEN-23):', leibungAnswer ? leibungAnswer.answer : 'MISSING!');
  
  // Berechne Fragenanzahl
const answeredQuestionCount = enrichedAnswers.length;

// NEU: Erweiterte Orientierungswerte mit Projekt-Context (NUR EINMAL!)
const orientation = getPositionOrientation(trade.code, answeredQuestionCount, {
    ...project,
    complexity: projectComplexity,
    description: project.description
});

// Override bei MITTEL, HOCH und SEHR_HOCH
if (projectComplexity === 'SEHR_HOCH' || projectComplexity === 'HOCH' || projectComplexity === 'MITTEL') {
  const MINIMUM_POSITIONS_BY_COMPLEXITY = {
    'SEHR_HOCH': 18,
    'HOCH': 15,
    'MITTEL': 12,
    'EINFACH': 8,
    'INTAKE': 0
  };
  
  const tradeComplexity = TRADE_COMPLEXITY[trade.code]?.complexity || 'MITTEL';
  const absoluteMinimum = MINIMUM_POSITIONS_BY_COMPLEXITY[tradeComplexity];
  
  if (orientation.min < absoluteMinimum) {
    orientation.min = absoluteMinimum;
    orientation.max = Math.max(absoluteMinimum + 10, orientation.max);
    console.log(`[LV] OVERRIDE for ${projectComplexity} project: ${trade.code} minimum positions: ${absoluteMinimum}`);
  }
} else {
  // Nur bei NIEDRIG und EINFACH: Keine Overrides
  console.log(`[LV] ${projectComplexity} project - using orientation values without override`);
}

console.log(`[LV] Final orientation for ${trade.code}: ${orientation.min}-${orientation.max} positions from ${answeredQuestionCount} questions`);

  // Nach Zeile ~1300, vor der LV-Generierung
if (projectMetadata.isManual || projectMetadata.isAiRecommended) {
  console.log(`[LV] Verstärkte Validierung für ${trade.code} - Gewerk ist manuell/AI-empfohlen`);
  
  // Sicherstellen dass ALLE bestehenden Regeln angewendet werden
  // Verwende die GLEICHEN Orientierungswerte wie bei erforderlichen Gewerken
  const enforcedOrientation = getPositionOrientation(trade.code, answeredQuestionCount, {
    ...project,
    complexity: projectComplexity,
    description: project.description
  });
  
  // Override falls zu wenige Positionen vorgesehen
  if (orientation.min < enforcedOrientation.min) {
    orientation.min = enforcedOrientation.min;
    orientation.max = enforcedOrientation.max;
    console.log(`[LV] Enforcing standard position count for ${trade.code}: ${orientation.min}-${orientation.max}`);
  }
  
  // Verwende EXAKT das gleiche Prompt-Template wie bei erforderlichen Gewerken
  const lvPrompt = await getPromptForTrade(tradeId, 'lv');
  if (!lvPrompt || lvPrompt.length < 100) {
    console.error(`[LV] KRITISCH: LV-Template fehlt für ${trade.code} - Abbruch`);
    throw new Error(`LV-Template für ${trade.name} nicht verfügbar`);
  }
  
  console.log(`[LV] Verwende Standard-LV-Template mit ${lvPrompt.length} Zeichen`);
}
  
  // NEU: Prüfe ob Gerüst als separates Gewerk vorhanden ist
  const hasScaffoldingTrade = await query(
    `SELECT 1 FROM project_trades pt 
     JOIN trades t ON t.id = pt.trade_id 
     WHERE pt.project_id = $1 AND t.code = 'GER'`,
    [projectId]
  );
  const hasGeruestGewerk = hasScaffoldingTrade.rows.length > 0;

  // NEU: Füge Gerüst-Vorbemerkung für betroffene Gewerke hinzu
  let additionalVorbemerkungen = [];
  if (hasGeruestGewerk && ['DACH', 'FASS', 'FEN'].includes(trade.code)) {
    additionalVorbemerkungen.push('Gerüst wird bauseits gestellt');
    additionalVorbemerkungen.push('Gerüstkosten sind in separatem Gewerk erfasst');
  }

  // NEU: Lade ALLE Intake-Antworten mit Zahlen/Maßen
  const intakeResponses = await query(
    `SELECT question_text, answer_text 
     FROM intake_responses
     WHERE project_id = $1`,
    [projectId]
  );
  
  // NEU: Extrahiere ALLE Zahlen- und Maßangaben
  const criticalMeasurements = {};
  
  intakeResponses.rows.forEach(response => {
    const question = response.question_text.toLowerCase();
    const answer = response.answer_text;
    
    // Suche nach Zahlen mit Einheiten
    const measurementMatch = answer.match(/(\d+(?:\.\d+)?)\s*(m²|qm|m2|m|stück|stk)/i);
    
    if (measurementMatch) {
    // Speichere nach Kategorie
    if (question.includes('dach')) {
      criticalMeasurements.dachflaeche = {
        value: parseFloat(measurementMatch[1]),
        unit: measurementMatch[2],
        original: answer,
        source: 'intake'
      };
    }
    if (question.includes('fassade')) {
      criticalMeasurements.fassadenflaeche = {
        value: parseFloat(measurementMatch[1]),
        unit: measurementMatch[2],
        original: answer,
        source: 'intake'
      };
    }
  }  // <-- DIESE KLAMMER FEHLT (schließt if measurementMatch)
});  // <-- DIESE KLAMMER FEHLT (schließt forEach)

// FASS-spezifisch: Extrahiere Dämmstärke
if (trade.code === 'FASS') {
  tradeAnswers.forEach(answer => {
    const question = answer.question.toLowerCase();
    const answerText = answer.answer;
    
    if (question.includes('dämmstärke') || question.includes('dämmung') || 
        question.includes('wärmedämmung') || question.includes('stärke')) {
      
      let daemmstaerke = null;
      
      // Suche ALLE Zahlen im Text
      const allNumbers = answerText.match(/\d+/g);
      
      if (allNumbers && allNumbers.length > 0) {
        // Nimm die erste gültige Dämmstärke (10-30cm)
        for (const num of allNumbers) {
          const value = parseInt(num);
          if (value >= 10 && value <= 30) {
            daemmstaerke = value;
            break;
          }
        }
      }
      
      if (daemmstaerke) {
        // Auf gerade Zahl runden
        if (daemmstaerke % 2 !== 0) {
          daemmstaerke = daemmstaerke + 1;
        }
        
        criticalMeasurements.daemmstaerke = {
          value: daemmstaerke,
          unit: 'cm',
          original: answerText,
          source: 'trade_answers'
        };
        
        console.log(`[FASS] Dämmstärke ${daemmstaerke}cm aus: "${answerText}"`);
      }
    }
  });
}

// GER-spezifisch: Berechne Gerüstfläche aus Fassadenfläche
if (trade.code === 'GER') {
  // Suche Fassadenfläche in Intake oder Trade-Antworten
  let fassadenflaeche = criticalMeasurements.fassadenflaeche?.value;
  
  if (!fassadenflaeche) {
    // Suche in Trade-Antworten
    tradeAnswers.forEach(answer => {
      const question = answer.question.toLowerCase();
      const answerText = answer.answer;
      
      if (question.includes('fassade') && question.includes('fläche')) {
        const flaecheMatch = answerText.match(/(\d+(?:\.\d+)?)\s*(m²|qm|m2)/i);
        if (flaecheMatch) {
          fassadenflaeche = parseFloat(flaecheMatch[1]);
        }
      }
    });
  }
  
  if (fassadenflaeche) {
    // Gerüstfläche = Fassadenfläche * 1.1 (10% Zuschlag)
    const geruestflaeche = Math.round(fassadenflaeche * 1.1);
    
    criticalMeasurements.geruestflaeche = {
      value: geruestflaeche,
      unit: 'm²',
      original: `Berechnet aus Fassadenfläche ${fassadenflaeche}m² + 10% Zuschlag`,
      source: 'calculated'
    };
    
    console.log(`[GER] Gerüstfläche berechnet: ${fassadenflaeche}m² * 1.1 = ${geruestflaeche}m²`);
  }
}
  
  // Validiere und schätze fehlende Werte
  const validationResult = await validateAndEstimateAnswers(
    tradeAnswers,
    trade.code,
    {
      category: project.category,
      description: project.description,
      intakeAnswers
    }
  );

  const lvPrompt = await getPromptForTrade(tradeId, 'lv');
  if (!lvPrompt) throw new Error('LV prompt missing for trade');

  // SICHERSTELLEN dass Prompt korrekt geladen wurde
if (!lvPrompt || lvPrompt.length < 100) {
  console.error(`[LV] WARNING: LV prompt for ${trade.code} missing or too short!`);
  console.error(`[LV] Prompt length: ${lvPrompt?.length || 0}`);
}

// DEBUG: Prüfe ob Prompt korrekte Preisinformationen enthält
if (trade.code === 'GER' && lvPrompt) {
  const hasCorrectPrices = lvPrompt.includes('8-12') || lvPrompt.includes('Auf-/Abbau');
  if (!hasCorrectPrices) {
    console.error(`[LV] WARNING: Gerüst prompt missing price information!`);
  }
}

const universalLVRules = `
╔════════════════════════════════════════════════════════════════╗
║ UNIVERSELLE LV-REGELN FÜR ALLE GEWERKE                        ║
╚════════════════════════════════════════════════════════════════╝

PREISE IN BESCHREIBUNGEN - ABSOLUT VERBOTEN:
NIEMALS Preisspannen: "Premium (400-1000€)", "Standard (50-150€)"  
NIEMALS Preisangaben: "hochwertig (ab 500€)", "günstig (unter 100€)"
NUR Qualitätsbeschreibung: "Premium-Qualität", "Standardausführung"

QUALITÄT MUSS ZUM EP PASSEN:
- EP < 100€ → "Standard" oder keine Qualitätsangabe
- EP 100-250€ → "Solide Qualität"
- EP 250-500€ → "Gehobene Qualität"  
- EP > 500€ → "Premium-Qualität"

NIEMALS "Premium" bei niedrigen Preisen!
NIEMALS "Standard" bei hohen Preisen!

Der PREIS definiert die Qualität, NICHT umgekehrt!
`;
  
  const systemPrompt = `Du bist ein Experte für VOB-konforme Leistungsverzeichnisse mit 25+ Jahren Erfahrung.
Erstelle ein PRÄZISES und REALISTISCHES Leistungsverzeichnis für ${trade.name}.

${manualTradeContext}

${(() => {
  const uploadContext = buildUploadContext(enrichedAnswers);
  if (!uploadContext.hasUploads) return '';
  
  return `
╔══════════════════════════════════════════════════════════════════╗
║              HOCHGELADENE DATEIEN - ZUSÄTZLICHE DATENQUELLE      ║
╚══════════════════════════════════════════════════════════════════╝

${uploadContext.summary}

REGELN FÜR UPLOAD-DATEN:
1. Upload-Daten sind ZUSÄTZLICHE Informationsquelle zu den Antworten
2. Bei strukturierten Listen (Excel): Nutze für detaillierte Mengenermittlung
3. Bei Maßangaben aus PDFs/Plänen: Verwende als Referenz
4. Bei Bildern: Nutze für Zustandsbewertung und Mengenabschätzung

WICHTIG BEI WIDERSPRÜCHEN:
- Wenn Upload-Daten und Textantworten UNTERSCHIEDLICH sind:
  → Erwähne BEIDE Werte im LV
  → Füge Hinweis in Notes hinzu: "Abweichung zwischen Upload (X) und Angabe (Y) - Klärung empfohlen"
  → Verwende den PLAUSIBLEREN Wert für die Kalkulation
- Confidence >80%: Hohe Verlässlichkeit der Upload-Daten
- Confidence <60%: Upload-Daten nur als grobe Orientierung

${uploadContext.detailedData}
`;
})()}

STRIKTE REGEL: Du MUSST zwischen ${orientation.min} und ${orientation.max} Positionen erstellen.
NICHT WENIGER ALS ${orientation.min}, NICHT MEHR ALS ${orientation.max}!

PROJEKT-KOMPLEXITÄT: ${projectComplexity}

📋 POSITIONS-ANFORDERUNG: ${orientation.min}-${orientation.max} Positionen

${Object.keys(criticalMeasurements).length > 0 ? `
KRITISCHE VORGABEN AUS INTAKE (MÜSSEN EXAKT ÜBERNOMMEN WERDEN):
${Object.entries(criticalMeasurements).map(([key, data]) => 
  `- ${key}: ${data.value} ${data.unit} (Nutzerangabe: "${data.original}")`
).join('\n')}

STRIKTE REGEL: 
- Diese Werte MÜSSEN EXAKT in den LV-Positionen verwendet werden
- KEINE Anpassungen, Rundungen oder "Sicherheitszuschläge"
- Bei Dachfläche 120m² MUSS im LV auch 120m² stehen
- Wenn der Nutzer "ca." oder "ungefähr" sagt, verwende trotzdem den genannten Wert
` : ''}

${universalLVRules}

KRITISCHE REGELN:
1. Erstelle ${orientation.min} bis ${orientation.max} ECHTE Positionen mit tatsächlichen Leistungen
2. NIEMALS leere, "nicht vorhanden" oder "nicht definiert" Positionen
3. NIEMALS Positionen mit Menge 0, "-" oder ohne Preis
4. NUR Arbeiten die tatsächlich ausgeführt werden
5. Bei Bedarf: Unterschreitung um max. 30% erlaubt (Minimum: ${Math.floor(orientation.min * 0.7)} Positionen)

${projectComplexity === 'SEHR_HOCH' ? `
🔴 SEHR HOHE KOMPLEXITÄT:
- Ziel: ${orientation.min}-${orientation.max} sinnvolle Positionen
- Mindestens: ${Math.floor(orientation.min * 0.7)} Positionen (30% Toleranz)
- Detaillierte Aufschlüsselung wo sinnvoll
- Zusammenfassung ähnlicher Arbeiten erlaubt
- Fokus auf Vollständigkeit und Qualität
` : projectComplexity === 'HOCH' ? `
🟡 HOHE KOMPLEXITÄT:
- Ziel: ${orientation.min}-${orientation.max} sinnvolle Positionen
- Mindestens: ${Math.floor(orientation.min * 0.7)} Positionen (30% Toleranz)
- Ausgewogene Detaillierung
- Wichtige Leistungen einzeln erfassen
` : projectComplexity === 'MITTEL' ? `
🟢 MITTLERE KOMPLEXITÄT:
- Ziel: ${orientation.min}-${orientation.max} Positionen
- Mindestens: ${Math.floor(orientation.min * 0.7)} Positionen (30% Toleranz)
- Standarddetaillierung mit sinnvollen Zusammenfassungen
` : `
⚪ STANDARD-PROJEKT:
- Ziel: ${orientation.min}-${orientation.max} Positionen
- Mindestens: ${Math.floor(orientation.min * 0.7)} Positionen (30% Toleranz)
- Kompakte, praxisgerechte Darstellung
`}

VERBOTENE POSITIONEN (WERDEN AUTOMATISCH ENTFERNT):
- Positionen mit "(nicht vorhanden)", "(nicht enthalten)", "(nicht definiert)"
- Positionen mit Menge = 0, "-" oder ohne Menge
- Positionen ohne reale Leistung
- Künstliche Positionen nur zur Mengenerhöhung
- Doppelte/redundante Positionen

ERLAUBT:
- Sinnvolle Zusammenfassung ähnlicher Arbeiten
- Unterschreitung der Vorgabe um bis zu 20% wenn nötig
- Fokus auf realistische, ausführbare Leistungen

Ziel: Ein vollständiges, realistisches LV ohne künstliche Aufblähung

KRITISCHE ANFORDERUNGEN FÜR PRÄZISE LV-ERSTELLUNG:

1. NUR ERFRAGTE POSITIONEN:
   - Erstelle NUR Positionen für explizit erfragte und beantwortete Leistungen
   - KEINE erfundenen Positionen oder Annahmen
   - Wenn eine Leistung nicht erfragt wurde, darf sie NICHT im LV erscheinen

2. MENGENERMITTLUNG:
   - Verwende NUR die validierten Mengen aus den Antworten
   - Bei geschätzten Werten: Kennzeichne dies in den Notes
   - Plausibilitätsprüfung aller Mengen

3. PREISKALKULATION (2024/2025):
   - Realistische Marktpreise
   - Regionale Unterschiede berücksichtigen
   - Inkl. aller Nebenleistungen gem. VOB/C

4. TECHNISCH SINNVOLLE POSITIONIERUNG & ORIENTIERUNG:
   - Erfasste Informationen: ${answeredQuestionCount} beantwortete Fragen
   - Orientierungs-Richtwert: ca. ${orientation.min}-${orientation.max} Positionen
   - Diese Zahl ist KEINE strikte Vorgabe, sondern eine ORIENTIERUNG
   - Maßgeblich ist die TECHNISCH SINNVOLLE Aufteilung

   KRITISCHE REGEL FÜR BAUTEILE MIT ABMESSUNGEN:
   - UNTERSCHIEDLICHE Abmessungen = IMMER separate Positionen
   - GLEICHE Abmessungen = IMMER in einer Position mit erhöhter Stückzahl
   
   Beispiele RICHTIG:
   - "3 Stk. Fenster Kunststoff weiß, 120x140cm, DIN rechts" (gleiche Maße)
   - "1 Stk. Fenster Kunststoff weiß, 180x140cm, DIN rechts" (andere Maße = neue Position)
   - "5 Stk. Innentüren Weißlack 86x198,5cm inkl. Zarge" (gleiche Maße)
   - "2 Stk. Innentüren Weißlack 96x198,5cm inkl. Zarge" (andere Breite = neue Position)
   
   Beispiele FALSCH:
   - "Fenster verschiedene Größen" (zu unspezifisch)
   - Gleiche Fenster in mehreren Positionen aufteilen
   - Verschiedene Türmaße in einer Position zusammenfassen
   
   GILT FÜR ALLE BAUTEILE wo Maße kalkulationsrelevant sind:
   - Fenster, Türen, Zargen
   - Heizkörper
   - Sanitärobjekte (Waschbecken, WCs, Duschwannen)
   - Fliesen (verschiedene Formate)
   - Treppen, Geländer
   - Alle vorgefertigten Bauteile mit definierten Abmessungen
   
   Zusammengehörende Arbeiten ohne Maßrelevanz in EINER Position:
   - Flächenarbeiten (Malerarbeiten, Putz, Estrich)
   - Installationsarbeiten (sofern nicht bauteilbezogen)
   - Demontagearbeiten gleicher Art

5. GEWERKEABGRENZUNG & DUPLIKATSVERMEIDUNG:
   - KRITISCH: Prüfe ALLE anderen Gewerke auf Überschneidungen
   - STRIKTE ZUORDNUNGEN:
   - Fliesenarbeiten → IMMER UND AUSSCHLIESSLICH im Gewerk FLI
   - Türen und Zargen → IMMER UND AUSSCHLIESSLICH im Gewerk TIS
   - Rigips-/Gipskartonwände → IMMER UND AUSSCHLIESSLICH im Gewerk TRO
   - Putzqualitäten Q1-Q3 → NUR bei Innenarbeiten im Gewerk MAL
   - Fassadenputz → NUR Struktur/Körnung im Gewerk FASS (keine Q-Stufen)
   - Bodenbeläge wie Parkett/Laminat/Vinyl → NUR im Gewerk BOD (nie Fliesen!)
   - Wanddurchbruch: NUR im beauftragten Hauptgewerk (Rohbau ODER Abbruch, nie beide)
   - Gerüstbau: Wenn als eigenes Gewerk -> KEINE Gerüstpositionen in anderen Gewerken
   - Elektro-/Sanitärschlitze: NUR im jeweiligen Fachgewerk, nicht im Rohbau oder Abbruch
   - Entsorgung: Pro Material nur in EINEM Gewerk ausschreiben
   - Bei Überschneidungsgefahr: Leistung dem primär verantwortlichen Gewerk zuordnen
   
6. GEWERKE-HIERARCHIE (bei Konflikten):
   1. Spezialisierte Gewerke haben Vorrang (z.B. Gerüstbau vor Fassade)
   2. Abbruch vor Neubau
   3. Rohbau vor Ausbau
   4. Hauptleistung vor Nebenleistung
   
7. VOB-KONFORME VORBEMERKUNGEN:
   - Erstelle aus den Intake-Daten technische Vorbemerkungen
   - Diese müssen VOR den Positionen stehen
   - Inhalt: Baustellenlogistik, Gebäudedaten, Arbeitszeiten, besondere Bedingungen
   - Format: Array von Strings im "vorbemerkungen" Feld

8. SPEZIELLE FENSTER-REGELN (NUR für Gewerk FEN):
   ${tradeCode === 'FEN' ? `
   KRITISCH: ÜBERNIMM EXAKT DIE NUTZER-ANGABEN!
   - Lieferung und Montage IMMER in EINER Position pro Fenstertyp
   - DEMONTAGE: NUR EINE Sammelposition für ALLE Altfenster
   - Reihenfolge: Erst Demontage, dann neue Fenster   
   - Wenn Nutzer "Holzfenster" wählt → NUR Holzfenster im LV
   - Wenn Nutzer "Kunststofffenster" wählt → NUR Kunststofffenster im LV
   - KEINE Standard-Annahmen die den Nutzer-Angaben widersprechen!
   
   - JEDES Fenster MUSS als EIGENE Position mit EXAKTEN Abmessungen
   - Format: "Fenster [GEWÄHLTES MATERIAL], [Breite] x [Höhe] cm, [Öffnungsart]"
   - NIEMALS Sammelpositionen wie "6 Fenster" ohne Einzelaufstellung
   - NIEMALS m² oder Pauschalangaben
   - Gleiche Fenstertypen: Als eine Position mit Stückzahl
   
   BEISPIEL KORREKT:
   - Pos 1: Demontage und Entsorgung sämtlicher Altfenster, 5 Stück
   - Pos 2: Fenster [NUTZER-MATERIAL], 120 x 140 cm, Dreh-Kipp, 2 Stück
   - Pos 3: Fenster [NUTZER-MATERIAL], 60 x 80 cm, Kipp, 3 Stück
   
   BEISPIEL FALSCH:
   - "Demontage Fenster 1" 
   - "Demontage Fenster 2" 
   - "Entsorgung Fenster"  
   - "Einbau von 6 Fenstern" 
   - "Fenster gesamt 25 m²" 
   - Falsches Material verwenden 
   ` : ''}

  9. LIEFERUNG UND MONTAGE IMMER ZUSAMMEN:
   - NIEMALS getrennte Positionen für Lieferung und Montage
   - IMMER: "Lieferung und [Verb]" in EINER Position
   - NIEMALS: Lieferung und Demontage im Gewerk ABBR (Abbruch/Entkernung)
   - NIEMALS: Lieferung und Montage bei Rückbau- und Demontagearbeiten in allen Gewerken
   
   KORREKTE FORMULIERUNGEN:
   - "Lieferung und Verlegung von Dachziegeln..."
   - "Lieferung und Montage Fenster Kunststoff, 120x140cm, Dreh-Kipp..."
   - "Lieferung und Montage von Heizkörpern..."
   - "Lieferung und Installation von Sanitärobjekten..."
   - "Lieferung und Verlegen von Fliesen..."
   
   FALSCH:
   - "Verlegung von Dachziegeln..." (fehlt Lieferung!)
   - "Einbau von Fenstern..." (fehlt Lieferung!)
   - Pos 1: "Lieferung Dachziegel", Pos 2: "Verlegung Dachziegel"
   
   AUSNAHMEN (OHNE "Lieferung"):
   - Reine Arbeitsleistungen: "Abbruch...", "Demontage...", "Reinigung..."
   - Vorhandenes Material: "Wiederverwendung vorhandener..."
   - Nebenleistungen: "Abdichtung...", "Anschluss...", "Verfugung..."
   
   KRITISCH: Bei JEDEM einzubauenden Material in JEDEM Gewerk MUSS "Lieferung und" vorangestellt werden!

10. REALISTISCHE PREISE ZWINGEND:
    - Putzarbeiten: 25-60€/m² oder 30-80€/m
    - Fenster komplett: 400-4000€/Stück (inkl. Montage)
    - Türen komplett: 600-6000€/Stück (inkl. Montage)
    - NIEMALS über 200€/m für einfache Arbeiten
    - NIEMALS über 100€/m² für Standard-Arbeiten

11. STRIKTE GEWERKE-TRENNUNG:
    - Fenster (normale) → NUR im Gewerk FEN
    - Dachfenster → NUR im Gewerk DACH
    - NIEMALS Annahmen treffen die nicht explizit genannt wurden
    - Bei "5 Fenster" im Projekt + Dach-Gewerk → KEINE Dachfenster annehmen!

KRITISCHE VERBOTE - NIE VERWENDEN:
1. "Lieferung und Demontage" - IMMER TRENNEN in:
   - "Demontage und Entsorgung" (eigene Position)
   - "Lieferung und Montage" (eigene Position)

2. Vorwandinstallation:
   - NUR bei Gewerk TROCKENBAU (TRO) erlaubt
   - Bei SANITÄR (SAN): Verwende "Unterputz-Installation"
   - Bei anderen Gewerken: GAR NICHT erwähnen

3. Korrekte Formulierungen:
   ✓ "Lieferung und Montage"
   ✓ "Demontage und Entsorgung"
   ✗ "Lieferung und Demontage" (FALSCH!)
   
4. Gewerke-Abgrenzung:
   - Vorwand = IMMER Trockenbau
   - Sanitärinstallation in Vorwand = Zwei Gewerke:
     * TRO: Vorwandinstallation erstellen
     * SAN: Sanitärobjekte montieren

// Trade-spezifische Ergänzung
const tradeSpecificRules = {
  'FEN': 'KEINE Dachfenster - nur normale Wandfenster!',
  'DACH': 'Dachfenster JA, normale Fenster NEIN!',
  'SAN': 'KEINE Vorwandinstallation - nur Sanitärobjekte!',
  'TRO': 'Vorwandinstallation JA, aber KEINE Sanitärobjekte!'
};

  ${hasGeruestGewerk && ['DACH', 'FASS', 'FEN'].includes(trade.code) ? `
KRITISCH - GERÜST-REGEL:
- Gerüst ist als SEPARATES Gewerk vorhanden
- KEINE Gerüstpositionen in diesem LV
- Vorbemerkung hinzufügen: "Gerüst wird bauseits gestellt"
- Alle Gerüstkosten sind im Gewerk GER erfasst
` : ''}

${trade.code === 'GER' ? `
KRITISCH FÜR GERÜSTBAU - STRIKTE REGELN:

${criticalMeasurements.geruestflaeche ? `
GERÜSTFLÄCHE - VERBINDLICH:
- EXAKTE GERÜSTFLÄCHE: ${criticalMeasurements.geruestflaeche.value} m²
- Berechnung: Fassadenfläche + 10% Sicherheitszuschlag
- Diese Fläche MUSS in allen Positionen verwendet werden
` : ''}

PFLICHT-POSITIONEN (GENAU DIESE STRUKTUR):
1. "Lieferung, Auf- und Abbau Arbeitsgerüst" - ${criticalMeasurements.geruestflaeche?.value || '[Fläche]'} m² - 8-12 €/m²
2. "Gerüst-Standzeit erste 4 Wochen" - ${criticalMeasurements.geruestflaeche?.value || '[Fläche]'} m² - 4-6 €/m²
3. "Gerüst-Standzeit jede weitere Woche (Eventualposition)" - ${criticalMeasurements.geruestflaeche?.value || '[Fläche]'} m² - max. 1,20 €/m² - MUSS als NEP markiert sein!
4. "Schutznetz/Plane" - ${criticalMeasurements.geruestflaeche?.value || '[Fläche]'} m² - 2-3 €/m² (optional)

VERBOTEN:
- KEINE separate Position "An- und Abtransport" (ist in Pos. 1 enthalten!)
- KEINE höhere Fläche als berechnet
- KEINE Transportkosten als eigene Position

EVENTUALPOSITION (NEP):
Die Position "Gerüst-Standzeit jede weitere Woche" MUSS:
- Als Eventualposition (NEP) markiert werden: "isNEP": true
- Einheitspreis maximal 1,20 €/m²
- NICHT in die Hauptsumme einfließen
- Mit Hinweis "Abrechnung nach tatsächlichem Bedarf"

REALISTISCHE PREISE:
- Auf-/Abbau inkl. Transport: 8-12 €/m²
- Standzeit erste 4 Wochen: 4-6 €/m²
- Jede weitere Woche (NEP): max. 1,20 €/m²
- Schutznetz: 2-3 €/m²
` : ''}

${trade.code === 'ROH' ? `
KRITISCH FÜR ROHBAUARBEITEN:
1. KLARE ABGRENZUNG - ROHBAU macht NUR:
   - Fundamente, Bodenplatte, Kellerwände
   - Tragende Wände (Mauerwerk, Beton, Stahlbeton)
   - Rohdecken (Betondecken, Filigrandecken)
   - Stürze, Ringanker, Betonstützen
   - Treppen (Rohbau, nicht Ausbau)
   - Verstärkung/Ertüchtigung von BESTANDSMAUERWERK
   - Statisch relevante Wanddurchbrüche
   - Anschlüsse AN Bestandsmauerwerk
   
2. NIEMALS IM ROHBAU:
   - KEIN Estrich (gehört zu Gewerk ESTR)
   - KEINE Dämmung unter Estrich
   - KEIN Holzbau (→ ZIMM)
   - KEINE Holzständerwände (→ ZIMM)
   - KEINE Holzbalkendecke (→ ZIMM)
   - KEINE Dachkonstruktion (→ ZIMM)   
   - KEINE Trittschalldämmung 
   - KEINE Bodenbeläge
   - KEINE Putze (gehört zu MAL oder FASS)
   - KEINE Abdichtungen (außer Bodenplatte, Kellerwände)

3. HÄUFIGE FEHLER VERMEIDEN:
   - "Estrich" → FALSCH! Rohbau macht nur Rohdecke
   - "Fließestrich" → FALSCH! Gehört zu ESTR
   - "Dämmung unter Estrich" → FALSCH! Gehört zu ESTR
   - "Innenputz" → FALSCH! Gehört zu MAL

4. KORREKTE POSITIONEN:
   - "Stahlbetondecke d=20cm"
   - "Filigrandecke verlegen"
   - "Mauerwerk erstellen, 24cm Poroton"
   - "Ringanker betonieren"
   - "Betonstützen 30x30cm"

5. BEI DEMONTAGE/ABBRUCH:
   - Wanddurchbrüche gehören zu ROH
   - Deckendurchbrüche gehören zu ROH
   - Abbruch tragender Teile gehört zu ROH
   - Nicht-tragende Wände → Gewerk TRO oder ABBR

6. BEI AUFSTOCKUNG IN HOLZBAUWEISE:
   - Rohbau macht NUR: Verstärkung Bestandsmauerwerk, Ringanker aus Beton
   - Zimmerer macht: KOMPLETTE Holzkonstruktion der Aufstockung
   - KEINE Vermischung der Gewerke!

WENN HOLZBAU ERWÄHNT WIRD:
→ Schreibe: "Holzbauarbeiten siehe Gewerk ZIMMERER"
→ KEINE Holz-Positionen im Rohbau-LV!
` : ''}

${trade.code === 'HEI' ? `
KRITISCH FÜR HEIZUNGSARBEITEN:

1. HEIZLASTBERECHNUNG IMMER ZUERST FRAGEN:
   - "Liegt eine Heizlastberechnung vor?"
   - Wenn JA: Nach berechneten Leistungen fragen
   - Wenn NEIN: Nach Raumgrößen fragen, "gemäß Heizlastberechnung" ins LV

2. FUSSBODENHEIZUNG - EXKLUSIVE ZUSTÄNDIGKEIT:
   IMMER im Heizungs-LV:
   - Fußbodenheizung komplett
   - Heizrohre/Heizkreise verlegen
   - Verteiler für FBH inkl. Durchflussmesser
   - Systemplatten/Noppenplatten/Tackerplatten
   - Heizkreise anschließen und regulieren
   - Befüllung und Druckprobe FBH
   - Heizkreisverteiler inkl. Stellantriebe
   
   NIEMALS im Heizungs-LV:
   - Estrich (gehört zu ESTR)
   - Dämmung unter Estrich (gehört zu ESTR)
   - Randdämmstreifen (gehört zu ESTR)
   
   KORREKTE FORMULIERUNGEN:
   - "Lieferung und Verlegung Fußbodenheizung, Noppenplatte"
   - "FBH-Verteiler 8 Kreise inkl. Durchflussmesser"
   - NICHT: "Heizestrich" (das macht ESTR)
` : ''}

${trade.code === 'ESTR' ? `
KRITISCH FÜR ESTRICHARBEITEN:
1. ESTRICH KOMMT NACH ROHBAU:
   - Rohdecke muss fertig sein
   - Elektro/Sanitär-Leitungen verlegt
   - Innenputz idealerweise fertig

2. ESTRICH-POSITIONEN:
   - Dämmung unter Estrich
   - Trittschalldämmung
   - Randdämmstreifen
   - Fließestrich/Zementestrich/Anhydritestrich
   - Estrich schleifen
   - KEINE Rohdecken oder Betonarbeiten!

3. FUSSBODENHEIZUNG - KLARE ABGRENZUNG:
   NIEMALS "Fußbodenheizung verlegen" im Estrich-LV!
   NIEMALS "Heizrohre verlegen" oder "Heizkreise"!
   NUR "Heizestrich" oder "Estrich auf Fußbodenheizung"
   
   Die Fußbodenheizung selbst = IMMER Gewerk HEIZUNG
   Der Estrich darüber = Gewerk ESTRICH
   
   KORREKTE FORMULIERUNG:
   - "Heizestrich auf vorhandener Fußbodenheizung"
   - "Estrich schwimmend auf FBH-System"
   - NICHT: "inkl. Fußbodenheizung"!

4. MENGENERMITTLUNG:
   - Fläche = Bodenfläche der Räume
   - NICHT Deckenfläche (das ist Rohbau)
   - Dämmung = gleiche Fläche wie Estrich
` : ''}

${trade.code === 'SAN' ? `
KRITISCH FÜR SANITÄR:
HAUPTREGEL:
- Vorwandinstallation → IMMER Trockenbau (TRO)
- SAN macht NUR Sanitärobjekte, Anschlüsse und Leitungen
- Elektrische Handtuchheizkörper → SAN (da Sanitärobjekt)
REIHENFOLGE:
1. Rohinstallation (vor Fliesen)
2. Fliesenleger macht Fliesen
3. Endmontage (nach Fliesen)
NICHT VON SAN:
- Elektrische Fußbodenheizung → ELEKT oder FLI
` : ''}

${trade.code === 'ELEKT' ? `
KRITISCH FÜR ELEKTRO:
HAUPTREGEL:
- Schlitze in Wänden → IMMER Elektroinstallation selbst, nie Rohbau (ROH)
- Endmontage → IMMER nach Malerarbeiten
- FI-Schutzschalter Bad → PFLICHT
- Elektrische Fußbodenheizung → ELEKT macht Anschluss + Thermostat
SCHNITTSTELLEN:
- PV: Elektro macht AC-Seite, PV macht DC-Seite
- Heizung: Elektro macht Stromanschluss für Kessel/Wärmepumpe
- Bad: FI-Schutzschalter + Potentialausgleich
- Fußbodenheizung elektrisch: ELEKT (Anschluss) oder FLI (Komplett inkl. Verlegung)
- Handtuchheizkörper elektrisch: Stromanschluss von ELEKT, Gerät von SAN
` : ''}

${trade.code === 'FLI' ? `
KRITISCH FÜR FLIESENLEGER:
HAUPTREGEL:
- Elektrische Fußbodenheizung → FLI kann komplett machen (nach Estrich, vor Fliesen)
- Alternative: ELEKT macht Anschluss, FLI verlegt Heizmatten
REIHENFOLGE:
1. Estrich fertig
2. Elektrische Fußbodenheizung verlegen (falls vorhanden)
3. Fliesen verlegen
` : ''}

${trade.code === 'DACH' ? `
KRITISCH FÜR DACHARBEITEN:
- NUR Dachfenster wenn EXPLIZIT "Dachfenster" erwähnt
- Bei "Fenster" im Projekt → Das sind NORMALE Fenster (Gewerk FEN)
- KEINE Annahmen über nicht erwähnte Leistungen
- Fokus auf: Dämmung, Eindeckung, Abdichtung, Rinnen
` : ''}

${trade.code === 'FASS' ? `
KRITISCH FÜR FASSADENARBEITEN:

DÄMMSTÄRKE - ABSOLUT VERBINDLICH:
${criticalMeasurements.daemmstaerke ? `
- EXAKTE DÄMMSTÄRKE: ${criticalMeasurements.daemmstaerke.value} cm
- Diese Stärke MUSS in ALLEN Dämmpositionen verwendet werden
- KEINE Abweichungen erlaubt!
- Nutzerangabe war: "${criticalMeasurements.daemmstaerke.original}"
` : ''}

WICHTIG:
- NUR gerade Dämmstärken verwenden (10, 12, 14, 16, 18, 20 cm)
- Ungerade Zahlen sind NICHT handelsüblich
- Bei ungeraden Angaben: Auf nächste gerade Zahl aufrunden
- Die angegebene Dämmstärke MUSS exakt übernommen werden
- Sockeldämmung immer 2 cm dünner als WDVS

BEISPIEL KORREKT:
- "Lieferung und Montage WDVS, EPS WLG 035, ${criticalMeasurements.daemmstaerke?.value || 16} cm"

BEISPIEL FALSCH:
- "WDVS, 15 cm" (ungerade Zahl!)
- Andere Stärke als angegeben verwenden
` : ''}

${trade.code === 'TIS' ? `
KRITISCH FÜR TÜRARBEITEN:
1. DEMONTAGE/ENTSORGUNG:
   - NUR EINE Sammelposition für ALLE Demontagen
   - Format: "Demontage und Entsorgung sämtlicher Alttüren, [X] Stück"
   - NICHT einzeln aufführen!
   
2. NEUE TÜREN:
   - Jede unterschiedliche Größe = eigene Position
   - IMMER "Lieferung und Montage" in EINER Position
   - KEINE separaten Montage-Positionen wenn bereits in "Lieferung und Montage" enthalten
   
3. REALISTISCHE PREISE:
   - Demontage + Entsorgung: 60-100€ pro Tür
   - Innentür Standard (inkl. Montage): 400-800€
   - Wohnungstür Sicherheit: 1500-3000€
   - Beschläge Innentür: 60-150€
   - NIEMALS alle Positionen mit gleichem Preis!
` : ''}

${trade.code === 'SCHL' ? `
KRITISCH FÜR GELÄNDER:
- Jedes Geländer MUSS als einzelne "Lieferung und Montage" Position ausgeschrieben werden
- Format: "Lieferung und Montage [Typ]geländer [Material] [Länge]"
- KEINE separaten Positionen für:
  - Werkstattfertigung
  - Produktion
  - Füllungen/Metallstäbe
  - Verzinkung (außer Pulverbeschichtung als Zusatz)
  - Montage ohne Lieferung
- Diese Leistungen sind in der Hauptposition "Lieferung und Montage" enthalten
- Erlaubte Zusatzpositionen: Demontage Alt, Entsorgung, Pulverbeschichtung, Verankerung, Zusatz- und Nebenarbeiten!
` : ''}

OUTPUT FORMAT (NUR valides JSON):
{
  "trade": "${trade.name}",
  "tradeCode": "${trade.code}",
  "vorbemerkungen": [
    "Gebäudedaten und Baustellensituation aus Projekterfassung",
    "Zufahrt und Lagerungsmöglichkeiten",
    "Verfügbare Anschlüsse",
    "Arbeitszeiten und Einschränkungen"
  ],
  "projectType": "string",
  "dataQuality": {
    "measuredValues": 15,
    "estimatedValues": 3,
    "confidence": 0.85
  },
  "positions": [
    // KRITISCH: EXAKT ${orientation.min} bis ${orientation.max} POSITIONEN
    // NICHT WENIGER, NICHT MEHR!
    { 
      "pos": "01.01.001",
      "title": "Präziser Positionstitel",
      "description": "Detaillierte VOB-konforme Beschreibung mit Material, Ausführung, Qualität, Normen. Min. 2-3 Sätze.",
      "quantity": 150.00,
      "unit": "m²",
      "unitPrice": 45.50,
      "totalPrice": 6825.00,
      "priceBase": "Marktpreis 2024 inkl. Nebenleistungen",
      "dataSource": "measured|estimated|assumed",
      "notes": "Hinweise zu Annahmen"
    }
  ],
  "positionCount": ${orientation.max}, // MAXIMAL ERLAUBTE ANZAHL
  "totalSum": 0,
  "additionalNotes": "Wichtige Ausführungshinweise",
  "assumptions": ["Liste aller getroffenen Annahmen"],
  "excludedServices": ["Explizit nicht enthaltene Leistungen"],
  "priceDate": "${new Date().toISOString().split('T')[0]}",
  "validUntil": "3 Monate",
  "executionTime": "Geschätzte Ausführungsdauer"
}`;

// Cross-Check Funktion zur Duplikatsprüfung
async function checkForDuplicatePositions(projectId, currentTradeId, positions) {
  const otherLVs = await query(
    `SELECT t.name as trade_name, t.code as trade_code, l.content 
     FROM lvs l 
     JOIN trades t ON l.trade_id = t.id 
     WHERE l.project_id = $1 AND l.trade_id != $2`,
    [projectId, currentTradeId]
  );
  
  const duplicates = [];
  const criticalKeywords = [
    'Wanddurchbruch', 'Durchbruch', 
    'Gerüst', 'Arbeitsgerüst', 'Fassadengerüst',
    'Container', 'Baustelleneinrichtung',
    'Entsorgung', 'Abtransport', 'Abfuhr'
  ];
  
  for (const pos of positions) {
    for (const lv of otherLVs.rows) {

  // NEUE ZEILEN HIER EINFÜGEN:
  if (!lv.content || lv.content === '[object Object]') {
    console.log('[checkForDuplicatePositions] Skipping invalid LV content');
    continue;
  }
  
  let otherContent;
  try {
    otherContent = JSON.parse(lv.content);  // Original Zeile 1615
  } catch (error) {
    console.log('[checkForDuplicatePositions] Could not parse LV content:', error.message);
    continue;
  }      
  
      if (!otherContent.positions) continue;
      
      for (const otherPos of otherContent.positions) {
        for (const keyword of criticalKeywords) {
          if (pos.title?.toLowerCase().includes(keyword.toLowerCase()) && 
              otherPos.title?.toLowerCase().includes(keyword.toLowerCase())) {
            duplicates.push({
              position: pos.title,
              foundIn: lv.trade_name,
              tradeCode: lv.trade_code,
              keyword: keyword
            });
          }
        }
      }
    }
  }
  
  return duplicates;
}  
  
  const userPrompt = `GEWERK: ${trade.name} (${trade.code})
  
PFLICHT-ANFORDERUNG: Erstelle MINDESTENS ${orientation.min} Positionen!
LV-TEMPLATE (MUSS BEACHTET WERDEN!):
${lvPrompt || 'KEIN TEMPLATE GELADEN - FEHLER!'}

KRITISCH: Die Preise und Strukturvorgaben aus dem Template MÜSSEN eingehalten werden!

PROJEKTDATEN:
${JSON.stringify(project, null, 2)}

INTAKE-ANTWORTEN (${enrichedIntakeAnswers.length} Antworten):
WICHTIG: Diese Intake-Daten müssen als Vorbemerkungen im LV erscheinen!
${enrichedIntakeAnswers.map(a => {
  let answer = `[${a.question_id}] ${a.question}
  Antwort: ${a.answer}`;
  
  if (a.hasUpload) {
    answer += ` 📎 (Upload: ${a.uploadFileName})`;
  }
  
  if (a.assumption) {
    answer += `\n  Annahme: ${a.assumption}`;
  }
  
  return answer;
}).join('\n\n')}

GEWERK-SPEZIFISCHE ANTWORTEN (${enrichedAnswers.length} Antworten):
${enrichedAnswers.map(a => {
  let answer = `[${a.question_id}] ${a.question}${a.unit ? ` (${a.unit})` : ''}
  Antwort: ${a.answer || a.answer_text}`;
  
  // Upload-Info hinzufügen
  if (a.hasUpload) {
    answer += `
  📎 UPLOAD: ${a.uploadMetadata.fileName} (${a.uploadMetadata.documentType || a.uploadMetadata.fileType})
  📊 Confidence: ${(a.uploadMetadata.confidence * 100).toFixed(0)}%`;
    
    if (a.extractedAnswer && a.extractedAnswer !== a.answer_text) {
      answer += `
  🔍 Extrahiert: ${a.extractedAnswer}`;
    }
    
    if (a.structuredData?.items) {
      answer += `
  📋 Strukturierte Daten: ${a.structuredData.items.length} Einträge (Typ: ${a.structuredData.type})`;
    }
  }
  
  if (a.assumption) {
    answer += `
  ⚠️ Annahme: ${a.assumption}`;
  }
  
  return answer;
}).join('\n\n')}

VALIDIERTE WERTE:
${validationResult ? JSON.stringify(validationResult, null, 2) : 'Keine Validierung verfügbar'}

WICHTIG:
1. Erstelle NUR Positionen für explizit erfragte Leistungen
2. Verwende die validierten Mengen
3. Realistische Preise (Stand 2024/2025)
4. Dokumentiere alle Annahmen transparent`;  // HIER ENDET der userPrompt String

console.log(`[LV-DEBUG] Building userPrompt with ${enrichedAnswers.length} enriched answers`);
console.log(`[LV-DEBUG] Sample enriched answer:`, enrichedAnswers[0]);
  
  try {
  const response = await llmWithPolicy('lv', [
    { role: 'system', content: systemPrompt },
    { role: 'user', content: userPrompt }
  ], { 
    maxTokens: 16000,
    temperature: 0.3,
    jsonMode: true,  // Nutzt jetzt den korrigierten JSON-Mode
    timeout: 120000
  });

// Debug was wirklich zurückkommt
console.log('[LV-DEBUG] Raw response type:', typeof response);
console.log('[LV-DEBUG] First 500 chars:', response.substring(0, 500));
    
  // Debug-Output für alle Gewerke (kann später auf problematische beschränkt werden)
  if (trade.code === 'FASS' || trade.code === 'FEN') {
    console.log(`\n========== ${trade.code} LLM RESPONSE DEBUG ==========`);
    console.log('Response length:', response.length);
    console.log('First 200 chars:', response.substring(0, 200));
    console.log('Last 200 chars:', response.substring(response.length - 200));
    
    // Prüfe ob Response mit { beginnt und } endet
    const startsWithBrace = response.trim().startsWith('{');
    const endsWithBrace = response.trim().endsWith('}');
    console.log('Starts with {:', startsWithBrace);
    console.log('Ends with }:', endsWithBrace);
    
    // Prüfe auf Markdown
    if (response.includes('```')) {
      console.log('⚠️ WARNING: Contains markdown blocks (should not happen with JSON mode)');
    }
    
    console.log('========================================\n');
  }
  
  // VERBESSERTE Bereinigung für Claude-Responses
let cleanedResponse = response.trim();

// Claude-spezifische Bereinigung (auch wenn jsonMode aktiv ist)
if (cleanedResponse.includes('```')) {
  console.warn(`[LV] Markdown wrapper detected for ${trade.code} - cleaning...`);
  // Entferne ```json oder ``` am Anfang und Ende
  cleanedResponse = cleanedResponse
    .replace(/^```(?:json)?\s*\n?/, '')
    .replace(/\n?```\s*$/, '');
}

// Weitere Claude-typische Probleme bereinigen
cleanedResponse = cleanedResponse
  .replace(/^json\s*\n?/i, '') // Falls "json" oder "JSON" am Anfang steht
  .trim();

// Validiere JSON-Struktur
if (!cleanedResponse.startsWith('{') || !cleanedResponse.endsWith('}')) {
  console.error(`[LV] Invalid JSON structure for ${trade.code}`);
  
  // Versuche zu reparieren
  const firstBrace = cleanedResponse.indexOf('{');
  const lastBrace = cleanedResponse.lastIndexOf('}');
  
  if (firstBrace !== -1 && lastBrace !== -1 && firstBrace < lastBrace) {
    cleanedResponse = cleanedResponse.substring(firstBrace, lastBrace + 1);
    console.log(`[LV] Trimmed to valid JSON bounds for ${trade.code}`);
  }
}

// Parse mit erweiterter Fehlerbehandlung
let lv;
try {
  lv = JSON.parse(cleanedResponse);
  console.log(`[LV] Successfully parsed JSON for ${trade.code}`);
  
} catch (parseError) {
  console.error(`[LV] Parse error for ${trade.code}:`, parseError.message);
  console.error('[LV] First 200 chars of response:', cleanedResponse.substring(0, 200));
  
  // Versuche abgeschnittenes JSON zu reparieren
  if (parseError.message.includes('Unexpected end of JSON')) {
    console.log('[LV] Attempting to repair truncated JSON...');
    
    // Zähle offene Arrays/Objekte
    const openBraces = (cleanedResponse.match(/{/g) || []).length;
    const closeBraces = (cleanedResponse.match(/}/g) || []).length;
    const openBrackets = (cleanedResponse.match(/\[/g) || []).length;
    const closeBrackets = (cleanedResponse.match(/\]/g) || []).length;
    
    let repaired = cleanedResponse;
    
    // Schließe offene Arrays
    for (let i = 0; i < (openBrackets - closeBrackets); i++) {
      repaired += ']';
    }
    
    // Schließe offene Objekte
    for (let i = 0; i < (openBraces - closeBraces); i++) {
      repaired += '}';
    }
    
    try {
      lv = JSON.parse(repaired);
      console.log('[LV] Successfully repaired truncated JSON');
    } catch (repairError) {
      console.error('[LV] Repair attempt failed');
      throw new Error(`LV-Generierung für ${trade.name} fehlgeschlagen - Claude lieferte ungültiges JSON trotz JSON-Mode`);
    }
  } else {
    // Nicht reparierbar
    throw new Error(`LV-Generierung für ${trade.name} fehlgeschlagen - Claude lieferte ungültiges JSON trotz JSON-Mode`);
  }
}

// Das auch BEHALTEN:
const uploadContext = buildUploadContext(enrichedAnswers);
const extractedData = extractProjectKeyData(project.description, project.category);
    
// Validiere LV-Struktur
if (!lv || !lv.positions || !Array.isArray(lv.positions)) {
  throw new Error(`LV-Generierung für ${trade.name} fehlgeschlagen - Ungültige LV-Struktur`);
}
    
// INTELLIGENTE KONTEXT-VALIDIERUNG FÜR MANUELL/ZUSÄTZLICH HINZUGEFÜGTE GEWERKE
if ((projectMetadata.isManual || projectMetadata.isAiRecommended) && contextAnswer) {
  console.log(`[LV-VALIDATION] Starting intelligent context validation for ${trade.code}`);
  console.log(`[LV-VALIDATION] User scope: "${contextAnswer.answer}"`);
  
  // NEU: Sammle Keywords aus ALLEN verfügbaren Quellen
  const allKeywords = extractAllRelevantKeywords(
    contextAnswer,
    tradeAnswers,
    extractedData,  // Diese Variable sollte bereits im Scope verfügbar sein
    trade.code
  );
  
  console.log(`[LV-VALIDATION] Collected ${allKeywords.length} keywords from all sources`);
  
  const beforeFilter = lv.positions.length;
  const filteredPositions = [];
  const rejectedPositions = [];
  
  lv.positions.forEach(pos => {
    const posTitle = (pos.title || '').toLowerCase();
    const posDesc = (pos.description || '').toLowerCase();
    const posText = `${posTitle} ${posDesc}`;
    
    // Relevanz-Score System
    let relevanceScore = 0;
    const reasons = [];
    
    // 1. Direkte Keyword-Übereinstimmung (40 Punkte)
    const matchingKeywords = allKeywords.filter(kw => 
      posText.includes(kw.toLowerCase())
    );
    
    if (matchingKeywords.length > 0) {
      relevanceScore += Math.min(40, matchingKeywords.length * 10);
      reasons.push(`Keywords: ${matchingKeywords.slice(0, 3).join(', ')}`);
    }
    
    // 2. Mengen-Übereinstimmung (30 Punkte)
    if (pos.quantity) {
      const quantityStr = pos.quantity.toString();
      const hasMatchingQuantity = tradeAnswers.some(ans => 
        ans.answer?.includes(quantityStr)
      );
      
      if (hasMatchingQuantity) {
        relevanceScore += 30;
        reasons.push(`Quantity match: ${quantityStr}`);
      }
    }
    
    // 3. Maß-Übereinstimmung (30 Punkte)
    const dimensionPattern = /\d+\s*[x×]\s*\d+/gi;
    const posDimensions = posText.match(dimensionPattern);
    
    if (posDimensions) {
      const hasMatchingDimension = tradeAnswers.some(ans => {
        return posDimensions.some(dim => 
          ans.answer?.toLowerCase().includes(dim.toLowerCase())
        );
      });
      
      if (hasMatchingDimension) {
        relevanceScore += 30;
        reasons.push('Dimension match');
      }
    }
    
    // 4. Basis-Arbeiten (20 Punkte)
    const baseWorkKeywords = [
      'vorbereitung', 'abdeckung', 'schutz', 'reinigung', 
      'entsorgung', 'anfahrt', 'montage', 'demontage',
      'kleinmaterial', 'befestigung', 'baustelleneinrichtung',
      'koordination', 'stundenlohn', 'nachbehandlung'
    ];
    
    const isBaseWork = baseWorkKeywords.some(kw => posText.includes(kw));
    if (isBaseWork) {
      relevanceScore += 20;
      reasons.push('Base work');
    }
    
    // 5. File-Upload Kontext Bonus (20 Punkte)
    if (contextAnswer.answer?.includes('Datei analysiert') || 
        contextAnswer.answer?.includes('PDF') ||
        contextAnswer.answer?.includes('Excel') ||
        contextAnswer.answer?.includes('hochgeladen')) {
      relevanceScore += 20;
      reasons.push('File context bonus');
    }
    
    // ENTSCHEIDUNG: Position behalten wenn Score >= 30
    const shouldKeep = relevanceScore >= 30;
    
    if (shouldKeep) {
      filteredPositions.push(pos);
      console.log(`[LV-VALIDATION] ✓ KEPT (Score: ${relevanceScore}): "${pos.title}"`);
    } else {
      rejectedPositions.push(pos);
      console.log(`[LV-VALIDATION] ✗ REJECTED (Score: ${relevanceScore}): "${pos.title}"`);
    }
  });
  
  lv.positions = filteredPositions;
  
  const filteredCount = beforeFilter - lv.positions.length;
  
  if (filteredCount > 0) {
    console.log(`[LV-VALIDATION] ═══════════════════════════════════════`);
    console.log(`[LV-VALIDATION] FILTERED ${filteredCount} positions`);
    console.log(`[LV-VALIDATION] Remaining: ${lv.positions.length} positions`);
    console.log(`[LV-VALIDATION] ═══════════════════════════════════════`);
    
    // Füge Hinweis zu Notes hinzu
    if (!lv.additionalNotes) lv.additionalNotes = '';
    lv.additionalNotes += `\n\nHINWEIS: Dieses LV wurde auf Basis aller verfügbaren Informationen erstellt.`;
    if (contextAnswer.answer?.includes('Datei') || contextAnswer.answer?.includes('PDF')) {
      lv.additionalNotes += ` Die hochgeladene Datei wurde berücksichtigt.`;
    }
    lv.additionalNotes += ` ${lv.positions.length} relevante Positionen wurden identifiziert.`;
  }
  
  // KRITISCHE PRÜFUNG: Warnung bei zu starker Filterung
  if (lv.positions.length < 3 && rejectedPositions.length > 5) {
    console.warn(`[LV-VALIDATION] WARNING: Possibly over-filtered!`);
    console.warn(`[LV-VALIDATION] Only ${lv.positions.length} positions remain`);
    
    // Bei sehr wenigen Positionen: Die besten verworfenen wieder hinzufügen
    const highScoreRejects = rejectedPositions
      .map(pos => {
        // Berechne Score für verworfene Positionen
        const posText = `${pos.title} ${pos.description}`.toLowerCase();
        let score = 0;
        
        // Basis-Arbeiten bekommen Extra-Chance
        if (posText.includes('montage') || posText.includes('demontage') || 
            posText.includes('entsorgung') || posText.includes('vorbereitung')) {
          score += 15;
        }
        
        return { pos, score };
      })
      .filter(item => item.score > 0)
      .sort((a, b) => b.score - a.score)
      .slice(0, 2);
    
    if (highScoreRejects.length > 0 && lv.positions.length < 2) {
      console.log('[LV-VALIDATION] Re-adding essential base work positions');
      highScoreRejects.forEach(item => {
        lv.positions.push(item.pos);
        console.log(`[LV-VALIDATION] + Re-added: "${item.pos.title}"`);
      });
    }
  }
  
  // Wenn gar keine Positionen: Fehler
  if (lv.positions.length === 0) {
    throw new Error(
      `LV-Generierung fehlgeschlagen: Keine passenden Positionen gefunden. ` +
      `Bitte stellen Sie sicher, dass alle relevanten Fragen beantwortet wurden.`
    );
  }
}

/**
 * NEUE FUNKTION: Erweiterte Keyword-Extraktion aus ALLEN verfügbaren Quellen
 * @param {Object} contextAnswer - Die Kontext-Antwort (z.B. von File-Upload)
 * @param {Array} tradeAnswers - Alle Antworten für dieses Gewerk
 * @param {Object} extractedData - Extrahierte Daten aus Projektbeschreibung/Files
 * @param {String} tradeCode - Code des Gewerks
 * @returns {Array} Array von relevanten Keywords
 */
function extractAllRelevantKeywords(contextAnswer, tradeAnswers, extractedData, tradeCode) {
  const keywords = [];
  
  // 1. Keywords aus Kontext-Antwort (z.B. File-Upload Analyse)
  if (contextAnswer?.answer) {
    const contextKeywords = extractKeywordsFromScope(contextAnswer.answer, tradeCode);
    keywords.push(...contextKeywords);
  }
  
  // 2. Keywords aus allen Trade-Antworten extrahieren
  if (tradeAnswers && tradeAnswers.length > 0) {
    tradeAnswers.forEach(ans => {
      // Extrahiere relevante Begriffe aus Antworten
      const answerWords = (ans.answer || '').toLowerCase().split(/[\s,;.!?]+/);
      
      answerWords.forEach(word => {
        const cleanWord = word.replace(/[^a-zäöüß0-9]/gi, '');
        if (cleanWord.length > 3 && !keywords.includes(cleanWord)) {
          keywords.push(cleanWord);
        }
      });
      
      // Spezielle Muster extrahieren (Maße, Mengen)
      const patterns = [
        /\d+\s*x\s*\d+/gi,  // Maße wie "90x200"
        /\d+\s*(m²|qm|m|cm|mm|stk|stück)/gi,  // Mengenangaben
      ];
      
      patterns.forEach(pattern => {
        const matches = (ans.answer || '').match(pattern);
        if (matches) {
          matches.forEach(match => {
            const clean = match.toLowerCase().trim();
            if (!keywords.includes(clean)) {
              keywords.push(clean);
            }
          });
        }
      });
    });
  }
  
  // 3. Keywords aus extrahierten Datei-Daten
  if (extractedData) {
    // Aus quantities
    if (extractedData.quantities) {
      Object.entries(extractedData.quantities).forEach(([key, value]) => {
        keywords.push(key.toLowerCase());
        if (value && typeof value === 'number') {
          keywords.push(value.toString());
        }
      });
    }
    
    // Aus materials
    if (extractedData.materials) {
      extractedData.materials.forEach(mat => {
        if (typeof mat === 'string') {
          keywords.push(mat.toLowerCase());
        }
      });
    }
    
    // Aus scope/description
    if (extractedData.scope) {
      const scopeWords = extractedData.scope.toLowerCase().split(/[\s,;.!?]+/);
      scopeWords.forEach(word => {
        const cleanWord = word.replace(/[^a-zäöüß0-9]/gi, '');
        if (cleanWord.length > 3) {
          keywords.push(cleanWord);
        }
      });
    }
  }
  
  // Deduplizieren und zurückgeben
  return [...new Set(keywords)];
}
    
// Hilfsfunktion: Keywords aus User-Scope extrahieren
function extractKeywordsFromScope(scopeText, tradeCode) {
  const keywords = [];
  
  // Basis-Keywords aus dem Text selbst
  const words = scopeText.split(/\s+/);
  
  // Gewerk-spezifische relevante Begriffe
  const tradeKeywordMap = {
  'ELEKT': ['steckdose', 'schalter', 'lampe', 'elektro', 'kabel', 'sicherung', 'strom', 'leitung', 'verteiler', 'fi-schalter'],
  'HEI': ['heizung', 'heizkörper', 'thermostat', 'warmwasser', 'kessel', 'brenner', 'fußbodenheizung', 'radiator'],
  'KLIMA': ['lüftung', 'klima', 'luftwechsel', 'abluft', 'zuluft', 'klimaanlage', 'wärmerückgewinnung'],
  'TRO': ['rigips', 'trockenbau', 'ständerwerk', 'vorwand', 'gipskarton', 'abgehängte decke', 'schallschutz'],
  'FLI': ['fliesen', 'verfugen', 'mosaik', 'bad', 'naturstein', 'feinsteinzeug', 'bodenfliesen', 'wandfliesen'],
  'MAL': ['streichen', 'innenputz', 'tapezieren', 'verputzen', 'spachteln', 'anstrich', 'farbe', 'lackieren', 'grundierung', 'malerarbeiten'],
  'BOD': ['parkett', 'laminat', 'vinyl', 'teppich', 'linoleum', 'kork', 'designboden', 'bodenbelag'],
  'ROH': ['mauerwerk', 'durchbruch', 'beton', 'wand', 'decke', 'maurerarbeiten'],
  'SAN': ['bad', 'wc', 'waschbecken', 'dusche', 'badewanne', 'sanitär', 'abfluss', 'wasserhahn', 'armatur'],
  'FEN': ['fenster', 'verglasung', 'rolladen', 'jalousie', 'fensterbank', 'glasbruch', 'isolierglas'],
  'TIS': ['tür', 'innentür', 'zarge', 'möbel', 'einbauschrank', 'holzarbeiten', 'küche', 'arbeitsplatte'],
  'DACH': ['dach', 'ziegel', 'dachrinne', 'schneefang', 'dachfenster', 'gauben', 'dachstuhl', 'eindeckung'],
  'FASS': ['fassade', 'wdvs', 'außenputz', 'dämmung', 'verblendung', 'klinker', 'fassadenfarbe'],
  'GER': ['gerüst', 'baugerüst', 'arbeitsgerüst', 'fassadengerüst', 'rollgerüst'],
  'ZIMM': ['holzbau', 'gaube', 'dachstuhl', 'balken', 'carport', 'pergola', 'holzkonstruktion', 'fachwerk'],
  'ESTR': ['estrich', 'fließestrich', 'zementestrich', 'anhydritestrich', 'trockenestrich', 'ausgleichsmasse'],
  'SCHL': ['geländer', 'zaun', 'tor', 'metallbau', 'stahltreppe', 'gitter', 'schlosserarbeiten'],
  'AUSS': ['pflaster', 'terrasse', 'einfahrt', 'garten', 'außenanlage', 'randstein', 'rasen'],
  'PV': ['solar', 'photovoltaik', 'solaranlage', 'wechselrichter', 'speicher', 'batterie', 'einspeisung'],
  'ABBR': ['abriss', 'abbruch', 'entkernung', 'rückbau', 'demontage', 'entsorgung', 'schutt']
  };
  
  const relevantTerms = tradeKeywordMap[tradeCode] || [];
  
  // Finde alle relevanten Begriffe im User-Text
  relevantTerms.forEach(term => {
    const regex = new RegExp(term, 'i');
    if (regex.test(scopeText)) {
      keywords.push(term);
      // Auch Plural/Singular-Varianten hinzufügen
      if (!term.endsWith('en') && !scopeText.includes(term + 'en')) {
        keywords.push(term + 'en');
      }
    }
  });
  
  // Extrahiere auch direkte Substantive aus dem Text
  words.forEach(word => {
    const cleanWord = word.replace(/[^a-zäöüß]/gi, '').toLowerCase();
    if (cleanWord.length > 3) {
      keywords.push(cleanWord);
    }
  });
  
  // Dedupliziere
  return [...new Set(keywords)];
}
    
// ERWEITERTE VALIDIERUNG für alle maßrelevanten Bauteile
const dimensionConfig = DIMENSION_REQUIRED_ITEMS[trade.code];
if (dimensionConfig) {
  const hasInvalidPositions = lv.positions.some(pos => {
    const desc = pos.description.toLowerCase();
    // Prüfe ob Position eines der Keywords enthält
    const containsKeyword = dimensionConfig.keywords.some(kw => desc.includes(kw));
    
    // Bei Heizung: Flexiblere Prüfung
    if (trade.code === 'HEI') {
      const hasValidSpec = 
        dimensionConfig.format.test(pos.description) ||
        desc.includes('nach berechnung') ||
        desc.includes('gemäß heizlast') ||
        /\d+\s*watt/i.test(desc) ||
        /typ\s*\d+/i.test(desc);
      
      return containsKeyword && !hasValidSpec;
    }
    
    // Für andere Gewerke: Strikte Maßprüfung
    const hasDimensions = dimensionConfig.format.test(pos.description);
    return containsKeyword && !hasDimensions;
  });
  
  if (hasInvalidPositions) {
    console.error(`[LV] WARNUNG: ${dimensionConfig.itemName}-LV ohne detaillierte Maßangaben erkannt! Regeneriere...`);
    
    // Sammle alle relevanten Maßangaben aus den Antworten
    const dimensionAnswers = tradeAnswers.filter(a => 
      a.answer.match(/\d+\s*x\s*\d+/) || 
      a.answer.match(/\d+\s*(cm|mm|m)/)
    ).map(a => `- ${a.question}: ${a.answer}`).join('\n');
    
    const enhancedPrompt = userPrompt + `\n\nKRITISCH: Die vorherige Generierung hatte ${dimensionConfig.itemName} OHNE Maßangaben!
    
ABSOLUT VERPFLICHTEND für JEDE ${dimensionConfig.itemName}-Position:
- Format: ${dimensionConfig.example}
- Die Maße MÜSSEN aus den erfassten Antworten stammen!

ERFASSTE MAßANGABEN AUS DEN ANTWORTEN:
${dimensionAnswers || 'KEINE MAßANGABEN IN DEN ANTWORTEN GEFUNDEN'}

REGELN:
1. UNTERSCHIEDLICHE Abmessungen = SEPARATE Positionen
2. GLEICHE Abmessungen = EINE Position mit Stückzahl
3. Wenn KEINE Maße in den Antworten: "Maße vor Ort aufzunehmen" vermerken
4. NIEMALS Standardmaße erfinden!

Beispiel RICHTIG:
- "3 Stk. ${dimensionConfig.example}" (gleiche Maße)
- "1 Stk. ${dimensionConfig.itemName} [andere Maße]" (separate Position)

Beispiel FALSCH:
- "${dimensionConfig.itemName} verschiedene Größen"
- Maßangaben erfinden die nicht in den Antworten stehen

WICHTIG: Antworte NUR mit validem JSON!`;
    
    let retryResponse = await llmWithPolicy('lv', [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: enhancedPrompt }
    ], { 
      maxTokens: 16000, 
      temperature: 0.3,
      jsonMode: true
    });
    
    // Bereinige auch die Retry-Response
    retryResponse = retryResponse.trim()
      .replace(/^```(?:json)?\s*\n?/, '')
      .replace(/\n?```\s*$/, '')
      .replace(/^json\s*\n?/i, '');
    
    try {
      lv = JSON.parse(retryResponse);
      console.log(`[LV] ${dimensionConfig.itemName}-LV erfolgreich regeneriert mit Maßangaben`);
    } catch (retryParseError) {
      console.error('[LV] Retry parse failed:', retryParseError.message);
      throw new Error(`LV-Regenerierung für ${trade.name} fehlgeschlagen - Claude lieferte erneut ungültiges JSON`);
    }
  }
}

// Post-Processing: Konsolidiere Demontage und entferne Redundanzen
if (trade.code === 'TIS' && lv.positions) {
  console.log('[LV-TIS] Starting TIS-specific post-processing...');
  
  // 1. Konsolidiere Demontage-Positionen
  const demontagePositionen = lv.positions.filter(p => 
    p.title?.toLowerCase().includes('demontage') && 
    !p.title?.toLowerCase().includes('entsorgung'));
  
  const entsorgungsPositionen = lv.positions.filter(p => 
    p.title?.toLowerCase().includes('entsorgung'));
  
  if (demontagePositionen.length > 1) {
    console.log(`[LV-TIS] Found ${demontagePositionen.length} separate Demontage positions - consolidating...`);
    
    const totalQuantity = demontagePositionen.reduce((sum, p) => 
      sum + (parseFloat(p.quantity) || 0), 0);
    
    const sammelPosition = {
      pos: "01.01",
      title: "Demontage und Entsorgung sämtlicher Alttüren",
      description: "Demontage bestehender Innentüren und Wohnungstür inkl. Türblätter aushängen, Zargen ausbauen, Beschläge demontieren und sortieren. Fachgerechte Entsorgung als Altholz Kategorie A II inkl. Transport zur Entsorgungsanlage.",
      quantity: totalQuantity,
      unit: "Stk",
      unitPrice: 120, // Demontage + Entsorgung kombiniert
      totalPrice: totalQuantity * 120,
      dataSource: "measured",
      notes: `Zusammengefasst aus ${demontagePositionen.length} Einzelpositionen`
    };
    
    // Entferne alte Positionen und füge neue hinzu
    lv.positions = lv.positions.filter(p => 
      !p.title?.toLowerCase().includes('demontage') && 
      !p.title?.toLowerCase().includes('entsorgung'));
    
    lv.positions.unshift(sammelPosition);
    console.log(`[LV-TIS] Created consolidated position for ${totalQuantity} doors`);
  }
  
  // 2. Entferne redundante Montage-Positionen
  const lieferungUndMontageCount = lv.positions.filter(p => 
    p.title?.toLowerCase().includes('lieferung und montage')).length;
  
  if (lieferungUndMontageCount > 0) {
    const redundantMontage = lv.positions.filter(p => {
      const title = p.title?.toLowerCase() || '';
      return (title.includes('montage') || title.includes('justage')) && 
             !title.includes('lieferung') && 
             !title.includes('demontage');
    });
    
    if (redundantMontage.length > 0) {
      console.log(`[LV-TIS] Removing ${redundantMontage.length} redundant Montage positions`);
      lv.positions = lv.positions.filter(p => !redundantMontage.includes(p));
    }
  }
  
  // 3. Neuberechnung der Positionsnummern
  lv.positions = lv.positions.map((pos, index) => ({
    ...pos,
    pos: `${String(index + 1).padStart(2, '0')}.01`
  }));
  
  console.log(`[LV-TIS] Post-processing complete. Final position count: ${lv.positions.length}`);
}

/**
 * Intelligentere Preisvalidierung basierend auf Kontext
 */
function validateAndFixPrices(lv, tradeCode) {
  let fixedCount = 0;
  let warnings = [];
  
  if (!lv.positions || !Array.isArray(lv.positions)) {
    return { lv, fixedCount, warnings };
  }

    // ============== KOMMAFEHLER-ERKENNUNG DURCH VERHÄLTNISMÄSSIGKEIT ==============
  // Regel: Wenn eine Position mehr als 50% der Gesamtsumme ausmacht, prüfe auf Kommafehler
  
  // Berechne Gesamtsumme aller Positionen
  const gesamtSumme = lv.positions.reduce((sum, pos) => sum + (pos.totalPrice || 0), 0);
  
  lv.positions = lv.positions.map(pos => {
    
    // Prüfe ob diese Position unverhältnismäßig teuer ist
    if (pos.totalPrice > gesamtSumme * 0.4 && lv.positions.length > 3) {
      // Diese Position macht mehr als 40% der Gesamtsumme aus (bei mehr als 3 Positionen)
      
      // Berechne Summe OHNE diese Position
      const summeOhnePosition = gesamtSumme - pos.totalPrice;
      
      // Wenn Position mehr als doppelt so teuer wie alle anderen zusammen
      if (pos.totalPrice > summeOhnePosition * 2) {
        console.error(`[KOMMAFEHLER-VERDACHT] Position macht ${((pos.totalPrice/gesamtSumme)*100).toFixed(1)}% der Gesamtsumme aus!`);
        console.error(`  Position: "${pos.title?.substring(0, 60)}..."`);
        console.error(`  Preis: ${pos.unitPrice}€ × ${pos.quantity} = ${pos.totalPrice}€`);
        console.error(`  Summe aller anderen: ${summeOhnePosition}€`);
        
        // Teste Korrektur durch Division
        const kandidaten = [
          { divisor: 100, neuPreis: pos.unitPrice / 100 },
          { divisor: 1000, neuPreis: pos.unitPrice / 1000 },
          { divisor: 10, neuPreis: pos.unitPrice / 10 }
        ];
        
        for (const k of kandidaten) {
          const neueGesamtPosition = k.neuPreis * pos.quantity;
          
          // Prüfe ob korrigierter Preis plausibel wird
          // Sollte maximal 50% der anderen Positionen ausmachen
          if (neueGesamtPosition < summeOhnePosition * 0.5) {
            const oldPrice = pos.unitPrice;
            pos.unitPrice = Math.round(k.neuPreis * 100) / 100;
            pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
            
            console.error(`[KOMMAFEHLER KORRIGIERT] Division durch ${k.divisor}:`);
            console.error(`  ${oldPrice}€ → ${pos.unitPrice}€`);
            console.error(`  Neue Positionssumme: ${pos.totalPrice}€ (${((pos.totalPrice/(summeOhnePosition + pos.totalPrice))*100).toFixed(1)}% der Gesamtsumme)`);
            
            warnings.push(`KOMMAFEHLER behoben bei "${pos.title?.substring(0, 40)}...": ${oldPrice}€ → ${pos.unitPrice}€`);
            fixedCount++;
            break;
          }
        }
      }
    }
    
    // Zusätzlich: Extreme Einzelpreise im Vergleich zum Durchschnitt
    if (pos.unitPrice > 1000 && lv.positions.length > 5) {
      const gleicheEinheit = lv.positions.filter(p => 
        p !== pos && 
        p.unit === pos.unit && 
        p.unitPrice > 0
      );
      
      if (gleicheEinheit.length >= 2) {
        const durchschnitt = gleicheEinheit.reduce((sum, p) => sum + p.unitPrice, 0) / gleicheEinheit.length;
        
        // Wenn Preis mehr als 50x höher als Durchschnitt
        if (pos.unitPrice > durchschnitt * 50) {
          const kandidaten = [
            { divisor: 100, neuPreis: pos.unitPrice / 100 },
            { divisor: 1000, neuPreis: pos.unitPrice / 1000 }
          ];
          
          for (const k of kandidaten) {
            // Neuer Preis sollte maximal 5x Durchschnitt sein
            if (k.neuPreis > durchschnitt * 0.5 && k.neuPreis < durchschnitt * 5) {
              const oldPrice = pos.unitPrice;
              pos.unitPrice = Math.round(k.neuPreis * 100) / 100;
              pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
              
              console.error(`[AUSREISSER KORRIGIERT] ${oldPrice}€ war ${(oldPrice/durchschnitt).toFixed(0)}x Durchschnitt`);
              console.error(`  Korrigiert auf ${pos.unitPrice}€ (${(pos.unitPrice/durchschnitt).toFixed(1)}x Durchschnitt)`);
              
              warnings.push(`Preisausreißer korrigiert: ${oldPrice}€ → ${pos.unitPrice}€`);
              fixedCount++;
              break;
            }
          }
        }
      }
    }
    
    return pos;
  });
  
  // ============== ENDE KOMMAFEHLER-ERKENNUNG ==============
  
  // Neuberechnung der Gesamtsumme nach Korrekturen
  if (fixedCount > 0) {
    const neueGesamtsumme = lv.positions.reduce((sum, pos) => sum + (pos.totalPrice || 0), 0);
    console.log(`[KOMMAFEHLER] Gesamtsumme korrigiert: ${gesamtSumme.toFixed(2)}€ → ${neueGesamtsumme.toFixed(2)}€`);
  }
  
  lv.positions = lv.positions.map(pos => {

  // Entferne Preisspannen und korrigiere Qualitätsbegriffe
    const originalTitle = pos.title || '';
    const originalDesc = pos.description || '';
    const ep = pos.unitPrice || 0;
    
    // Bereinige Titel
    if (pos.title) {
      pos.title = pos.title
        // Entferne Preisspannen
        .replace(/\(\s*\d+\s*-\s*\d+\s*€?\s*\)/g, '')     // (400-1000€)
        .replace(/\(\s*ab\s+\d+\s*€?\s*\)/g, '')          // (ab 500€)
        .replace(/\(\s*bis\s+\d+\s*€?\s*\)/g, '')         // (bis 1000€)
        .replace(/\(\s*ca\.\s*\d+\s*€?\s*\)/g, '')        // (ca. 250€)
        .replace(/\d+\s*-\s*\d+\s*€/g, '')                // 400-1000€ ohne Klammern
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    // Bereinige Beschreibung
    if (pos.description) {
      pos.description = pos.description
        // Entferne Preisspannen
        .replace(/\(\s*\d+\s*-\s*\d+\s*€?\s*\)/g, '')
        .replace(/\(\s*ab\s+\d+\s*€?\s*\)/g, '')
        .replace(/\(\s*bis\s+\d+\s*€?\s*\)/g, '')
        .replace(/\(\s*ca\.\s*\d+\s*€?\s*\)/g, '')
        .replace(/\d+\s*-\s*\d+\s*€/g, '')
        .replace(/\s+/g, ' ')
        .trim();
    }
    
    // Korrigiere Qualitätsbegriffe basierend auf EP
    const fullText = `${pos.title} ${pos.description}`.toLowerCase();
    
    // Bei niedrigen Preisen (<150€): Entferne Premium-Begriffe
    if (ep < 150) {
      if (fullText.includes('premium') || fullText.includes('luxus') || 
          fullText.includes('exklusiv') || fullText.includes('erstklassig')) {
        
        if (pos.title) {
          pos.title = pos.title
            .replace(/Premium(-| )?Qualität/gi, 'Standardausführung')
            .replace(/Premium(-| )?/gi, 'Standard-')
            .replace(/Luxus(-| )?/gi, '')
            .replace(/Exklusiv(-| )?/gi, '')
            .replace(/erstklassig(e|er|es)?/gi, 'solide');
        }
        
        if (pos.description) {
          pos.description = pos.description
            .replace(/Premium(-| )?Qualität/gi, 'Standardausführung')
            .replace(/hochwertig(e|er|es)?/gi, 'solide')
            .replace(/Luxus(-| )?/gi, '')
            .replace(/erstklassig(e|er|es)?/gi, 'bewährt');
        }
        
        warnings.push(`Qualitätsbegriff angepasst bei "${pos.title?.substring(0, 40)}..." (EP: €${ep})`);
        fixedCount++;
      }
    }
    
    // Bei hohen Preisen (>500€): Entferne Standard/Einfach-Begriffe
    else if (ep > 500) {
      if (fullText.includes('standard') || fullText.includes('einfach') || 
          fullText.includes('basis') || fullText.includes('baumarkt')) {
        
        if (pos.title) {
          pos.title = pos.title
            .replace(/Standard(-| )?Qualität/gi, 'gehobene Qualität')
            .replace(/Standard(-| )?/gi, '')
            .replace(/einfach(e|er|es)?/gi, 'hochwertig')
            .replace(/Basis(-| )?/gi, '');
        }
        
        if (pos.description) {
          pos.description = pos.description
            .replace(/Standard(-| )?Ausführung/gi, 'gehobene Ausführung')
            .replace(/Baumarkt(-| )?Qualität/gi, 'Markenqualität')
            .replace(/einfach(e|er|es)?/gi, 'qualitätsvoll');
        }
        
        warnings.push(`Qualitätsbegriff angepasst bei "${pos.title?.substring(0, 40)}..." (EP: €${ep})`);
        fixedCount++;
      }
    }
    
    // Logging bei Änderungen
    if (originalTitle !== pos.title || originalDesc !== pos.description) {
      console.log(`[PRICE-CLEAN] ${tradeCode}: Beschreibung bereinigt`);
      if (originalTitle !== pos.title) {
        console.log(`  Titel: "${originalTitle.substring(0, 50)}..." → "${pos.title?.substring(0, 50)}..."`);
      }
      if (originalDesc !== pos.description) {
        console.log(`  Desc: "${originalDesc.substring(0, 50)}..." → "${pos.description?.substring(0, 50)}..."`);
      }
    }
    
    // Skip Kleinmaterial
    if (pos.title?.toLowerCase().includes('kleinmaterial')) {
  return pos;
}
   
    const titleLower = pos.title?.toLowerCase() || '';
    const descLower = pos.description?.toLowerCase() || '';
    
    // REGEL: "Lieferung und Demontage" ist VERBOTEN
if (titleLower.includes('lieferung') && 
    (titleLower.includes('demontage') || titleLower.includes('rückbau') || titleLower.includes('abbruch'))) {
  
  console.error(`[KRITISCH] Verbotene Kombination "Lieferung" mit Abbruch/Demontage`);
  
  // Entscheide basierend auf Beschreibung was gemeint ist
  if (descLower.includes('bestehend') || descLower.includes('alt') || descLower.includes('demontage')) {
    // Es geht um DEMONTAGE - entferne "Lieferung"
    pos.title = pos.title.replace(/Lieferung\s+(und\s+)?/gi, '');
    warnings.push(`"Lieferung" entfernt - Position betrifft Demontage`);
  } else if (descLower.includes('neu') || descLower.includes('montage')) {
    // Es geht um NEULIEFERUNG - ersetze "Demontage" mit "Montage"
    pos.title = pos.title.replace(/Demontage/gi, 'Montage')
                         .replace(/Rückbau/gi, 'Einbau')
                         .replace(/Abbruch/gi, 'Montage');
    warnings.push(`Demontage-Begriffe zu Montage korrigiert`);
  } else {
    // Im Zweifel: Nur "Lieferung" entfernen
    pos.title = pos.title.replace(/Lieferung\s+(und\s+)?/gi, '');
    warnings.push(`"Lieferung" entfernt aus unklarer Position`);
  }
  
  fixedCount++;
}

if (tradeCode === 'TRO') {
  // PREISVALIDIERUNG - Nur die 2 Hauptpositionen
  lv.positions = lv.positions.map(pos => {
    const titleLower = (pos.title || '').toLowerCase();
    const unit = (pos.unit || '').toLowerCase();
    let minPrice = null;
    let reason = '';
    
    // Ständerwerk CW/UW Profile (Material + Montage)
    if ((titleLower.includes('ständerwerk') || titleLower.includes('cw') || titleLower.includes('uw')) && 
        (unit === 'm²' || unit === 'm2')) {
      minPrice = 25;
      reason = 'Ständerwerk inkl. Montage';
    }
    
    // Beplankung GKB/GKBI/GKF (Material + Montage)
    else if ((titleLower.includes('beplanken') || titleLower.includes('beplankung') || 
              titleLower.includes('gipskarton') || titleLower.includes('gkb') || 
              titleLower.includes('gkbi') || titleLower.includes('gkf')) && 
             (unit === 'm²' || unit === 'm2')) {
      minPrice = 22;
      reason = 'Beplankung';
    }
    
    // Preiskorrektur wenn zu niedrig
    if (minPrice && pos.unitPrice < minPrice) {
      console.warn(`[TRO] Preiskorrektur "${pos.title}": ${pos.unitPrice}€ -> ${minPrice}€ (${reason})`);
      pos.unitPrice = minPrice;
      pos.totalPrice = Math.round(pos.quantity * minPrice * 100) / 100;
      pos.notes = (pos.notes || '') + ` | Preis korrigiert (min. ${minPrice}€/${unit} für ${reason})`;
      fixedCount++;
    }
    
    return pos;
  });
  
  // Tischlerarbeiten rausfiltern (gehören NICHT zu Trockenbau)
  const vorher = lv.positions.length;
  lv.positions = lv.positions.filter(pos => {
    const titleLower = (pos.title || '').toLowerCase();
    
    if (titleLower.includes('zarge') || titleLower.includes('türblatt') || 
        titleLower.includes('türbeschlag') || titleLower.includes('türdrücker')) {
      console.warn(`[TRO] Entferne Position (gehört zu Tischler): "${pos.title}"`);
      return false;
    }
    
    return true;
  });
  
  if (vorher !== lv.positions.length) {
    console.log(`[TRO] ${vorher - lv.positions.length} Nicht-Trockenbau-Positionen entfernt`);
  }
}    
    // NEUE REGEL: Vorwandinstallation NUR bei Trockenbau
    if (tradeCode !== 'TRO' && 
        (titleLower.includes('vorwand') || descLower.includes('vorwandinstallation'))) {
      console.error(`[KRITISCH] Vorwandinstallation in ${tradeCode} statt TRO`);
      
      if (tradeCode === 'SAN') {
        pos.title = pos.title.replace(/vorwand.*installation/gi, 'Unterputz-Installation');
        pos.description = pos.description?.replace(/vorwand/gi, 'Unterputz');
        warnings.push(`Vorwandinstallation in SAN korrigiert zu Unterputz`);
        fixedCount++;
      } else {
        // Bei anderen Gewerken: Position markieren
        pos._remove = true;
      }
    }
    
    // 1. NEUE REGEL: Entsorgungskosten prüfen
    if (titleLower.includes('entsorg') || 
        titleLower.includes('abtransport') ||
        titleLower.includes('abfuhr') ||
        titleLower.includes('demontage und entsorgung')) {
      
      // Entsorgung pro Stück (Fenster, Türen, etc.)
      if (pos.unit === 'Stk' && pos.unitPrice > 100) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = titleLower.includes('demontage') ? 120 : 40; // 120€ wenn Demontage dabei, sonst 40€
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Entsorgung/Stück korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
      
      // Entsorgung pro m³
      if (pos.unit === 'm³' && pos.unitPrice > 200) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = 120; // Realistisch für Bauschutt
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Entsorgung/m³ korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
      
      // Entsorgung pauschal
      if (pos.unit === 'psch' && pos.unitPrice > 2000) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = 800; // Maximal für Pauschal-Entsorgung
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Entsorgung/pauschal korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
    }
    
    // 2. VERBESSERTE REGEL: Putzarbeiten und Ausbesserungen
if (titleLower.includes('putz') || 
    titleLower.includes('laibung') || 
    titleLower.includes('leibung') ||  // NEU: beide Schreibweisen
    titleLower.includes('spachtel') ||
    titleLower.includes('glätten') ||
    titleLower.includes('ausbesser')) {
  
  // NEU: Spezialfall Leibungsverputz nach Fenstermontage
  if ((titleLower.includes('leibung') || titleLower.includes('laibung')) && 
      titleLower.includes('verputz')) {
    if (pos.unit === 'm' && pos.unitPrice > 45) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 35;  // Speziell für Leibungsverputz
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Leibungsverputz korrigiert: €${oldPrice}/m → €35/m`);
      fixedCount++;
    }
  }
  // Normale Putzarbeiten pro lfd. Meter
  else if (pos.unit === 'm' && pos.unitPrice > 80) {
    const oldPrice = pos.unitPrice;
    pos.unitPrice = 45;
    pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
    warnings.push(`Putzarbeit/m korrigiert: €${oldPrice}/m → €${pos.unitPrice}/m`);
    fixedCount++;
  }
  
  // Für Quadratmeter (z.B. Wandflächen)
  else if (pos.unit === 'm²' && pos.unitPrice > 60) {
    const oldPrice = pos.unitPrice;
    pos.unitPrice = 35; // Etwas günstiger pro m² als pro laufenden Meter
    pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
    warnings.push(`Putzarbeit/m² korrigiert: "${pos.title}": €${oldPrice}/m² → €${pos.unitPrice}/m²`);
    fixedCount++;
  }
  
  // Für Pauschalpreise (kleine Ausbesserungen)
  else if (pos.unit === 'psch' && pos.unitPrice > 500) {
    const oldPrice = pos.unitPrice;
    pos.unitPrice = 250;
    pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
    warnings.push(`Ausbesserung pauschal korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
    fixedCount++;
  }
}
    
    // 3. ERWEITERTE REGEL: Nebenleistungen mit intelligenter Mengenerkennung
const EXPENSIVE_EQUIPMENT_KEYWORDS = [
  'kran', 'gerüst', 'bagger', 'aufzug', 'hebebühne', 
  'spezialgerät', 'schwerlast', 'transport'
];

const isSpecialEquipment = EXPENSIVE_EQUIPMENT_KEYWORDS.some(keyword => 
  titleLower.includes(keyword)
);

const isNebenleistung = 
  titleLower.includes('anschluss') ||
  titleLower.includes('abdichtung') ||
  titleLower.includes('laibung') ||
  titleLower.includes('leibung') ||
  titleLower.includes('befestigung') ||
  titleLower.includes('dämmstreifen') ||
  titleLower.includes('anarbeiten');

// NEU: Intelligente Mengenprüfung für Nebenleistungen
if (isNebenleistung && pos.unit === 'm') {
  const fensterPositionen = lv.positions.filter(p => 
    p.title?.toLowerCase().includes('fenster') && 
    !p.title?.toLowerCase().includes('bank') &&
    p.unit === 'Stk'
  );
  
  if (fensterPositionen.length > 0) {
    const totalFenster = fensterPositionen.reduce((sum, p) => sum + (p.quantity || 0), 0);
    const erwarteteLeibungsMeter = totalFenster * 3;
    
    if (titleLower.includes('leibung') && pos.quantity > erwarteteLeibungsMeter * 2) {
      const oldQuantity = pos.quantity;
      pos.quantity = Math.round(erwarteteLeibungsMeter * 10) / 10;
      warnings.push(`Leibungsmenge korrigiert: ${oldQuantity}m → ${pos.quantity}m`);
      fixedCount++;
    }
  }
}

// Preiskorrektur für Nebenleistungen
if (isNebenleistung && !isSpecialEquipment && pos.unit !== 'psch') {
  const maxPreise = {
    'leibung': { m: 45, m2: 60 },
    'laibung': { m: 45, m2: 60 },
    'abdichtung': { m: 40, m2: 55 },
    'anschluss': { m: 60, m2: 80 },
    'befestigung': { m: 30, Stk: 25 },
    'dämmstreifen': { m: 15, m2: 25 }
  };
  
  Object.entries(maxPreise).forEach(([keyword, limits]) => {
    if (titleLower.includes(keyword) && limits[pos.unit]) {
      if (pos.unitPrice > limits[pos.unit]) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = limits[pos.unit];
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`${keyword} korrigiert: €${oldPrice}/${pos.unit} → €${pos.unitPrice}/${pos.unit}`);
        fixedCount++;
      }
    }
  });
}

// WICHTIGE REGEL BLEIBT ERHALTEN: Warnung bei teuren Spezialleistungen
if (isSpecialEquipment && pos.unitPrice > 1000) {
  console.log(`[PRICE-CHECK] Spezialleistung erkannt: "${pos.title}" - €${pos.unitPrice} (keine Korrektur)`);
  if (pos.unitPrice > 5000) {
    warnings.push(`REVIEW: Hoher Preis für Spezialleistung "${pos.title}": €${pos.unitPrice}`);
  }
}
    
    // 4. BESTEHENDE REGEL: Hauptpositionen Mindestpreise
    const isMainPosition = 
      titleLower.includes('fenster') && !titleLower.includes('entsorg') ||
      titleLower.includes('tür') && !titleLower.includes('entsorg') ||
      titleLower.includes('heizung') ||
      titleLower.includes('sanitär');
    
    if (isMainPosition && pos.unitPrice < 50) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 50;  
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;  
      warnings.push(`Mindestpreis: €${oldPrice} → €50`);  
      fixedCount++;  
      }  
                               
// ZUSÄTZLICHE REGEL: KEINE PREISE UNTER 10€ (außer Kleinmaterial)
if (!titleLower.includes('kleinmaterial') && 
    !titleLower.includes('befestigungsmaterial') &&
    pos.unitPrice < 10 && 
    pos.unit === 'Stk') {
  const oldPrice = pos.unitPrice;
  
  // Bestimme Mindestpreis basierend auf Gewerk
  let minPrice = 50; // Default
  
  if (tradeCode === 'TIS') minPrice = 250;
  if (tradeCode === 'FEN') minPrice = 400;
  if (tradeCode === 'SAN') minPrice = 150;
  if (tradeCode === 'ELEKT') minPrice = 30;
  
  pos.unitPrice = minPrice;
  pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
  warnings.push(`Unrealistischer Preis korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
  fixedCount++;
}

// GENERELLE REGEL: Wiederverwendbare Materialien werden NICHT entsorgt
const wiederverwendbareItems = [
  'gerüst', 'baustütze', 'abstützung', 'unterzug', 
  'schalung', 'rüstung', 'stützbock', 'stempel',
  'träger', 'sprieß', 'temporär', 'provisorisch'
];

const istWiederverwendbar = wiederverwendbareItems.some(item => 
  titleLower.includes(item)
);

if (istWiederverwendbar && titleLower.includes('entsorgung')) {
  // Ersetze "Entsorgung" mit korrekten Begriffen
  pos.title = pos.title
    .replace(/Demontage\s+und\s+Entsorgung/gi, 'Demontage')
    .replace(/und\s+Entsorgung/gi, 'und Abtransport')
    .replace(/Entsorgung/gi, 'Rückgabe');
  
  if (pos.description) {
    pos.description = pos.description
      .replace(/Entsorgung/gi, 'Abtransport')
      .replace(/entsorgt/gi, 'abtransportiert');
  }
  
  console.error(`[KRITISCH] "Entsorgung" bei wiederverwendbarem Material: ${pos.title}`);
  warnings.push(`"Entsorgung" korrigiert - ${wiederverwendbareItems.find(item => titleLower.includes(item))} wird wiederverwendet`);
  fixedCount++;
}

// Spezifisch für Abstützungen
if (titleLower.includes('abstützung') || titleLower.includes('baustütze')) {
  if (pos.unit === 'psch' && pos.unitPrice > 500) {
    const oldPrice = pos.unitPrice;
    pos.unitPrice = 380; // Realistisch für Demontage
    pos.totalPrice = pos.unitPrice;
    warnings.push(`Abstützung Demontage: €${oldPrice} → €380`);
    fixedCount++;
  }
}
    
// NEUE REGEL: Gewerk-spezifische Begriffskorrekturen
if (tradeCode === 'MAL') {
  // Maler liefern NICHTS - nur Oberflächenbearbeitung
  if (titleLower.includes('lieferung')) {
    // Entferne "Lieferung und" komplett
    pos.title = pos.title.replace(/Lieferung\s+(und\s+)?/gi, '');
    
    // Falls nur "Lieferung" übrig bleibt, ersetze komplett
    if (pos.title.trim() === '') {
      pos.title = 'Oberflächenbehandlung';
    }
    
    warnings.push(`Maler: "Lieferung" entfernt aus "${originalTitle}"`);
    fixedCount++;
  }
  
  // Maler-typische Leistungen sicherstellen
  if (titleLower.includes('fenster') && !titleLower.includes('anstrich') && 
      !titleLower.includes('lackier') && !titleLower.includes('streich')) {
    pos.title += ' - Anstrich und Lackierung';
    warnings.push(`Maler: Leistungsbeschreibung präzisiert`);
    fixedCount++;
  }
}

// Ähnlich für andere Gewerke
if (tradeCode === 'ELEK') {
  // Elektriker liefern keine Fenster/Türen
  if ((titleLower.includes('fenster') || titleLower.includes('tür')) && 
      titleLower.includes('lieferung')) {
    pos.title = pos.title.replace(/Lieferung\s+(und\s+)?Montage/gi, 'Installation');
    warnings.push(`Elektriker: Falsche Leistung korrigiert`);
    fixedCount++;
  }
}
    
    // SPEZIAL-REGEL FÜR GERÜST
if (tradeCode === 'GER') {
  // NEU: "Entsorgung" bei Gerüst entfernen
  if (titleLower.includes('entsorgung')) {
    pos.title = pos.title.replace(/und\s+Entsorgung/gi, '');
    if (pos.description) {
      pos.description = pos.description.replace(/Entsorgung/gi, 'Abtransport');
    }
    warnings.push(`Gerüst: "Entsorgung" entfernt (Gerüste werden wiederverwendet)`);
    fixedCount++;
  }
  
  // NEU: Prüfe auf doppelte Abbau-Position
  const hatHauptposition = lv.positions.some(p => 
    p.title?.toLowerCase().includes('auf') && 
    p.title?.toLowerCase().includes('abbau')
  );
  
  if (hatHauptposition && 
      (titleLower.includes('demontage') || titleLower.includes('abbau')) && 
      !titleLower.includes('auf') && 
      !titleLower.includes('besenrein')) {
    pos._remove = true;
    warnings.push(`Gerüst-Abbau bereits in Auf-/Abbau enthalten - Position entfernt`);
    fixedCount++;
    return pos;
  }
  
  // BESTEHENDE REGELN
  if (titleLower.includes('auf') && titleLower.includes('abbau') || 
      titleLower.includes('gerüst') && titleLower.includes('montage')) {
    if (pos.unit === 'm²' && pos.unitPrice > 15) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 10;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Gerüst Auf-/Abbau korrigiert: €${oldPrice}/m² → €${pos.unitPrice}/m²`);
      fixedCount++;
    }
  }
  
  if (titleLower.includes('standzeit') || titleLower.includes('miete')) {
    if (pos.unit === 'm²' && pos.unitPrice > 10) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 5;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Gerüst Standzeit korrigiert: €${oldPrice}/m² → €${pos.unitPrice}/m²`);
      fixedCount++;
    }
  }
}

    // SPEZIAL-REGEL FÜR FENSTER-DEMONTAGE
if (tradeCode === 'FEN' && lv.positions) {
  // Sammle alle Demontage-Positionen
  const demontagePositions = lv.positions.filter(pos => 
    pos.title?.toLowerCase().includes('demontage') && 
    pos.title?.toLowerCase().includes('fenster')
  );
  
  if (demontagePositions.length > 1) {
    console.warn(`[FEN] Konsolidiere ${demontagePositions.length} Demontage-Positionen zu einer`);
    
    // Berechne Gesamtmenge
    const totalQuantity = demontagePositions.reduce((sum, pos) => 
      sum + (pos.quantity || 0), 0
    );
    
    // Erstelle eine konsolidierte Position
    const consolidatedDemontage = {
      pos: demontagePositions[0].pos,
      title: 'Demontage und Entsorgung sämtlicher Altfenster',
      description: 'Fachgerechte Demontage aller Bestandsfenster inkl. Entsorgung und Recycling gemäß Abfallverordnung',
      quantity: totalQuantity,
      unit: 'Stk',
      unitPrice: 60, // Realistischer Preis
      totalPrice: totalQuantity * 60,
      dataSource: 'consolidated'
    };
    
    // Entferne alte Positionen und füge neue hinzu
    lv.positions = lv.positions.filter(pos => 
      !demontagePositions.includes(pos)
    );
    lv.positions.unshift(consolidatedDemontage); // Am Anfang einfügen
    
    fixedCount++;
    warnings.push(`Fenster-Demontage zu Sammelposition konsolidiert`);
  }
}    

// SPEZIAL-REGEL FÜR ZIMMERER - VOLLSTÄNDIG ERWEITERT
if (tradeCode === 'ZIMM') {
  
  // KRITISCHE REGEL: Sparren, Latten, Balken - Maximalpreise
  if (titleLower.includes('sparren') || 
      titleLower.includes('latte') || 
      titleLower.includes('balken') ||
      titleLower.includes('pfette') ||
      titleLower.includes('schwelle')) {
    
    // Stückpreise - niemals über 200€
    if (pos.unit === 'Stk') {
      let maxPrice = 120;
      if (titleLower.includes('gaube')) maxPrice = 150;
      if (titleLower.includes('kehl')) maxPrice = 95;
      if (titleLower.includes('dach') && titleLower.includes('sparren')) maxPrice = 95;
      
      if (pos.unitPrice > maxPrice) {
        const oldPrice = pos.unitPrice;
        // Prüfe ob Kommafehler (9500 statt 95.00)
        if (pos.unitPrice > 1000) {
          pos.unitPrice = Math.round(pos.unitPrice / 100);
        } else {
          pos.unitPrice = maxPrice;
        }
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Holzbauteil/Stk korrigiert: €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
    }
    
    // Laufende Meter - niemals über 80€
    if (pos.unit === 'm' || pos.unit === 'lfd.m') {
      let maxPrice = 45;
      if (titleLower.includes('pfette')) maxPrice = 80;
      if (titleLower.includes('schwelle')) maxPrice = 60;
      
      if (pos.unitPrice > maxPrice) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = maxPrice;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Holzbauteil/m korrigiert: €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
    }
    
    // Quadratmeter - niemals über 200€
    if (pos.unit === 'm²') {
      let maxPrice = 150;
      if (titleLower.includes('lattung')) maxPrice = 35;
      if (titleLower.includes('schalung')) maxPrice = 45;
      
      if (pos.unitPrice > maxPrice) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = maxPrice;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Holzbauteil/m² korrigiert: €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
    }
  }
  
  // NEUE REGEL: Keine doppelten Gaube-Positionen
  const hatGaubeKomplett = lv.positions.some(p => 
    p.title?.toLowerCase().includes('gaube') && 
    (p.title?.toLowerCase().includes('komplett') || 
     p.title?.toLowerCase().includes('konstruktion komplett'))
  );
  
  if (hatGaubeKomplett) {
    // Entferne Einzelpositionen wenn "komplett" vorhanden
    if ((titleLower.includes('gaubenwange') || 
         titleLower.includes('gaubensparren') || 
         titleLower.includes('gauben-first') ||
         titleLower.includes('gaubendach-sparren')) &&
        !titleLower.includes('komplett')) {
      console.warn(`[ZIMM] Doppelte Gaube-Position entfernt: ${pos.title}`);
      pos._remove = true;
      warnings.push(`Doppelte Position entfernt (in "Gaube komplett" enthalten)`);
      fixedCount++;
    }
  }
  
  // Dachstuhl-Preiskorrektur (bestehend)
  if (titleLower.includes('dachstuhl')) {
    if (pos.unit === 'm²' && pos.unitPrice > 250) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 180;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Dachstuhl korrigiert: €${oldPrice}/m² → €${pos.unitPrice}/m²`);
      fixedCount++;
    }
  }
  
  // VERBESSERTE REGEL: Gaubenkonstruktion mit Größenberechnung
  if (titleLower.includes('gaube')) {
    if (titleLower.includes('konstruktion') || 
        titleLower.includes('erstellen') || 
        titleLower.includes('sparren') ||
        titleLower.includes('zimmermann')) {
      
      // Extrahiere Größe aus Beschreibung
      const sizeMatch = (pos.title + ' ' + pos.description).match(/(\d+(?:[,\.]\d+)?)\s*m/);
      const width = sizeMatch ? parseFloat(sizeMatch[1].replace(',', '.')) : 2.5; // Default 2.5m
      
      // Grundpreis nach Gaubentyp
      let basePrice;
      if (titleLower.includes('schlepp')) {
        basePrice = 3500; // pro Meter Breite
      } else if (titleLower.includes('sattel') || titleLower.includes('giebel')) {
        basePrice = 4000; // pro Meter Breite
      } else if (titleLower.includes('walm')) {
        basePrice = 4500; // pro Meter Breite
      } else if (titleLower.includes('fledermaus')) {
        basePrice = 5000; // pro Meter Breite
      } else {
        basePrice = 3800; // Standard
      }
      
      // Berechne Preis basierend auf Breite
      const calculatedPrice = Math.round(basePrice * width);
      
      // Preiskorrektur wenn nötig
      if (pos.unit === 'Stk' && (pos.unitPrice < calculatedPrice * 0.7 || pos.unitPrice > calculatedPrice * 1.5)) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = calculatedPrice;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Gaube ${width}m (${titleLower.includes('schlepp') ? 'Schlepp' : 'Standard'}): €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
      
      // Wenn Einheit m² ist, umrechnen
      if (pos.unit === 'm²') {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = 650; // Pauschale für Gaube pro m²
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Gaube/m² korrigiert: €${oldPrice}/m² → €650/m²`);
        fixedCount++;
      }
    }
  }
  
  // NEU: Kehlbalken - niemals über 150€ pro Stück
  if (titleLower.includes('kehlbalken')) {
    if (pos.unit === 'Stk' && pos.unitPrice > 150) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 95;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Kehlbalken korrigiert: €${oldPrice} → €95/Stk`);
      fixedCount++;
    }
  }
  
  // NEU: Wechselkonstruktion - realistischer Preis
  if (titleLower.includes('wechsel') && titleLower.includes('konstruktion')) {
    if (pos.unit === 'Stk' && pos.unitPrice > 1500) {
      const oldPrice = pos.unitPrice;
      const sizeMatch = (pos.title + ' ' + pos.description).match(/(\d+(?:[,\.]\d+)?)\s*m/);
      const width = sizeMatch ? parseFloat(sizeMatch[1].replace(',', '.')) : 2.0;
      pos.unitPrice = Math.round(350 * width); // ~350€ pro Meter
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Wechselkonstruktion ${width}m: €${oldPrice} → €${pos.unitPrice}`);
      fixedCount++;
    }
  }
  
  // NEU: Gaubenwangen - max 600€ pro Stück
  if (titleLower.includes('gaubenwange')) {
    if (pos.unit === 'Stk' && (pos.unitPrice < 300 || pos.unitPrice > 600)) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 420;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Gaubenwangen korrigiert: €${oldPrice} → €420/Stk`);
      fixedCount++;
    }
  }
  
  // NEU: Sparrenverstärkung - max 250€ pro Stück
  if (titleLower.includes('verstärkung') && titleLower.includes('sparren')) {
    if (pos.unit === 'Stk' && pos.unitPrice > 250) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 180;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Sparrenverstärkung korrigiert: €${oldPrice} → €180/Stk`);
      fixedCount++;
    }
  }
  
  // NEU: Begutachtung/Statik - Pauschale max 1500€
  if (titleLower.includes('begutachtung') || titleLower.includes('statisch')) {
    if (pos.unit === 'psch' && pos.unitPrice > 1500) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 850;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Statische Begutachtung korrigiert: €${oldPrice} → €850`);
      fixedCount++;
    }
  }
  
  // NEU: Kranstellung - Tagespreis max 1200€
  if (titleLower.includes('kran')) {
    if (pos.unit === 'Tag' && pos.unitPrice > 1200) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 850;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Kranstellung korrigiert: €${oldPrice} → €850/Tag`);
      fixedCount++;
    }
  }
  
  // NEU: Windrispen - max 40€/m
  if (titleLower.includes('windrisp') || titleLower.includes('aussteifung')) {
    if (pos.unit === 'lfd.m' && pos.unitPrice > 40) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 22;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Windrispen korrigiert: €${oldPrice} → €22/m`);
      fixedCount++;
    }
  }
  
  // Dachlatten und Unterkonstruktion (bestehend)
  if (titleLower.includes('dachlatte') || titleLower.includes('lattung')) {
    if (pos.unit === 'm²' && pos.unitPrice > 35) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 25;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Dachlattung korrigiert: €${oldPrice}/m² → €25/m²`);
      fixedCount++;
    }
  }
  
  // Carport/Überdachung mit Größenfaktor (bestehend)
  if (titleLower.includes('carport') || titleLower.includes('überdachung')) {
    const areaMatch = (pos.title + ' ' + pos.description).match(/(\d+)\s*m²/);
    const area = areaMatch ? parseInt(areaMatch[1]) : 20; // Default 20m²
    
    // Kleinere Flächen sind teurer pro m²
    let pricePerSqm = area < 15 ? 300 : area < 30 ? 250 : 200;
    
    if (pos.unit === 'm²' && pos.unitPrice > pricePerSqm * 1.3) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = pricePerSqm;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Carport ${area}m²: €${oldPrice}/m² → €${pricePerSqm}/m²`);
      fixedCount++;
    }
  }
  
  // Holzbalkendecke (bestehend)
  if (titleLower.includes('holzbalkendecke') || titleLower.includes('balkendecke')) {
    if (pos.unit === 'm²' && pos.unitPrice > 200) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 150;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Holzbalkendecke korrigiert: €${oldPrice}/m² → €150/m²`);
      fixedCount++;
    }
  }
  
  // NEU: Allgemeine Holzkonstruktion m² Preise
  if (pos.unit === 'm²' && !titleLower.includes('dachstuhl')) {
    const maxPreise = {
      'gaubendach': 150,
      'gaubenstirnwand': 120,
      'holzrahmenbau': 180,
      'schalung': 45,
      'lattung': 25
    };
    
    Object.entries(maxPreise).forEach(([keyword, maxPrice]) => {
      if (titleLower.includes(keyword) && pos.unitPrice > maxPrice * 1.2) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = maxPrice;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`${keyword} korrigiert: €${oldPrice}/m² → €${maxPrice}/m²`);
        fixedCount++;
      }
    });
  }
  
  // FEHLERHAFTE POSITIONEN entfernen (bestehend)
  if (titleLower.includes('eindeckung') || 
      titleLower.includes('dachziegel') || 
      titleLower.includes('dachstein')) {
    console.error(`[KRITISCH] Eindeckung bei ZIMM statt DACH`);
    pos._remove = true;
    warnings.push(`Eindeckung gehört zu DACHDECKER`);
    fixedCount++;
  }
}

  // ZUSÄTZLICH: Dachdecker darf keine Zimmererarbeiten haben
if (tradeCode === 'DACH') {
  // Dachdecker macht KEINE Holzkonstruktionen
  if ((titleLower.includes('gaube') && titleLower.includes('erstellen')) ||
      titleLower.includes('dachstuhl') ||
      titleLower.includes('sparren') ||
      titleLower.includes('zimmermann') ||
      titleLower.includes('holzkonstruktion')) {
    
    console.error(`[KRITISCH] Zimmererarbeit bei DACH`);
    pos._remove = true;
    pos._moveToTrade = 'ZIMM';
    warnings.push(`Holzkonstruktion gehört zu ZIMMERER`);
    fixedCount++;
  }
}
    
  // SPEZIAL-REGEL FÜR ROHBAU - Betonstahl-Preise
if (tradeCode === 'ROH') {
  // Betonstahl BSt 500 - Stabstahl
  if ((titleLower.includes('betonstahl') || titleLower.includes('bst 500')) && 
      !titleLower.includes('matte')) {
    
    // Prüfe ob Einheit kg ist
    if (pos.unit === 'kg') {
      const korrektPreis = 1.85; // €/kg für Stabstahl
      
      if (pos.unitPrice < korrektPreis * 0.8 || pos.unitPrice > korrektPreis * 1.5) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = korrektPreis;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Betonstahl BSt 500 korrigiert: ${oldPrice}€/kg → ${korrektPreis}€/kg`);
        fixedCount++;
      }
    }
  }
  
  // Betonstahlmatten
  if (titleLower.includes('betonstahlmatte') || 
      (titleLower.includes('matte') && titleLower.includes('stahl'))) {
    
    if (pos.unit === 'kg' || pos.unit === 'm²') {
      const korrektPreis = pos.unit === 'kg' ? 2.20 : 35.00; // €/kg oder €/m²
      
      if (pos.unitPrice < korrektPreis * 0.8 || pos.unitPrice > korrektPreis * 1.5) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = korrektPreis;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Betonstahlmatten korrigiert: ${oldPrice}€/${pos.unit} → ${korrektPreis}€/${pos.unit}`);
        fixedCount++;
      }
    }
  }
  
  // Weitere Rohbau-Preise
  const rohbauPreise = {
    'beton c25/30': { unit: 'm³', price: 135 },
    'beton c20/25': { unit: 'm³', price: 125 },
    'schalung': { unit: 'm²', price: 45 },
    'mauerwerk': { unit: 'm²', price: 95 },
    'poroton': { unit: 'm²', price: 85 },
    'kalksandstein': { unit: 'm²', price: 75 }
  };
  
  // Prüfe gegen definierte Preise
  Object.entries(rohbauPreise).forEach(([material, config]) => {
    if (titleLower.includes(material) && pos.unit === config.unit) {
      if (pos.unitPrice < config.price * 0.7 || pos.unitPrice > config.price * 1.3) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = config.price;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`${material} korrigiert: ${oldPrice}€/${config.unit} → ${config.price}€/${config.unit}`);
        fixedCount++;
      }
    }
  });
}
    
    // 5. GENERELLE ABSURDITÄTSPRÜFUNG
    if (pos.unit === 'm' && pos.unitPrice > 500) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 80;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Absurder Preis/m korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
      fixedCount++;
    }
    
    if (pos.unit === 'm²' && pos.unitPrice > 500) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 120;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      warnings.push(`Absurder Preis/m² korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
      fixedCount++;
    }
    
    // 6. NEUE REGEL: Demontage darf nicht teurer als Montage sein
    if (titleLower.includes('demontage') || titleLower.includes('ausbau')) {
      // Demontage maximal 30% der Montage
      if (pos.unit === 'Stk' && pos.unitPrice > 200) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = 80; // Pauschal für Demontage
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Demontage korrigiert: "${pos.title}": €${oldPrice} → €${pos.unitPrice}`);
        fixedCount++;
      }
    }
    
    return pos;
  }).filter(pos => !pos._remove); 
  
  // Neuberechnung der Gesamtsumme wenn Änderungen
  if (fixedCount > 0) {
    const newTotal = lv.positions.reduce((sum, pos) => sum + (pos.totalPrice || 0), 0);
    lv.totalSum = Math.round(newTotal * 100) / 100;
  }
  
  if (warnings.length > 0) {
    console.warn(`[PRICE-CHECK] ${tradeCode}: ${fixedCount} kritische Preise korrigiert`);
    warnings.forEach(w => console.warn(`  - ${w}`));
  }

  // Rechenfehler IMMER korrigieren
lv.positions = lv.positions.map(pos => {
  const sollSumme = Math.round((pos.quantity || 0) * (pos.unitPrice || 0) * 100) / 100;
  if (Math.abs((pos.totalPrice || 0) - sollSumme) > 0.01) {
    console.error(`[RECHENFEHLER] "${pos.title}": ${pos.quantity} × ${pos.unitPrice} = ${sollSumme} (war: ${pos.totalPrice})`);
    pos.totalPrice = sollSumme;
    fixedCount++;
  }
  return pos;
});

// Verhältnismäßigkeiten prüfen
if (tradeCode === 'FEN') {
  const fensterBanks = lv.positions.filter(p => p.title?.toLowerCase().includes('fensterbank'));
  const leibungen = lv.positions.filter(p => 
    p.title?.toLowerCase().includes('leibung') || p.title?.toLowerCase().includes('laibung')
  );
  
  if (fensterBanks.length > 0 && leibungen.length > 0) {
    const avgBankMeter = fensterBanks.reduce((sum, p) => sum + p.quantity, 0) / fensterBanks.length;
    leibungen.forEach(pos => {
      // Leibungen sollten 2-3x mehr Meter haben als Fensterbänke
      if (Math.abs(pos.quantity - avgBankMeter) < 1) { // Fast identisch = Problem
        pos.quantity = Math.round(avgBankMeter * 2.5 * 10) / 10;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        warnings.push(`Leibungsmenge angepasst auf ${pos.quantity}m`);
        fixedCount++;
      }
    });
  }
}

  // Nach der Rechenfehler-Korrektur
if (fixedCount > 0) {
  const newTotal = lv.positions.reduce((sum, pos) => sum + (pos.totalPrice || 0), 0);
  lv.totalSum = Math.round(newTotal * 100) / 100;
}
  
  return { lv, fixedCount, warnings };
}
    
// NEUE PREISVALIDIERUNG - HIER EINFÜGEN (Zeile 1921)
const priceValidation = validateAndFixPrices(lv, trade.code);
if (priceValidation.fixedCount > 0) {
  console.warn(`[LV] Fixed ${priceValidation.fixedCount} unrealistic prices for ${trade.code}`);
  lv = priceValidation.lv;
}
    
    // Duplikatsprüfung durchführen
const duplicates = await checkForDuplicatePositions(projectId, tradeId, lv.positions);

if (duplicates.length > 0) {
  console.log(`Warnung: ${duplicates.length} potenzielle Duplikate gefunden für ${trade.name}`);
  
  // Prüfe ob spezialisierte Gewerke vorhanden sind
  const specializedTrades = await query(
    `SELECT code FROM trades t 
     JOIN project_trades pt ON t.id = pt.trade_id 
     WHERE pt.project_id = $1 AND t.code IN ('GERÜST', 'ABBR', 'ENTSO')`,
    [projectId]
  );
  
  const hasGerüstbau = specializedTrades.rows.some(t => t.code === 'GERÜST');
  const hasAbbruch = specializedTrades.rows.some(t => t.code === 'ABBR');
  
  // Filtere Duplikate basierend auf Gewerke-Hierarchie
  lv.positions = lv.positions.filter(pos => {
    // Entferne Gerüstpositionen wenn Gerüstbau-Gewerk existiert
    if (hasGerüstbau && trade.code !== 'GERÜST' && 
        pos.title?.toLowerCase().includes('gerüst')) {
      console.log(`Entferne Gerüstposition aus ${trade.code}`);
      return false;
    }
    
    // Entferne Wanddurchbruch aus Rohbau wenn Abbruch existiert
    if (hasAbbruch && trade.code === 'ROH' && 
        pos.title?.toLowerCase().includes('durchbruch')) {
      console.log(`Entferne Durchbruch aus Rohbau (gehört zu Abbruch)`);
      return false;
    }
    
    return true;
  });
  
  // Füge Hinweis zu Notes hinzu
  if (!lv.notes) lv.notes = '';
  lv.notes += '\n\nGewerkeabgrenzung beachtet - Duplikate wurden entfernt.';
}

    // NEU: Filtere Gerüstpositionen wenn Gerüst separates Gewerk ist
    if (hasGeruestGewerk && ['DACH', 'FASS', 'FEN'].includes(trade.code)) {
      const originalCount = lv.positions?.length || 0;
      lv.positions = lv.positions?.filter(pos => {
        const title = (pos.title || '').toLowerCase();
        const desc = (pos.description || '').toLowerCase();
        const isScaffolding = title.includes('gerüst') || desc.includes('gerüst') || 
                             title.includes('arbeitsgerüst') || desc.includes('arbeitsgerüst') ||
                             title.includes('fassadengerüst') || desc.includes('fassadengerüst');
        if (isScaffolding) {
          console.log(`[LV] Filtered scaffolding position in ${trade.code}: ${pos.title}`);
        }
        return !isScaffolding;
      }) || [];
      
      if (originalCount !== lv.positions.length) {
        console.log(`[LV] Removed ${originalCount - lv.positions.length} scaffolding positions from ${trade.code}`);
      }
      
      // Füge Vorbemerkungen hinzu wenn noch nicht vorhanden
      if (!lv.vorbemerkungen) lv.vorbemerkungen = [];
      if (!lv.vorbemerkungen.includes('Gerüst wird bauseits gestellt')) {
        lv.vorbemerkungen.unshift('Gerüst wird bauseits gestellt');
        lv.vorbemerkungen.unshift('Gerüstkosten sind in separatem Gewerk erfasst');
      }
    }
    
    // Post-Processing und Stundenlohnarbeiten hinzufügen
    if (lv.positions && Array.isArray(lv.positions)) {
  // Filtere leere/ungültige Positionen
  const validPositions = lv.positions.filter(pos => {
    // Entferne Positionen mit Menge 0, "-" oder ohne Menge
    if (!pos.quantity || pos.quantity === 0 || pos.quantity === '-') {
      console.log(`[LV] Filtered empty position: ${pos.title}`);
      return false;
    }
    
    // Entferne "nicht vorhanden" Positionen
    const title = (pos.title || '').toLowerCase();
    const desc = (pos.description || '').toLowerCase();
    if (title.includes('nicht vorhanden') || 
        title.includes('nicht enthalten') ||
        title.includes('nicht definiert') ||
        desc.includes('nicht vorhanden') ||
        desc.includes('keine position')) {
      console.log(`[LV] Filtered invalid position: ${pos.title}`);
      return false;
    }
    
    return true;
  });
  
  console.log(`[LV] Filtered ${lv.positions.length - validPositions.length} invalid positions`);
  lv.positions = validPositions;
  
  // Prüfe ob noch genug Positionen übrig sind (80% = 20% Toleranz)
  if (lv.positions.length < orientation.min * 0.8) {
    console.warn(`[LV] Only ${lv.positions.length} valid positions remain (80% minimum: ${Math.floor(orientation.min * 0.8)})`);
    // Optional: Hier könnte ein Retry getriggert werden
  }

// GER-spezifisch: Konsolidiere mehrfache Standzeit-Positionen
  if (trade.code === 'GER') {
    console.log('[GER] Prüfe auf mehrfache Standzeit-Positionen...');
    
    const weitereWochenPositionen = lv.positions.filter(pos => {
      const title = (pos.title || '').toLowerCase();
      return (
        (title.includes('woche') && 
         (title.includes('5') || title.includes('6') || title.includes('7') || 
          title.includes('8') || title.includes('9') || title.includes('10') ||
          title.includes('11') || title.includes('12'))) ||
        (title.includes('weitere') && title.includes('woche')) ||
        (title.includes('zusätzlich') && title.includes('standzeit'))
      ) && !title.includes('erste');
    });
    
    if (weitereWochenPositionen.length > 1) {
      console.log(`[GER] ${weitereWochenPositionen.length} Positionen für weitere Wochen - konsolidiere`);
      
      const consolidatedPos = {
        ...weitereWochenPositionen[0],
        title: "Gerüst-Standzeit jede weitere Woche (Eventualposition)",
        description: "Gerüstmiete für jede weitere Woche über 4 Wochen hinaus. Eventualposition. Abrechnung nach Bedarf.",
        unitPrice: 1.20,
        totalPrice: weitereWochenPositionen[0].quantity * 1.20,
        isNEP: true
      };
      
      lv.positions = lv.positions.filter(pos => !weitereWochenPositionen.includes(pos));
      lv.positions.splice(3, 0, consolidatedPos);
    }
    
    // Korrigiere EP
    lv.positions = lv.positions.map(pos => {
      const title = (pos.title || '').toLowerCase();
      if ((title.includes('weitere') || title.includes('eventualposition')) && 
          title.includes('woche') && pos.unitPrice > 1.20) {
        pos.unitPrice = 1.20;
        pos.totalPrice = pos.quantity * 1.20;
        pos.isNEP = true;
      }
      return pos;
    });
    
    // Entferne separate Demontage/Abtransport-Positionen
    const vorherAnzahl = lv.positions.length;
    lv.positions = lv.positions.filter(pos => {
      const title = (pos.title || '').toLowerCase();
      const desc = (pos.description || '').toLowerCase();
      
      // Entferne reine Demontage/Abbau-Positionen (ohne Aufbau)
      if ((title.includes('demontage') || title.includes('abbau') || title.includes('abtransport')) &&
          !title.includes('auf') && 
          !title.includes('lieferung') &&
          !title.includes('montage')) {
        console.log(`[GER] Entferne redundante Position: "${pos.title}"`);
        return false;
      }
      
      return true;
    });
    
    if (vorherAnzahl !== lv.positions.length) {
      console.log(`[GER] ${vorherAnzahl - lv.positions.length} redundante Abbau/Transport-Positionen entfernt`);
    }
  }

  // FASS-spezifisch: Teil 1 - Korrigiere falsche Dämmstärken
if (trade.code === 'FASS' && lv.positions) {
  // Prüfe ob Dämmstärke aus Antworten extrahiert wurde
  if (criticalMeasurements.daemmstaerke) {
    const korrekteDaemmstaerke = criticalMeasurements.daemmstaerke.value;
    console.log(`[FASS] Erzwinge Dämmstärke ${korrekteDaemmstaerke}cm aus Nutzerangaben`);
    
    // Gültige Dämmstärken (für Validierung)
    const gueltigeDaemmstaerken = [10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30];
    
    if (!gueltigeDaemmstaerken.includes(korrekteDaemmstaerke)) {
      console.warn(`[FASS] Unübliche Dämmstärke ${korrekteDaemmstaerke}cm aus Antworten - verwende trotzdem!`);
    }
    
    lv.positions = lv.positions.map((pos, index) => {
      // Prüfe ob Position Dämmung betrifft
      const istDaemmPosition = 
        pos.title?.toLowerCase().includes('dämm') ||
        pos.title?.toLowerCase().includes('wdvs') ||
        pos.title?.toLowerCase().includes('eps') ||
        pos.title?.toLowerCase().includes('xps') ||
        pos.title?.toLowerCase().includes('sockeldämm') ||
        pos.title?.toLowerCase().includes('perimeter') ||
        pos.title?.toLowerCase().includes('steinwolle') ||
        pos.title?.toLowerCase().includes('mineralwolle');
      
      if (istDaemmPosition) {
        // Regex findet ALLE Zahlen vor cm (inkl. 0, ungerade, etc.)
        const daemmRegex = /\b\d+(\.\d+)?\s*cm\b/gi;
        
        let aenderungen = [];
        
        // Korrigiere Titel
        if (pos.title) {
          const oldTitle = pos.title;
          // Ersetze JEDE Zahl+cm Kombination mit korrektem Wert
          pos.title = pos.title.replace(daemmRegex, (match) => {
            const zahl = parseInt(match);
            // Nur ersetzen wenn: 0, ungerade, unter 10, oder nicht in gültiger Liste
            if (zahl === 0 || zahl < 10 || zahl % 2 !== 0 || !gueltigeDaemmstaerken.includes(zahl)) {
              aenderungen.push(`${match} → ${korrekteDaemmstaerke} cm`);
              return `${korrekteDaemmstaerke} cm`;
            }
            // Sonst: Wenn Zahl gültig aber nicht die aus Antworten
            if (zahl !== korrekteDaemmstaerke) {
              aenderungen.push(`${match} → ${korrekteDaemmstaerke} cm`);
              return `${korrekteDaemmstaerke} cm`;
            }
            return match;
          });
          
          if (oldTitle !== pos.title) {
            console.log(`[FASS] Position ${index+1} Titel korrigiert:`, aenderungen.join(', '));
          }
        }
        
        // Korrigiere Beschreibung mit gleichem Ansatz
        if (pos.description) {
          pos.description = pos.description.replace(daemmRegex, (match) => {
            const zahl = parseInt(match);
            if (zahl === 0 || zahl < 10 || zahl % 2 !== 0 || zahl !== korrekteDaemmstaerke) {
              return `${korrekteDaemmstaerke} cm`;
            }
            return match;
          });
          
          // Zusätzlich: Spezifische Kontexte korrigieren
          pos.description = pos.description.replace(/Stärke:\?\s*\d+\s*cm/gi, `Stärke ${korrekteDaemmstaerke} cm`);
          pos.description = pos.description.replace(/Dicke:\?\s*\d+\s*cm/gi, `Dicke ${korrekteDaemmstaerke} cm`);
          pos.description = pos.description.replace(/Höhe:\?\s*\d+\s*cm/gi, `Höhe ${korrekteDaemmstaerke} cm`);
        }
        
        // Finale Prüfung: Warne wenn immer noch problematische Werte
const nachPruefung = (pos.title + ' ' + pos.description).match(/\b\d+\s*cm\b/gi);
if (nachPruefung) {
  nachPruefung.forEach(match => {
    const zahl = parseInt(match);
    if (zahl !== korrekteDaemmstaerke && (zahl === 0 || zahl < 10 || zahl % 2 !== 0)) {
      console.error(`[FASS] KRITISCH: Position ${index+1} enthält noch falsche Dämmstärke: ${match}`);
    }
  });
}

// Spezialbehandlung für Sockeldämmung (2cm dünner als WDVS)
if (pos.title?.toLowerCase().includes('sockel')) {
  const sockeldaemmstaerke = Math.max(8, korrekteDaemmstaerke - 2); // 2cm dünner, min. 8cm
  console.log(`[FASS] Sockeldämmung: ${sockeldaemmstaerke}cm (WDVS-2cm)`);
  
  // Ersetze ALLE Dämmstärken in Sockelpositionen mit angepasster Stärke
  const alleZahlenRegex = /\b\d+(\.\d+)?\s*cm\b/gi;
  
  if (pos.title) {
    pos.title = pos.title.replace(alleZahlenRegex, `${sockeldaemmstaerke} cm`);
  }
  
  if (pos.description) {
  const originalDescription = pos.description; // Speichere Original
  
  pos.description = originalDescription.replace(alleZahlenRegex, (match, p1, offset) => {
    // Prüfe Kontext - verwende originalDescription statt fullString
    const vorher = originalDescription.substring(Math.max(0, offset - 20), offset).toLowerCase();
    if (vorher.includes('höhe') || vorher.includes('sichtbar') || vorher.includes('über')) {
      return match; // Sockelhöhe nicht ändern
    }
    return `${sockeldaemmstaerke} cm`;
  });
    
    // Explizit "Stärke X cm" ersetzen
    pos.description = pos.description.replace(/Stärke\s+\d+\s*cm/gi, `Stärke ${sockeldaemmstaerke} cm`);
    pos.description = pos.description.replace(/Dicke\s+\d+\s*cm/gi, `Dicke ${sockeldaemmstaerke} cm`);
    pos.description = pos.description.replace(/XPS-Platten.*?\d+\s*cm/gi, `XPS-Platten WLG 035, ${sockeldaemmstaerke} cm`);
  }
  
  console.log(`[FASS] Sockeldämmung korrigiert auf ${sockeldaemmstaerke}cm`);
} // DIESE KLAMMER FEHLTE!

      } // Ende von istDaemmPosition
      return pos;
    });
  } else {
    // KRITISCHER FEHLER: Keine Dämmstärke gefunden
    console.error('[FASS] KRITISCH: Keine Dämmstärke in Antworten gefunden!');
    console.error('[FASS] Suche Notfall-Dämmstärke in den LV-Positionen...');
    
    // Versuche Dämmstärke aus vorhandenen Positionen zu extrahieren
    let gefundeneDaemmstaerken = [];
    lv.positions.forEach(pos => {
      const matches = (pos.title + ' ' + pos.description).match(/\b(\d+)\s*cm\b/gi);
      if (matches) {
        matches.forEach(m => {
          const zahl = parseInt(m);
          if (zahl >= 10 && zahl <= 30 && zahl % 2 === 0) {
            gefundeneDaemmstaerken.push(zahl);
          }
        });
      }
    });
    
    // Wenn keine gültige Dämmstärke gefunden, verwende 16cm als Standard
    const notfallDaemmstaerke = gefundeneDaemmstaerken.length > 0 ? 
      gefundeneDaemmstaerken[0] : 16;
    
    console.warn(`[FASS] Verwende Notfall-Dämmstärke: ${notfallDaemmstaerke}cm`);
    
    // Korrigiere alle falschen Werte NUR FÜR DÄMMUNG
    lv.positions = lv.positions.map(pos => {
      if (pos.title?.toLowerCase().includes('dämm') || 
          pos.title?.toLowerCase().includes('wdvs')) {
        // Ersetze 0cm und alle ungeraden/falschen Werte
        pos.title = pos.title?.replace(/\b[0-9]\s*cm\b/gi, `${notfallDaemmstaerke} cm`);
        pos.title = pos.title?.replace(/\b\d*[13579]\s*cm\b/gi, `${notfallDaemmstaerke} cm`);
        
        pos.description = pos.description?.replace(/\b[0-9]\s*cm\b/gi, `${notfallDaemmstaerke} cm`);
        pos.description = pos.description?.replace(/\b\d*[13579]\s*cm\b/gi, `${notfallDaemmstaerke} cm`);
      }
      return pos;
    });
  }
  
// TEIL 2: Entferne falsche Positionen (Isokorb etc.)
  const vorherCount = lv.positions.length;
  lv.positions = lv.positions.filter(pos => {
    const title = (pos.title || '').toLowerCase();
    const desc = (pos.description || '').toLowerCase();
    
    if (title.includes('isokorb') || desc.includes('isokorb')) {
      console.error(`[FASS] FEHLER: Isokorb-Position entfernt - gehört zu Rohbau!`);
      return false;
    }   
    if ((title.includes('balkon') && title.includes('abtrennen')) ||
        (desc.includes('thermische trennung') && desc.includes('balkon'))) {
      console.error(`[FASS] FEHLER: Balkon-Trennung entfernt - unmöglich bei Sanierung!`);
      return false;
    }
    
    return true;
  });
  
  if (vorherCount !== lv.positions.length) {
    console.log(`[FASS] ${vorherCount - lv.positions.length} falsche Positionen entfernt`);
  }
} // Ende des FASS-Blocks
      
// MATERIAL-PREISKORREKTUREN (Kleber, Kabel, etc.)
lv.positions = lv.positions.map(pos => {
  const titleLower = (pos.title || pos.bezeichnung || '').toLowerCase();
  const descLower = (pos.description || '').toLowerCase();
  
  // UNIVERSELLE REGEL 1: Kleber/Klebstoff-Preise
  if (titleLower.includes('kleber') || titleLower.includes('klebstoff')) {
    if (pos.unit === 'm²' && pos.unitPrice > 15) {
      const oldPrice = pos.unitPrice;
      
      // Bestimme Kleber-Typ
      let neuerPreis = 5; // Standard
      if (titleLower.includes('2-komponenten') || titleLower.includes('epoxid')) {
        neuerPreis = 12; // Teurer Spezialkleber
      } else if (titleLower.includes('flexkleber') || titleLower.includes('naturstein')) {
        neuerPreis = 8; // Mittelpreisig
      }
      
      pos.unitPrice = neuerPreis;
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      console.log(`[KLEBER] Preis korrigiert: ${oldPrice}€/m² → ${neuerPreis}€/m²`);
    }
    
    // Kleber pro kg
    if (pos.unit === 'kg' && pos.unitPrice > 25) {
      const oldPrice = pos.unitPrice;
      pos.unitPrice = 8; // Max 8€/kg für Spezialkleber
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      console.log(`[KLEBER] Preis/kg korrigiert: ${oldPrice}€ → 8€`);
    }
  }
  
  // UNIVERSELLE REGEL 2: Kabel/Leitungs-Preise
  if (titleLower.includes('nym') || titleLower.includes('kabel') || 
      titleLower.includes('leitung') || descLower.includes('nym')) {
    
    // NYM-J Kabel nach Querschnitt
    if (titleLower.includes('nym-j') || titleLower.includes('nym j') || 
        descLower.includes('nym-j')) {
      
      // Suche Querschnitt in Title oder Description
      const fullText = titleLower + ' ' + descLower;
      const querschnittMatch = fullText.match(/(\d+)\s*x\s*([\d,\.]+)\s*mm/);
      
      if (querschnittMatch) {
        const adern = parseInt(querschnittMatch[1]);
        const querschnitt = parseFloat(querschnittMatch[2].replace(',', '.'));
        
        let maxPreis = 15; // Basis
        
        // Preise nach Querschnitt (inkl. Verlegung)
        if (querschnitt <= 1.5) {
          maxPreis = 12; 
        } else if (querschnitt <= 2.5) {
          maxPreis = 15;
        } else if (querschnitt <= 4) {
          maxPreis = 20;
        } else if (querschnitt <= 6) {
          maxPreis = 25;
        } else if (querschnitt <= 10) {
          maxPreis = 35;
        } else {
          maxPreis = 45; // Große Querschnitte
        }
        
        // 5-adrig ist teurer
        if (adern === 5) {
          maxPreis = Math.round(maxPreis * 1.3);
        }
        
        if (pos.unit === 'm' && pos.unitPrice > maxPreis) {
          const oldPrice = pos.unitPrice;
          pos.unitPrice = maxPreis;
          pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
          console.log(`[KABEL] NYM-J ${adern}x${querschnitt}mm² korrigiert: ${oldPrice}€/m → ${maxPreis}€/m`);
        }
      }
    }
    
    // Datenkabel
    if (titleLower.includes('cat') || titleLower.includes('netzwerk') || 
        titleLower.includes('lan')) {
      if (pos.unit === 'm' && pos.unitPrice > 25) {
        const oldPrice = pos.unitPrice;
        let neuerPreis = 12; // Standard CAT
        
        if (titleLower.includes('cat7') || titleLower.includes('cat 7')) {
          neuerPreis = 18; // CAT7 teurer
        } else if (titleLower.includes('cat6') || titleLower.includes('cat 6')) {
          neuerPreis = 15; // CAT6 mittel
        }
        
        pos.unitPrice = neuerPreis;
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        console.log(`[KABEL] Datenkabel korrigiert: ${oldPrice}€/m → ${neuerPreis}€/m`);
      }
    }
    
    // Erdkabel NYY
    if (titleLower.includes('nyy') || titleLower.includes('erdkabel')) {
      if (pos.unit === 'm' && pos.unitPrice > 50) {
        const oldPrice = pos.unitPrice;
        pos.unitPrice = 35; // Erdkabel max 35€/m inkl. Verlegung
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
        console.log(`[KABEL] Erdkabel korrigiert: ${oldPrice}€/m → 35€/m`);
      }
    }
  }
  
  return pos;
});

// ROH-spezifisch: Entferne falsche Holzbau-Positionen
if (trade.code === 'ROH' && lv.positions) {
  console.log('[ROH] Prüfe auf falsche Holzbau-Positionen...');
  
  const vorherCount = lv.positions.length;
  lv.positions = lv.positions.filter(pos => {
    const title = (pos.title || '').toLowerCase();
    const desc = (pos.description || '').toLowerCase();
    
    // Holzbau-Keywords die NICHT in ROH gehören
    const holzbauKeywords = [
      'holzständer', 'holzrahmen', 'holzbalkendecke', 'holzkonstruktion',
      'sparren', 'pfetten', 'firstbalken', 'gratbalken', 'windrispen',
      'konstruktionsvollholz', 'kvh', 'c24', 'balkenschuhe', 'holzschutz'
    ];
    
    // Prüfe ob Position Holzbau enthält
    const istHolzbau = holzbauKeywords.some(keyword => 
      title.includes(keyword) || desc.includes(keyword)
    );
    
    if (istHolzbau) {
      console.log(`[ROH] FEHLER: Holzbau-Position entfernt: "${pos.title}"`);
      return false; // Position entfernen
    }
    
    // Auch "Aufstockung in Holz" ist Zimmerer-Sache
    if ((title.includes('aufstockung') || desc.includes('aufstockung')) &&
        (title.includes('holz') || desc.includes('holz'))) {
      console.log(`[ROH] FEHLER: Holz-Aufstockung gehört zu ZIMM: "${pos.title}"`);
      return false;
    }
    
    return true; // Position behalten
  });
  
  if (vorherCount !== lv.positions.length) {
    console.error(`[ROH] KRITISCH: ${vorherCount - lv.positions.length} Holzbau-Positionen entfernt - gehören zu ZIMMERER!`);
    
    // Füge Hinweis-Position ein
    if (lv.positions.length < orientation.min * 0.7) {
      lv.positions.push({
        pos: `${lv.positions.length + 1}.00`,
        title: "HINWEIS: Holzbauarbeiten",
        description: "Holzbauarbeiten für Aufstockung siehe separates Gewerk ZIMMERER. Rohbau erstellt nur die Anschlüsse und Verstärkungen am Bestandsmauerwerk.",
        quantity: 1,
        unit: "psch",
        unitPrice: 0,
        totalPrice: 0,
        isNEP: true,
        notes: "Nur zur Information - keine Kosten"
      });
    }
  }
}  
    
// ZIMM-spezifisch: Prüfe ob Holzbau-Positionen vorhanden sind
if (trade.code === 'ZIMM' && lv.positions) {
  const hatHolzbau = lv.positions.some(pos => 
    pos.title?.toLowerCase().includes('holz') || 
    pos.description?.toLowerCase().includes('holz')
  );
  
  if (!hatHolzbau) {
    console.error('[ZIMM] WARNUNG: Zimmerer-LV ohne Holzbau-Positionen!');
  }
}
      
  let calculatedSum = 0;
  let nepSum = 0; // NEU: Summe der NEP-Positionen
  
  lv.positions = lv.positions.map(pos => {
    // NEU: NEP-Flag standardmäßig false
    if (pos.isNEP === undefined) {
      pos.isNEP = false;
    }
    
    if (!pos.totalPrice && pos.quantity && pos.unitPrice) {
      pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
    }
    
    // NEU: NEP-Positionen nicht zur Hauptsumme addieren
    if (!pos.isNEP) {
      calculatedSum += pos.totalPrice || 0;
    } else {
      nepSum += pos.totalPrice || 0;
    }
    
    return pos;
  });
  
  // NEU: NEP-Summe separat speichern
  lv.nepSum = Math.round(nepSum * 100) / 100;
  lv.totalSum = Math.round(calculatedSum * 100) / 100;  // DIESE ZEILE FEHLT!
      
      // Stundenlohnarbeiten hinzufügen
      const stundenSätze = {
        'MAL': { stunden: 5, satz: 45, bezeichnung: 'Maler/Lackierer' },
        'GER': { stunden: 5, satz: 35, bezeichnung: 'Gerüstbauer' },
        'ESTR': { stunden: 5, satz: 50, bezeichnung: 'Estrichleger' },
        'FLI': { stunden: 8, satz: 55, bezeichnung: 'Fliesenleger' },
        'DACH': { stunden: 15, satz: 65, bezeichnung: 'Dachdecker' },
        'ELEKT': { stunden: 12, satz: 70, bezeichnung: 'Elektriker' },
        'SAN': { stunden: 15, satz: 75, bezeichnung: 'Sanitärinstallateur' },
        'HEI': { stunden: 12, satz: 75, bezeichnung: 'Heizungsbauer' },
        'TIS': { stunden: 10, satz: 60, bezeichnung: 'Tischler' },
        'FEN': { stunden: 8, satz: 60, bezeichnung: 'Fensterbauer' },
        'ZIMM': { stunden: 12, satz: 65, bezeichnung: 'Zimmerer' },
        'DEFAULT': { stunden: 8, satz: 55, bezeichnung: 'Handwerker' }
      };
      
      const stundenConfig = stundenSätze[trade.code] || stundenSätze['DEFAULT'];
      
      // Füge Stundenlohnposition hinzu
      const stundenlohnPos = {
        pos: `${lv.positions.length + 1}.00`,
        title: `Stundenlohnarbeiten ${stundenConfig.bezeichnung}`,
        description: `Zusätzliche Arbeiten auf Stundenlohnbasis für unvorhergesehene oder kleinteilige Leistungen, die nicht im LV erfasst sind. Abrechnung nach tatsächlichem Aufwand.`,
        quantity: stundenConfig.stunden,
        unit: 'Std',
        unitPrice: stundenConfig.satz,
        totalPrice: stundenConfig.stunden * stundenConfig.satz,
        dataSource: 'standard',
        notes: 'Pauschal einkalkuliert für Zusatzarbeiten'
      };
      
      lv.positions.push(stundenlohnPos);
      // NEUE POSITION: Stundenlohn-Korrektur HIER, NACH dem Hinzufügen
const summeOhneStundenlohn = lv.totalSum; // Summe VOR Stundenlohn
if (summeOhneStundenlohn < 2000) {
  const maxStundenlohn = summeOhneStundenlohn * 0.10;
  
  if (stundenlohnPos.totalPrice > maxStundenlohn) {
    console.log(`[STUNDENLOHN] Korrigiere: ${stundenlohnPos.totalPrice}€ -> max ${maxStundenlohn}€`);
    
    if (summeOhneStundenlohn < 500) {
      stundenlohnPos.quantity = 1;
    } else if (summeOhneStundenlohn < 1000) {
      stundenlohnPos.quantity = 2;
    } else {
      stundenlohnPos.quantity = Math.max(2, Math.floor(maxStundenlohn / stundenlohnPos.unitPrice));
    }
    
    stundenlohnPos.totalPrice = stundenlohnPos.quantity * stundenlohnPos.unitPrice;
    console.log(`[STUNDENLOHN] Neue Menge: ${stundenlohnPos.quantity} Std`);
  }
}
      
      calculatedSum += stundenlohnPos.totalPrice;
      
      lv.totalSum = Math.round(calculatedSum * 100) / 100;

      // Vorbemerkungen aus Intake-Daten generieren falls nicht vorhanden
      if (!lv.vorbemerkungen || lv.vorbemerkungen.length === 0) {
        lv.vorbemerkungen = [];
        
        // Extrahiere relevante Intake-Infos
        const gebäudeInfo = intakeAnswers.find(a => a.question.toLowerCase().includes('gebäude'));
        const zufahrtInfo = intakeAnswers.find(a => a.question.toLowerCase().includes('zufahrt') || a.question.toLowerCase().includes('zugang'));
        const zeitInfo = intakeAnswers.find(a => a.question.toLowerCase().includes('zeit') || a.question.toLowerCase().includes('termin'));
        
        if (gebäudeInfo) {
          lv.vorbemerkungen.push(`Gebäude: ${gebäudeInfo.answer}`);
        }
        if (zufahrtInfo) {
          lv.vorbemerkungen.push(`Baustellenzugang: ${zufahrtInfo.answer}`);
        }
        if (zeitInfo) {
          lv.vorbemerkungen.push(`Ausführungszeitraum: ${zeitInfo.answer}`);
        }
        
        // Standard-Vorbemerkungen
        lv.vorbemerkungen.push('Alle Preise verstehen sich inklusive aller Nebenleistungen gemäß VOB/C');
        lv.vorbemerkungen.push('Baustrom und Bauwasser werden bauseits gestellt');
      }

      // Adress-Anonymisierung in Vorbemerkungen
if (lv.vorbemerkungen && Array.isArray(lv.vorbemerkungen)) {
  lv.vorbemerkungen = lv.vorbemerkungen.map(vorbemerkung => {
    // Variante 1: "Straße Nr, PLZ Stadt" → "PLZ Stadt"
    let result = vorbemerkung.replace(
      /[A-ZÄÖÜ][a-zäöüß\-]+\s+(?:straße|str\.?|strasse|weg|platz|allee|gasse|ring|pfad)\.?\s+\d+[a-zA-Z]?,?\s*/gi, 
      ''
    );
    
    // Variante 2: "PLZ Stadt, Straße Nr" → "PLZ Stadt"
    result = result.replace(
      /,\s*[A-ZÄÖÜ][a-zäöüß\-]+\s+(?:straße|str\.?|strasse|weg|platz|allee|gasse|ring|pfad)\.?\s+\d+[a-zA-Z]?\.?/gi,
      ''
    );
    
    // Aufräumen
    result = result.replace(/,\s*,/g, ',');
    result = result.replace(/,\s*$/g, ''); // Komma am Ende entfernen
    
    return result;
  });
}
      
      // Statistiken
      lv.statistics = {
        positionCount: lv.positions.length,
        averagePositionValue: Math.round((lv.totalSum / lv.positions.length) * 100) / 100,
        minPosition: Math.min(...lv.positions.map(p => p.totalPrice || 0)),
        maxPosition: Math.max(...lv.positions.map(p => p.totalPrice || 0)),
        measuredPositions: lv.positions.filter(p => p.dataSource === 'measured').length,
        estimatedPositions: lv.positions.filter(p => p.dataSource === 'estimated').length,
        hasStundenlohn: true
      };
    }
    
    // Metadaten
    const lvWithMeta = {
      ...lv,
      metadata: {
        generatedAt: new Date().toISOString(),
        projectId,
        tradeId,
        hasVorbemerkungen: lv.vorbemerkungen && lv.vorbemerkungen.length > 0,
        vorbemerkungCount: lv.vorbemerkungen?.length || 0,
        intakeAnswersCount: intakeAnswers.length,
        tradeAnswersCount: tradeAnswers.length,
        positionsCount: lv.positions?.length || 0,
        totalValue: lv.totalSum || 0,
        dataQuality: lv.dataQuality || { confidence: 0.5 }
      }
    };
    
    return lvWithMeta;
    
  } catch (err) {
    console.error('[LV] Generation failed:', err);
    throw new Error(`LV-Generierung für ${trade.name} fehlgeschlagen`);
  }
}

// Optimierte LV-Generierung - schnell und effizient
async function generateDetailedLVWithRetry(projectId, tradeId, maxRetries = 2) {
  let lastError;
  
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`[LV] Generation attempt ${attempt}/${maxRetries} for trade ${tradeId}`);
      
      const result = await generateDetailedLV(projectId, tradeId);
      
      console.log(`[LV] Successfully generated on attempt ${attempt}`);
      console.log(`[LV] Generated for trade ${tradeId}: ${result.positions?.length || 0} positions, Total: €${result.totalSum || 0}`);
      return result;
      
    } catch (error) {
      lastError = error;
      console.error(`[LV] Attempt ${attempt} failed:`, error.message);
      
      // Bei Datenfehlern NICHT wiederholen - das bringt nichts
      if (error.message.includes('JSON') || 
          error.message.includes('[object Object]') ||
          error.message.includes('undefined') ||
          error.message.includes('duplicate')) {
        console.error('[LV] Data/Structure error detected - not retrying:', error.message);
        throw error; // Sofort fehlschlagen
      }
      
      // Nur bei echten API/Netzwerk-Fehlern retry
      if (attempt < maxRetries) {
        // Nur bei OpenAI Rate Limits oder Timeouts wiederholen
        if (error.message.includes('Rate limit') || 
            error.message.includes('timeout') ||
            error.message.includes('OpenAI') ||
            error.message.includes('network')) {
          const waitTime = 500; // Kurze konstante Wartezeit
          console.log(`[LV] API/Network issue - waiting ${waitTime}ms before retry...`);
          await new Promise(resolve => setTimeout(resolve, waitTime));
        } else {
          // Unbekannter Fehler - nicht wiederholen
          console.error('[LV] Unknown error type - not retrying');
          throw error;
        }
      }
    }
  }
  
  // Log den letzten Fehler ausführlich
  console.error('[LV] All attempts failed. Last error:', lastError);
  throw new Error(`LV-Generierung fehlgeschlagen: ${lastError.message}`);
}

/**
 * Finale LV-Validierung für alle Gewerke
 */
function finalLVValidation(lv, tradeCode) {
  const issues = [];
  
  // UMFASSENDE Cross-Trade-Keywords für alle Gewerke
  const crossTradeKeywords = {
    'DACH': { 
      forbidden: ['fassadendämmung', 'wdvs', 'fenster', 'haustür', 'innentür', 'sanitär', 'elektro', 'heizung', 'fliesen', 'parkett'],
      except: ['dachfenster', 'dachausstieg', 'blitzschutz']
    },
    'FASS': { 
      forbidden: ['fenster einbau', 'fenster lieferung', 'isokorb', 'tür montage', 'dachziegel', 'dachrinne', 'heizung', 'sanitär', 'elektro', 'parkett', 'fliesen'],
      except: ['fensterbank', 'laibung', 'fenstersims']
    },
    'FEN': { 
      forbidden: ['fassadendämmung', 'wdvs', 'außenputz', 'dachziegel', 'heizung', 'sanitär', 'elektro komplett'],
      except: ['fensterbank', 'rollladenkasten']
    },
    'ZIMM': {
    forbidden: ['innentüren', 'wohnungseingangstür', 'möbel', 'fenster', 'dachfenster', 'elektro', 'sanitär', 'fliesen'],
    except: ['holzverbindung', 'zimmermannsverbindung']
    },    
    'GER': { 
      forbidden: ['dämmung', 'entsorgung', 'putz', 'fenster einbau', 'malerarbeiten', 'elektro', 'sanitär', 'heizung', 'fliesen'],
      except: []
    },
    'ELEKT': {
      forbidden: ['sanitär objekte', 'heizkessel', 'heizkörper', 'fliesen', 'parkett', 'fenster', 'dämmung'],
      except: ['durchlauferhitzer', 'elektro-heizung']
    },
    'SAN': {
      forbidden: ['elektro verteiler', 'steckdosen', 'schalter', 'fenster', 'parkett', 'dämmung', 'dachziegel'],
      except: ['durchlauferhitzer', 'elektro-boiler']
    },
    'HEI': {
      forbidden: ['sanitär objekte', 'wc', 'dusche', 'elektro verteiler', 'fenster', 'fliesen', 'parkett'],
      except: ['warmwasser', 'zirkulation']
    },
    'FLI': {
      forbidden: ['parkett', 'laminat', 'vinyl', 'teppich', 'elektro', 'sanitär', 'heizung', 'fenster'],
      except: ['sockelleiste', 'übergangsprofil']
    },
    'BOD': {
      forbidden: ['fliesen', 'naturstein bad', 'elektro', 'sanitär', 'heizung', 'fenster', 'dämmung'],
      except: ['sockelleiste', 'übergangsprofil']
    },
    'MAL': {
      forbidden: ['fenster einbau', 'elektro installation', 'sanitär installation', 'heizung', 'fliesen', 'parkett'],
      except: ['malervorarbeiten']
    },
    'TRO': {
      forbidden: ['fenster', 'türen', 'elektro komplett', 'sanitär komplett', 'heizung komplett', 'fliesen'],
      except: ['revisionsklappen', 'aussparungen', 'installationsschächte']
    },
    'TIS': {
      forbidden: ['fenster', 'elektro installation', 'sanitär', 'heizung', 'rigips', 'gipskarton', 'sockelleisten'],
      except: ['fensterbank innen', 'möbelanschluss']
    },
    'ROH': {
      forbidden: ['fenster einbau', 'estrich', 'gaube', 'elektro feininstallation', 'sanitär objekte', 'fliesen', 'parkett', 'rigips'],
      except: ['kernbohrung', 'durchbruch']
    },
    'ABBR': {
      forbidden: ['neubau', 'lieferung', 'neue fenster', 'neue elektro', 'neue sanitär', 'aufbau'],
      except: ['schutzmaßnahmen', 'sicherung']
    },
    'ESTR': {
      forbidden: ['warmwasser', 'bewehrung', 'rohrsystem', 'aufheizprotokoll', 'dichtheitsprüfung', 'heizkreisverteiler', 'fliesen', 'parkett', 'oberbelag', 'elektro', 'sanitär', 'fenster'],
      except: ['fußbodenheizung', 'dämmung unter estrich']
    },
    'AUSS': {
      forbidden: ['innenputz', 'innentüren', 'elektro innen', 'sanitär innen', 'heizung'],
      except: ['außensteckdose', 'außenbeleuchtung', 'außenwasserhahn']
    },
    'SCHL': {
      forbidden: ['holzarbeiten', 'elektro installation', 'sanitär', 'heizung', 'fliesen'],
      except: ['metallzargen', 'stahlunterkonstruktion']
    },
    'KLIMA': {
      forbidden: ['heizkessel', 'heizkörper', 'sanitär objekte', 'fenster', 'fliesen'],
      except: ['kombianlagen', 'wärmepumpe']
    }
  };
  
   if (crossTradeKeywords[tradeCode] && lv.positions) {
    lv.positions.forEach(pos => {
      const titleLower = pos.title?.toLowerCase() || '';
      const descLower = pos.description?.toLowerCase() || '';
      const combined = titleLower + ' ' + descLower;
      
      const forbidden = crossTradeKeywords[tradeCode].forbidden;
      const exceptions = crossTradeKeywords[tradeCode].except;
      
      forbidden.forEach(keyword => {
        if (combined.includes(keyword)) {
          const isException = exceptions.some(ex => combined.includes(ex));
          if (!isException) {
            issues.push(`Position "${pos.title}" gehört nicht in ${tradeCode}`);
            console.error(`[FINAL-CHECK] Cross-trade violation in ${tradeCode}: ${pos.title}`);
          }
        }
      });
    });
  }
  
  // 2. Prüfe Mindestanforderungen
  if (tradeCode === 'FASS' && lv.positions) {
    const hasFlaeche = lv.positions.some(pos => 
      pos.unit === 'm²' && pos.title?.toLowerCase().includes('dämmung')
    );
    if (!hasFlaeche) {
      issues.push('Keine Flächenposition für Dämmung gefunden');
    }
  }
  
  // 3. Log finale Warnung wenn Issues
  if (issues.length > 0) {
    console.warn(`[FINAL-CHECK] ${tradeCode} hat ${issues.length} Issues:`);
    issues.forEach(issue => console.warn(`  - ${issue}`));
  }
  
  return { lv, issues };
}

// Helper function to get handwerker ID from company ID
async function getHandwerkerIdFromCompanyId(companyId) {
  const result = await query(
    'SELECT id FROM handwerker WHERE company_id = $1',
    [companyId]
  );
  return result.rows[0]?.id || null;
}

// ═══════════════════════════════════════════════════════════════
// HILFSFUNKTION: Upload-Kontext für System-Prompt
// ═══════════════════════════════════════════════════════════════

function buildUploadContext(enrichedAnswers) {
  const uploadsWithData = enrichedAnswers.filter(a => a.hasUpload);
  
  if (uploadsWithData.length === 0) {
    return {
      hasUploads: false,
      summary: '',
      detailedData: ''
    };
  }
  
  // Zusammenfassung
  const summary = `Es wurden ${uploadsWithData.length} Fragen mit hochgeladenen Dateien beantwortet:

${uploadsWithData.map((a, idx) => {
  const conf = (a.uploadMetadata.confidence * 100).toFixed(0);
  const type = a.uploadMetadata.documentType || a.uploadMetadata.fileType;
  return `${idx + 1}. ${a.question}
   → Datei: ${a.uploadMetadata.fileName}
   → Typ: ${type}
   → Confidence: ${conf}%`;
}).join('\n\n')}`;

  // Detaillierte Daten
  const detailedData = uploadsWithData.map((a, idx) => {
    let detail = `
═══ UPLOAD ${idx + 1}: ${a.question} ═══

EXTRAHIERTE ANTWORT:
${a.extractedAnswer || a.answer_text}
`;

    // Strukturierte Daten wenn vorhanden
    if (a.structuredData && a.structuredData.items) {
      detail += `
STRUKTURIERTE DATEN:
- Typ: ${a.structuredData.type || 'unbekannt'}
- Anzahl Einträge: ${a.structuredData.items.length}
`;
      
      // Zeige erste 5 Items als Beispiel
      if (a.structuredData.items.length > 0) {
        detail += `- Erste Einträge:\n`;
        a.structuredData.items.slice(0, 5).forEach((item, i) => {
          const itemStr = JSON.stringify(item, null, 2).substring(0, 200);
          detail += `  ${i + 1}. ${itemStr}...\n`;
        });
      }
      
      // Statistiken
      if (a.structuredData.statistics) {
        detail += `\nSTATISTIKEN:\n`;
        Object.entries(a.structuredData.statistics).forEach(([key, value]) => {
          detail += `  - ${key}: ${value}\n`;
        });
      }
    }
    
    return detail;
  }).join('\n');
  
  return {
    hasUploads: true,
    summary,
    detailedData
  };
}

/**
 * PDF Generation für komplettes Projekt-LV
 */
function generateCompleteLVPDF(project, lvs, withPrices = true) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 }
      });

      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));

      // Titelseite
      doc.fontSize(24)
         .font('Helvetica-Bold')
         .text('GESAMT-LEISTUNGSVERZEICHNIS', { align: 'center' });
      
      doc.moveDown(0.5);
      
      doc.fontSize(16)
         .font('Helvetica')
         .fillColor('#666666')
         .text(withPrices ? 'Komplette Kalkulation' : 'Angebotsanfrage', { align: 'center' });
      
      doc.moveDown(2);
      
      // Projektinfo
      doc.fontSize(14)
         .fillColor('black')
         .font('Helvetica-Bold')
         .text('Projekt:', { continued: false });
      
      doc.fontSize(12)
         .font('Helvetica')
         .text(project.description || 'Keine Beschreibung vorhanden');
      
      if (project.category) {
        doc.moveDown(0.5);
        doc.font('Helvetica-Bold')
           .text('Kategorie: ', { continued: true })
           .font('Helvetica')
           .text(project.category);
      }
      
      if (project.budget) {
        doc.font('Helvetica-Bold')
           .text('Budget: ', { continued: true })
           .font('Helvetica')
           .text(project.budget);
      }
      
      doc.moveDown(1);
      
      doc.font('Helvetica-Bold')
         .text('Datum: ', { continued: true })
         .font('Helvetica')
         .text(new Date().toLocaleDateString('de-DE', {
           year: 'numeric',
           month: 'long',
           day: 'numeric'
         }));

      // Globale Projekt-Vorbemerkungen aus Intake-Daten
// Lade Intake-Antworten für Vorbemerkungen
const intakeData = [];
for (const row of lvs) {
  const lv = typeof row.content === 'string' ? JSON.parse(row.content) : row.content;
  if (lv.vorbemerkungen && lv.vorbemerkungen.length > 0) {
    // Sammle alle Vorbemerkungen aus den LVs (die aus Intake-Daten generiert wurden)
    intakeData.push(...lv.vorbemerkungen.filter(v => 
      v.includes('Gebäude') || 
      v.includes('Zufahrt') || 
      v.includes('Arbeitszeit') || 
      v.includes('Baustrom') || 
      v.includes('Bauwasser')
    ));
  }
}

// Entferne Duplikate
const uniqueVorbemerkungen = [...new Set(intakeData)];

if (uniqueVorbemerkungen.length > 0) {
  doc.moveDown(2);
  doc.fontSize(12)
     .font('Helvetica-Bold')
     .text('ALLGEMEINE VORBEMERKUNGEN:', { underline: true });

  doc.moveDown(0.5);
  doc.fontSize(10)
     .font('Helvetica');

  uniqueVorbemerkungen.forEach(vorbemerkung => {
    doc.text(`• ${vorbemerkung}`, { indent: 20 });
  });
}
      
      // Inhaltsverzeichnis
      doc.moveDown(2);
      doc.fontSize(14)
         .font('Helvetica-Bold')
         .text('ENTHALTENE GEWERKE:', { underline: true });
      
      doc.moveDown(0.5);
      doc.fontSize(11)
         .font('Helvetica');
      
      let grandTotal = 0;
      const tradeSummaries = [];
      
      // Berechne Summen für Übersicht
for (const row of lvs) {
  const lv = typeof row.content === 'string' ? JSON.parse(row.content) : row.content;
  
  // NEU: Berechne Summe OHNE NEP-Positionen
  const tradeTotal = lv.positions && lv.positions.length > 0 
    ? lv.positions.reduce((sum, pos) => {
        // NEP-Positionen NICHT mitzählen
        if (!pos.isNEP) {
          return sum + (parseFloat(pos.totalPrice) || 0);
        }
        return sum;
      }, 0)
    : (parseFloat(lv.totalSum) || 0);
  
  // NEU: NEP-Summe separat erfassen
  const nepTotal = lv.positions && lv.positions.length > 0
    ? lv.positions.reduce((sum, pos) => {
        if (pos.isNEP) {
          return sum + (parseFloat(pos.totalPrice) || 0);
        }
        return sum;
      }, 0)
    : (lv.nepSum || 0);
  
  grandTotal += tradeTotal;  // NEP NICHT in Gesamtsumme
  
  tradeSummaries.push({
    code: row.trade_code,
    name: row.trade_name,
    total: tradeTotal,
    nepTotal: nepTotal  // NEU: NEP-Summe speichern
  });
  
  // Berechne und zeige die Gewerke in der Übersicht
  let displayText = `• ${row.trade_code} - ${row.trade_name}: ${withPrices ? formatCurrency(tradeTotal) : '________'}`;
  if (nepTotal > 0 && withPrices) {
  displayText += ` (+ NEP: ${formatCurrency(nepTotal)})`;
  }
  doc.text(displayText, { indent: 20 });
}    
      if (withPrices) {
        doc.moveDown(1);
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text(`Gesamtsumme (netto): ${formatCurrency(grandTotal)}`);
        doc.text(`MwSt. (19%): ${formatCurrency(grandTotal * 0.19)}`);
        doc.text(`Gesamtsumme (brutto): ${formatCurrency(grandTotal * 1.19)}`);
      }
      
      // Neue Seite für erstes Gewerk
      doc.addPage();
      
      // Einzelne Gewerke
      for (let i = 0; i < lvs.length; i++) {
        const row = lvs[i];
        const lv = typeof row.content === 'string' ? JSON.parse(row.content) : row.content;
        
        if (i > 0) {
          doc.addPage();
        }
        
        // Gewerk-Header
        doc.fontSize(18)
           .font('Helvetica-Bold')
           .text(`GEWERK: ${row.trade_code} - ${row.trade_name}`, { align: 'center' });
        
        doc.moveDown(1);

        // Vorbemerkungen für dieses Gewerk
if (lv.vorbemerkungen && lv.vorbemerkungen.length > 0) {
  doc.fontSize(11)
     .font('Helvetica-Bold')
     .text('VORBEMERKUNGEN:', { underline: true });
  
  doc.moveDown(0.3);
  doc.fontSize(9)
     .font('Helvetica');
  
  lv.vorbemerkungen.forEach((vorbemerkung, index) => {
    doc.text(`${index + 1}. ${vorbemerkung}`, {
      indent: 20,
      width: 480
    });
    doc.moveDown(0.2);
  });
  
  doc.moveDown(0.5);
}
        
        // Positionen-Tabelle
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('POSITIONEN:', { underline: true });
        
        doc.moveDown(0.5);
        
        const tableTop = doc.y;
        const col1 = 50;  
        const col2 = 90;  
        const col3 = 250; 
        const col4 = 310; 
        const col5 = 370; 
        const col6 = 450; 
        
        doc.fontSize(10)
           .font('Helvetica-Bold');
        
        doc.text('Pos.', col1, tableTop);
        doc.text('Bezeichnung', col2, tableTop);
        doc.text('Menge', col3, tableTop);
        doc.text('Einheit', col4, tableTop);
        doc.text('EP (€)', col5, tableTop);
        doc.text('GP (€)', col6, tableTop);
        
        doc.moveTo(col1, tableTop + 15)
           .lineTo(545, tableTop + 15)
           .stroke();
        
        let yPosition = tableTop + 25;
        let tradeSum = 0; // FIX: Initialisierung der Gewerk-Summe
        
        doc.font('Helvetica')
           .fontSize(9);
        
        if (lv && lv.positions && Array.isArray(lv.positions)) {
          lv.positions.forEach((pos, index) => {
            // Prüfe Seitenumbruch VOR dem Schreiben
            if (yPosition > 680) {  // Früher umbrechen für mehr Sicherheit
              doc.addPage();
              yPosition = 50;
              
              // Header wiederholen
              doc.fontSize(10)
                 .font('Helvetica-Bold');
              doc.text('Pos.', col1, yPosition);
              doc.text('Bezeichnung', col2, yPosition);
              doc.text('Menge', col3, yPosition);
              doc.text('Einheit', col4, yPosition);
              doc.text('EP (€)', col5, yPosition);
              doc.text('GP (€)', col6, yPosition);
              
              doc.moveTo(col1, yPosition + 15)
                 .lineTo(545, yPosition + 15)
                 .stroke();
              
              yPosition += 25;
              doc.font('Helvetica')
                 .fontSize(9);
            }
            
            // Position
            doc.text(pos.pos || `${index + 1}`, col1, yPosition, { width: 35 });
            
            // Titel mit Höhenberechnung
            const titleHeight = doc.heightOfString(pos.title || '', { width: 150 });
            doc.text(pos.title || 'Keine Bezeichnung', col2, yPosition, { width: 150 });
            
            // Andere Spalten auf gleicher Höhe
            doc.text(pos.quantity?.toString() || '-', col3, yPosition, { width: 50, align: 'right' });
            doc.text(pos.unit || '-', col4, yPosition, { width: 50 });
            
            if (withPrices && pos.unitPrice) {
              doc.text(formatCurrency(pos.unitPrice), col5, yPosition, { width: 70, align: 'right' });
              doc.text(formatCurrency(pos.totalPrice || 0), col6, yPosition, { width: 70, align: 'right' });
              tradeSum += parseFloat(pos.totalPrice) || 0; // FIX: Berechnung der Gewerk-Summe
            } else {
              doc.text('________', col5, yPosition, { width: 70, align: 'right' });
              doc.text('________', col6, yPosition, { width: 70, align: 'right' });
            }
            
            // Zeilenhöhe basierend auf Titel
            yPosition += Math.max(titleHeight, 20) + 5;
            
            // Beschreibung mit Abstandsprüfung
            if (pos.description) {
              const descHeight = doc.heightOfString(pos.description, { width: 400 });
              
              // Prüfe ob Beschreibung auf Seite passt
              if (yPosition + descHeight > 680) {
                doc.addPage();
                yPosition = 50;
              }
              
              doc.fontSize(8)
                 .fillColor('#666666')
                 .text(pos.description, col2, yPosition, { width: 400 });
              
              yPosition += descHeight + 10; // Extra Abstand nach Beschreibung
              
              doc.fontSize(9)
                 .fillColor('black');
            } else {
              yPosition += 8; // Kleinerer Abstand ohne Beschreibung
            }
          });
        }
        
        // Gewerk-Summe
        yPosition += 10;
        doc.moveTo(col5 - 10, yPosition)
           .lineTo(545, yPosition)
           .stroke();
        
        yPosition += 10;
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .text(`Summe ${row.trade_code}:`, col5 - 80, yPosition)
           .text(withPrices ? formatCurrency(tradeSum) : '________', col6, yPosition, { width: 70, align: 'right' }); // FIX: Verwendung der berechneten Summe
      }
      
      // Abschlussseite mit Zusammenfassung
      doc.addPage();
      
      doc.fontSize(18)
         .font('Helvetica-Bold')
         .text('KOSTENZUSAMMENFASSUNG', { align: 'center' });
      
      doc.moveDown(2);
      
      // Gewerke-Übersicht
      doc.fontSize(12)
         .font('Helvetica-Bold')
         .text('Einzelkosten der Gewerke:');
      
      doc.moveDown(0.5);
      doc.fontSize(11)
         .font('Helvetica');
      
      for (const trade of tradeSummaries) {
        doc.text(`${trade.code} - ${trade.name}:`, 70, doc.y)
           .text(withPrices ? formatCurrency(trade.total) : '________', 400, doc.y - 11, { width: 100, align: 'right' });
      }
      
      doc.moveDown(1);
      doc.moveTo(70, doc.y)
         .lineTo(500, doc.y)
         .stroke();
      
      doc.moveDown(0.5);
      
      if (withPrices) {
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Nettosumme:', 70, doc.y)
           .text(formatCurrency(grandTotal), 400, doc.y - 12, { width: 100, align: 'right' });
        
        doc.moveDown(0.5);
        
        const planningCosts = grandTotal * 0.10;
        const contingency = grandTotal * 0.05;
        const subtotal = grandTotal + planningCosts + contingency;
        const vat = subtotal * 0.19;
        const finalTotal = subtotal + vat;
        
        doc.fontSize(11)
           .font('Helvetica')
           .text('Planungskosten (10%):', 70, doc.y)
           .text(formatCurrency(planningCosts), 400, doc.y - 11, { width: 100, align: 'right' });
        
        doc.text('Unvorhergesehenes (5%):', 70, doc.y)
           .text(formatCurrency(contingency), 400, doc.y - 11, { width: 100, align: 'right' });
        
        doc.moveDown(0.5);
        doc.font('Helvetica-Bold')
           .text('Zwischensumme:', 70, doc.y)
           .text(formatCurrency(subtotal), 400, doc.y - 11, { width: 100, align: 'right' });
        
        doc.moveDown(0.5);
        doc.font('Helvetica')
           .text('MwSt. (19%):', 70, doc.y)
           .text(formatCurrency(vat), 400, doc.y - 11, { width: 100, align: 'right' });
        
        doc.moveDown(0.5);
        doc.moveTo(70, doc.y)
           .lineTo(500, doc.y)
           .stroke();
        doc.moveTo(70, doc.y + 2)
           .lineTo(500, doc.y + 2)
           .stroke();
        
        doc.moveDown(0.5);
        doc.fontSize(14)
           .font('Helvetica-Bold')
           .text('GESAMTSUMME:', 70, doc.y)
           .text(formatCurrency(finalTotal), 380, doc.y - 14, { width: 120, align: 'right' });
      } else {
        doc.fontSize(12)
           .font('Helvetica-Bold')
           .text('Gesamtsumme:', 70, doc.y)
           .text('________', 400, doc.y - 12, { width: 100, align: 'right' });
      }
      
      // Footer
      doc.fontSize(8)
         .font('Helvetica')
         .fillColor('#666666')
         .text('Alle Preise verstehen sich inklusive aller Nebenleistungen gemäß VOB/C.', 50, 750)
         .text(`Erstellt am ${new Date().toLocaleDateString('de-DE')} mit BYNDL`, 50, 765);
      
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}

/**
 * PDF Generation für LV
 */
function formatCurrency(amount) {
  if (!amount && amount !== 0) return '________';
  return new Intl.NumberFormat('de-DE', {
    style: 'currency',
    currency: 'EUR'
  }).format(amount);
}

function generateLVPDF(lv, tradeName, tradeCode, projectDescription, withPrices = true) {
  return new Promise((resolve, reject) => {
    try {
      const doc = new PDFDocument({
        size: 'A4',
        margins: { top: 50, bottom: 50, left: 50, right: 50 }
      });

      const chunks = [];
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));

      // Header
      doc.fontSize(20)
         .font('Helvetica-Bold')
         .text('LEISTUNGSVERZEICHNIS', { align: 'center' });
      
      doc.moveDown(0.5);
      
      doc.fontSize(14)
         .font('Helvetica')
         .fillColor('#666666')
         .text(withPrices ? 'Kalkulation' : 'Angebotsanfrage', { align: 'center' });
      
      doc.moveDown(1.5);
      
      // NEU: Vorbemerkungen einfügen (nach Projektinfo, vor Positionen)
  if (lv.vorbemerkungen && lv.vorbemerkungen.length > 0) {
    doc.moveDown(1);
    doc.fontSize(12)
       .font('Helvetica-Bold')
       .text('VORBEMERKUNGEN', { underline: true });
    
    doc.moveDown(0.5);
    doc.fontSize(10)
       .font('Helvetica');
    
    lv.vorbemerkungen.forEach((vorbemerkung, index) => {
      doc.text(`${index + 1}. ${vorbemerkung}`, {
        indent: 20,
        width: 500
      });
      doc.moveDown(0.3);
    });
    
    doc.moveDown(0.5);
    doc.moveTo(50, doc.y)
       .lineTo(545, doc.y)
       .stroke();
    doc.moveDown(1);
  }
  
 // Projektinfo
      doc.fontSize(12)
         .fillColor('black')
         .font('Helvetica-Bold')
         .text('Projektbeschreibung:', { continued: false });
      
      doc.font('Helvetica')
         .text(projectDescription || 'Keine Beschreibung vorhanden');
      
      doc.moveDown(0.5);
      
      doc.font('Helvetica-Bold')
         .text('Gewerk: ', { continued: true })
         .font('Helvetica')
         .text(`${tradeCode} - ${tradeName}`);
      
      doc.moveDown(0.5);
      
      doc.font('Helvetica-Bold')
         .text('Erstellt am: ', { continued: true })
         .font('Helvetica')
         .text(new Date().toLocaleDateString('de-DE', {
           year: 'numeric',
           month: 'long',
           day: 'numeric'
         }));
      
      // Datenqualität anzeigen
      if (lv.dataQuality) {
        doc.moveDown(0.5);
        doc.font('Helvetica-Bold')
           .text('Datenqualität: ', { continued: true })
           .font('Helvetica')
           .text(`${Math.round(lv.dataQuality.confidence * 100)}% Konfidenz`);
      }
      
      doc.moveDown(1);
      
      // Trennlinie
      doc.moveTo(50, doc.y)
         .lineTo(545, doc.y)
         .stroke();
      
      doc.moveDown(1);
      
      if (!withPrices) {
        doc.fontSize(10)
           .fillColor('#FF6600')
           .font('Helvetica-Oblique')
           .text('Hinweis: Bitte tragen Sie Ihre Preise in die vorgesehenen Felder ein.', { align: 'center' });
        doc.moveDown(1);
        doc.fillColor('black');
      }
      
      // Positionen
      doc.font('Helvetica-Bold')
         .fontSize(14)
         .text('POSITIONEN', { underline: true });
      
      doc.moveDown(0.5);
      
      const tableTop = doc.y;
      const col1 = 50;  
      const col2 = 90;  
      const col3 = 250; 
      const col4 = 310; 
      const col5 = 370; 
      const col6 = 450; 
      
      doc.fontSize(10)
         .font('Helvetica-Bold');
      
      doc.text('Pos.', col1, tableTop);
      doc.text('Bezeichnung', col2, tableTop);
      doc.text('Menge', col3, tableTop);
      doc.text('Einheit', col4, tableTop);
      doc.text('EP (€)', col5, tableTop);
      doc.text('GP (€)', col6, tableTop);
      
      doc.moveTo(col1, tableTop + 15)
         .lineTo(545, tableTop + 15)
         .stroke();
      
      let yPosition = tableTop + 25;
      let totalSum = 0;
      
      doc.font('Helvetica')
         .fontSize(9);
      
      if (lv && lv.positions && Array.isArray(lv.positions)) {
        lv.positions.forEach((pos, index) => {
          if (yPosition > 700) {
            doc.addPage();
            yPosition = 50;
            
            doc.fontSize(10)
               .font('Helvetica-Bold');
            doc.text('Pos.', col1, yPosition);
            doc.text('Bezeichnung', col2, yPosition);
            doc.text('Menge', col3, yPosition);
            doc.text('Einheit', col4, yPosition);
            doc.text('EP (€)', col5, yPosition);
            doc.text('GP (€)', col6, yPosition);
            
            doc.moveTo(col1, yPosition + 15)
               .lineTo(545, yPosition + 15)
               .stroke();
            
            yPosition += 25;
            doc.font('Helvetica')
               .fontSize(9);
          }
          
          // Position mit NEP-Kennzeichnung
let posText = pos.pos || `${index + 1}`;
if (pos.isNEP) {
  posText += ' (NEP)';
}
doc.text(posText, col1, yPosition, { width: 30 });
          
          let titleText = pos.title || 'Keine Bezeichnung';
if (pos.isNEP) {
  titleText = '(NEP) ' + titleText;
}
const titleHeight = doc.heightOfString(titleText, { width: 150 });
doc.text(titleText, col2, yPosition, { width: 150 });
          
          doc.text(pos.quantity?.toString() || '-', col3, yPosition, { width: 50, align: 'right' });
          doc.text(pos.unit || '-', col4, yPosition, { width: 50 });
          
          if (withPrices && pos.unitPrice) {
            doc.text(formatCurrency(pos.unitPrice), col5, yPosition, { width: 70, align: 'right' });
          } else {
            doc.text('________', col5, yPosition, { width: 70, align: 'right' });
          }
          
          if (withPrices && pos.totalPrice) {
  // NEU: Bei NEP-Positionen den Preis in Klammern setzen
  if (pos.isNEP) {
    doc.text(`(${formatCurrency(pos.totalPrice)})`, col6, yPosition, { 
      width: 70, 
      align: 'right' 
    });
    // NEP nicht zur totalSum addieren!
  } else {
    doc.text(formatCurrency(pos.totalPrice), col6, yPosition, { 
      width: 70, 
      align: 'right' 
    });
    totalSum += parseFloat(pos.totalPrice) || 0;
  }
} else {
  doc.text('________', col6, yPosition, { width: 70, align: 'right' });
}
          
          // Beschreibung und Datenquelle
          if (pos.description) {
            yPosition += Math.max(titleHeight, 15);
            doc.fontSize(8)
               .fillColor('#666666')
               .text(pos.description, col2, yPosition, { width: 400 });
            
            const descHeight = doc.heightOfString(pos.description, { width: 400 });
            yPosition += descHeight;
            
            // FIX: Datenquelle UNTER der Beschreibung anzeigen
            if (pos.dataSource && pos.dataSource !== 'measured') {
              const sourceText = pos.dataSource === 'estimated' ? '(geschätzt)' : '(angenommen)';
              yPosition += 2; // Kleine Lücke
              doc.fontSize(7)
                 .fillColor('#FF6600')
                 .text(sourceText, col2, yPosition);
              yPosition += 10; // Abstand nach Label
            }
            
            doc.fontSize(9)
               .fillColor('black');
          } else {
            yPosition += Math.max(titleHeight, 15);
          }
          
          yPosition += 5;
        });
      }
      
      // Summen
      yPosition += 10;
      
      if (yPosition > 650) {
        doc.addPage();
        yPosition = 50;
      }
      
      doc.moveTo(col5 - 10, yPosition)
         .lineTo(545, yPosition)
         .stroke();
      
      yPosition += 10;
      
      if (withPrices) {
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .text('Nettosumme:', col5 - 80, yPosition)
           .text(formatCurrency(totalSum), col6, yPosition, { width: 70, align: 'right' });

        // NEU: NEP-Summe anzeigen wenn vorhanden
  if (lv.nepSum && lv.nepSum > 0) {
    yPosition += 20;
    doc.fontSize(9)
       .font('Helvetica')
       .fillColor('#666666')
       .text('NEP-Positionen:', col5 - 80, yPosition)
       .text(formatCurrency(lv.nepSum), col6, yPosition, { width: 70, align: 'right' });
    doc.fillColor('black');
  }
        
        yPosition += 20;
        
        const vat = totalSum * 0.19;
        doc.font('Helvetica')
           .text('MwSt. (19%):', col5 - 80, yPosition)
           .text(formatCurrency(vat), col6, yPosition, { width: 70, align: 'right' });
        
        yPosition += 20;
        
        doc.moveTo(col5 - 10, yPosition - 5)
           .lineTo(545, yPosition - 5)
           .stroke();
        doc.moveTo(col5 - 10, yPosition - 3)
           .lineTo(545, yPosition - 3)
           .stroke();
        
        doc.fontSize(11)
           .font('Helvetica-Bold')
           .text('Gesamtsumme:', col5 - 80, yPosition + 5)
           .text(formatCurrency(totalSum + vat), col6, yPosition + 5, { width: 70, align: 'right' });
      } else {
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .text('Gesamtsumme:', col5 - 80, yPosition)
           .text('________', col6, yPosition, { width: 70, align: 'right' });
      }
      
      // Annahmen anzeigen
      if (lv.assumptions && lv.assumptions.length > 0) {
        yPosition += 40;
        
        if (yPosition > 650) {
          doc.addPage();
          yPosition = 50;
        }
        
        doc.fontSize(10)
           .font('Helvetica-Bold')
           .text('Annahmen und Hinweise:', 50, yPosition);
        
        yPosition += 15;
        doc.fontSize(8)
           .font('Helvetica');
        
        lv.assumptions.forEach(assumption => {
          doc.text(`• ${assumption}`, 60, yPosition, { width: 485 });
          yPosition += doc.heightOfString(assumption, { width: 485 }) + 5;
        });
      }
      
      // Footer
      doc.fontSize(8)
         .font('Helvetica')
         .fillColor('#666666')
         .text('Alle Preise verstehen sich inklusive aller Nebenleistungen gemäß VOB/C.', 50, 750)
         .text('Erstellt mit BYNDL - KI-gestützte Bauprojektplanung', 50, 765);
      
      doc.end();
      
    } catch (error) {
      reject(error);
    }
  });
}    
    

// ===========================================================================
// EXPRESS APP
// ===========================================================================

const app = express();

// CORS Configuration
const allowedOrigins = [
  'https://byndl-poc.netlify.app',
  'https://byndl.de',
  'http://localhost:3000',
  'http://localhost:5173'
];

app.use(cors({
  origin: (origin, callback) => {
    if (!origin || allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error('Not allowed by CORS'));
    }
  },
  credentials: true
}));

app.use(express.json());
app.use(bodyParser.json());

// ===========================================================================
// ROUTES
// ===========================================================================

// Health Check
app.get('/', (req, res) => {
  res.json({ 
    message: 'BYNDL Backend v4.0',
    status: 'running',
    timestamp: new Date().toISOString(),
    features: [
      'Intelligente Fragenanzahl nach Gewerke-Komplexität',
      'Detaillierte Mengenerfassung',
      'Realistische LV-Generierung',
      'Laienverständliche Fragen',
      'Intelligente Schätzlogik'
    ]
  });
});

// DB Ping
app.get('/api/dbping', async (req, res) => {
  try {
    const result = await query('SELECT NOW() as time, version() as version');
    res.json({ 
      ok: true, 
      time: result.rows[0].time,
      version: result.rows[0].version 
    });
  } catch (err) {
    console.error('DB ping failed:', err);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// Get all trades
app.get('/api/trades', async (req, res) => {
  try {
    const trades = await getAvailableTrades();
    
    // Füge Komplexitätsinformationen hinzu
    const tradesWithComplexity = trades.map(trade => ({
      ...trade,
      complexity: TRADE_COMPLEXITY[trade.code] || DEFAULT_COMPLEXITY
    }));
    
    res.json(tradesWithComplexity);
  } catch (err) {
    console.error('Failed to fetch trades:', err);
    res.status(500).json({ error: 'Failed to fetch trades' });
  }
});

// Create project with trade detection
app.post('/api/projects', async (req, res) => {
  try {
    const { 
      category, 
      subCategory, 
      description, 
      timeframe, 
      budget, 
      bauherrId,
      address,      // Frontend sendet address-Objekt
      userName,     // Auch diese Felder kommen vom Frontend
      userEmail
    } = req.body;
    
    // Address-Daten extrahieren - Frontend sendet "zipCode" (camelCase)
    const { street, houseNumber, zipCode, city } = address || {};
    
    // Debug-Log um zu sehen was ankommt
    console.log('Received address data:', { street, houseNumber, zipCode, city });
    
    if (!description) {
      return res.status(400).json({ error: 'Description is required' });
    }
    
    const extractedData = extractProjectKeyData(description, category);
    
    // INSERT mit korrektem Mapping: zipCode -> zip_code
    const projectResult = await query(
  `INSERT INTO projects (
    bauherr_id, category, sub_category, description, 
    timeframe, budget, 
    street, house_number, zip_code, city,
    metadata
  )
  VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
  RETURNING *`,
  [
    bauherrId || null,
    category || null,
    subCategory || null,
    description,
    timeframe || null,
    budget || null,
    street || null,        // NEU
    houseNumber || null,   // NEU
    zipCode || null,
    city || null,
    JSON.stringify({ extracted: extractedData })
  ]
);

// DEBUG - HIER EINFÜGEN:
console.log('=== INSERTED PROJECT ===');
console.log('Street from DB:', projectResult.rows[0].street);
console.log('House number from DB:', projectResult.rows[0].house_number);
console.log('Full project:', projectResult.rows[0]);

    const project = projectResult.rows[0];

     // NEU: Geocoding im Hintergrund starten
    if (street && houseNumber && zipCode && city) {
      ensureProjectGeocoded(project.id).catch(err => 
        console.error('Background geocoding failed:', err)
      );
    }
    
    // ERST Trades erkennen
    const detectedTrades = await detectTrades({
      category,
      subCategory,
      description,
      timeframe,
      budget,
      extractedData // NEU: Weitergabe der extrahierten Daten
    });
    
    // DANN Komplexität berechnen (mit den erkannten Trades)
    const projectComplexity = determineProjectComplexity({
      ...project,
      detectedTrades: detectedTrades  // Jetzt ist detectedTrades definiert!
    });
    
    // Komplexität in Metadata speichern (zusammen mit extrahierten Daten)
    await query(
      `UPDATE projects 
       SET metadata = jsonb_set(
         jsonb_set(
           COALESCE(metadata, '{}')::jsonb,
           '{complexity}',
           $1::jsonb
         ),
         '{extracted}',
         $2::jsonb
       )
       WHERE id = $3`,
      [
        JSON.stringify({
          level: projectComplexity,
          calculatedAt: new Date().toISOString(),
          tradeCount: detectedTrades.length
        }), 
        JSON.stringify(extractedData),
        project.id
      ]
    );
    
    // Nur erkannte Trades hinzufügen
    console.log(`[PROJECT] Creating project ${project.id} with ${detectedTrades.length} detected trades`);
    console.log(`[PROJECT] Project complexity: ${projectComplexity}`);
    console.log(`[PROJECT] Extracted quantities:`, extractedData.quantities);
    console.log(`[PROJECT] Extracted measures:`, extractedData.measures);
    
    for (const trade of detectedTrades) {
      await ensureProjectTrade(project.id, trade.id, 'detection');
    }
    
    res.json({
      project: {
        ...project,
        trades: detectedTrades,
        complexity: projectComplexity,  // Verwende die berechnete Komplexität
        extractedData // NEU: Sende extrahierte Daten zurück an Frontend
      }
    });
    
  } catch (err) {
    console.error('Failed to create project:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get project details
app.get('/api/projects/:projectId', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const projectResult = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    const project = projectResult.rows[0];
    const trades = await getProjectTrades(projectId);
    
    // Parse metadata falls vorhanden
    if (project.metadata && typeof project.metadata === 'string') {
      try {
        project.metadata = JSON.parse(project.metadata);
      } catch (e) {
        console.error('[PROJECT] Failed to parse metadata:', e);
        project.metadata = {};
      }
    }
    
    // NEU: Verwende gespeicherte Komplexität ODER berechne mit den geladenen Trades
    const projectComplexity = project.metadata?.complexity?.level || 
      determineProjectComplexity({
        ...project,
        detectedTrades: trades  // WICHTIG: Übergebe die geladenen Trades!
      });
    
    const extractedData = project.metadata?.extracted || null;
    
    project.trades = trades;
    project.complexity = projectComplexity;  // Verwende korrekte Komplexität
    project.extractedData = extractedData;
    
    console.log(`[PROJECT] Retrieved project ${projectId} with ${trades.length} trades, complexity: ${projectComplexity}`);
    if (extractedData) {
      console.log(`[PROJECT] Has extracted data:`, extractedData.quantities);
    }
    
    res.json(project);
    
  } catch (err) {
    console.error('Failed to fetch project:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get all selected trades for a project (for LVReviewPage)
app.get('/api/projects/:projectId/selected-trades', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    // Hole Projekt
    const project = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (project.rows.length === 0) {
      return res.status(404).json({ error: 'Projekt nicht gefunden' });
    }
    
    // Hole alle Trades die dem Projekt zugeordnet sind (außer INT)
    const trades = await query(`
      SELECT 
        t.id,
        t.code,
        t.name,
        t.description,
        pt.is_manual,
        pt.is_ai_recommended,
        pt.is_additional,
        tp.status as progress_status,
        tp.completed_at,
        tp.reviewed_at,
        l.id as lv_id,
        l.content as lv_content,
        l.status as lv_status,
        l.questions_completed,
        l.skipped
      FROM trades t
      JOIN project_trades pt ON t.id = pt.trade_id
      LEFT JOIN trade_progress tp ON t.id = tp.trade_id AND tp.project_id = $1
      LEFT JOIN lvs l ON t.id = l.trade_id AND l.project_id = $1
      WHERE pt.project_id = $1 
      AND t.code != 'INT'
      ORDER BY t.name
    `, [projectId]);
    
    // Formatiere Trades mit Status
    const formattedTrades = trades.rows.map(trade => {
      let lvContent = null;
      let totalCost = 0;
      
      // Parse LV content wenn vorhanden
      if (trade.lv_content) {
        lvContent = typeof trade.lv_content === 'string' 
          ? JSON.parse(trade.lv_content) 
          : trade.lv_content;
        
        // Berechne Gesamtkosten (ohne NEP)
        if (lvContent.totalSum) {
          totalCost = parseFloat(lvContent.totalSum) || 0;
        } else if (lvContent.positions) {
          totalCost = lvContent.positions
            .filter(pos => !pos.isNEP)
            .reduce((sum, pos) => sum + (parseFloat(pos.totalPrice) || 0), 0);
        }
      }
      
      return {
        id: trade.id,
        name: trade.name,
        code: trade.code,
        description: trade.description,
        isManual: trade.is_manual || false,
        isAiRecommended: trade.is_ai_recommended || false,
        isAdditional: trade.is_additional || false,
        status: trade.progress_status || 'pending',
        hasLV: !!trade.lv_id,
        lvId: trade.lv_id,
        lv: lvContent,
        totalCost: totalCost,
        questionsCompleted: trade.questions_completed || false,
        skipped: trade.skipped || false,
        completedAt: trade.completed_at,
        reviewedAt: trade.reviewed_at
      };
    });
    
    // Kategorisiere nach Status
    const completedTrades = formattedTrades.filter(t => t.hasLV && !t.skipped);
    const pendingTrades = formattedTrades.filter(t => !t.hasLV && !t.skipped);
    const skippedTrades = formattedTrades.filter(t => t.skipped);
    
    res.json({ 
      trades: formattedTrades,
      summary: {
        total: formattedTrades.length,
        completed: completedTrades.length,
        pending: pendingTrades.length,
        skipped: skippedTrades.length,
        totalCost: completedTrades.reduce((sum, t) => sum + t.totalCost, 0)
      },
      projectStatus: {
        id: project.rows[0].id,
        name: project.rows[0].description,
        budget: project.rows[0].budget,
        allTradesCompleted: project.rows[0].all_trades_completed || false
      }
    });
    
  } catch (error) {
    console.error('Error fetching selected trades:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Gewerke' });
  }
});

// NEU: Navigation Helper Endpoint
app.get('/api/projects/:projectId/navigation', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    // Hole alle Trades des Projekts
    const trades = await query(`
      SELECT 
        t.id,
        t.name,
        t.code,
        COALESCE(tp.status, 'pending') as status,
        l.id as lv_id
      FROM trades t
      JOIN project_trades pt ON t.id = pt.trade_id
      LEFT JOIN trade_progress tp ON t.id = tp.trade_id AND tp.project_id = $1
      LEFT JOIN lvs l ON t.id = l.trade_id AND l.project_id = $1
      WHERE pt.project_id = $1
      AND t.code != 'INT'
      ORDER BY t.name
    `, [projectId]);
    
    const completedTrades = trades.rows.filter(t => t.lv_id);
    const pendingTrades = trades.rows.filter(t => !t.lv_id && t.status === 'pending');
    
    res.json({
      totalTrades: trades.rows.length,
      completedTrades: completedTrades,
      pendingTrades: pendingTrades,
      allCompleted: pendingTrades.length === 0,
      nextTrade: pendingTrades[0] || null
    });
    
  } catch (error) {
    console.error('Error fetching navigation info:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Navigation' });
  }
});

// NEU: Project Status Endpoint
app.get('/api/projects/:projectId/status', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const project = await query('SELECT * FROM projects WHERE id = $1', [projectId]);
    
    if (project.rows.length === 0) {
      return res.status(404).json({ error: 'Projekt nicht gefunden' });
    }
    
    // Detaillierter Status mit LV-Informationen
    const tradeDetails = await query(`
      SELECT 
        t.id,
        t.name,
        t.code,
        tp.status as progress_status,
        l.id as lv_id,
        l.content as lv_content,
        l.skipped
      FROM trades t
      JOIN project_trades pt ON t.id = pt.trade_id
      LEFT JOIN trade_progress tp ON t.id = tp.trade_id AND tp.project_id = $1
      LEFT JOIN lvs l ON t.id = l.trade_id AND l.project_id = $1
      WHERE pt.project_id = $1
      AND t.code != 'INT'
    `, [projectId]);
    
    const pendingTrades = tradeDetails.rows.filter(t => !t.lv_id && !t.skipped);
    const completedTrades = tradeDetails.rows.filter(t => t.lv_id && !t.skipped);
    
    // Berechne Gesamtkosten
    let totalCost = 0;
    completedTrades.forEach(trade => {
      if (trade.lv_content) {
        const content = typeof trade.lv_content === 'string' 
          ? JSON.parse(trade.lv_content) 
          : trade.lv_content;
        totalCost += parseFloat(content.totalSum) || 0;
      }
    });
    
    res.json({
      projectId: projectId,
      projectName: project.rows[0].description,
      allTradesComplete: pendingTrades.length === 0,
      totalTrades: tradeDetails.rows.length,
      completedCount: completedTrades.length,
      pendingCount: pendingTrades.length,
      pendingTrades: pendingTrades.map(t => ({
        id: t.id,
        name: t.name,
        code: t.code
      })),
      totalCost: totalCost
    });
    
  } catch (error) {
    console.error('Error fetching project status:', error);
    res.status(500).json({ error: 'Fehler beim Laden des Status' });
  }
});

// NEU: Mark trade as complete
app.post('/api/projects/:projectId/trades/:tradeId/complete', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { questionsCompleted, lvGenerated } = req.body;
    
    // Upsert in trade_progress
    await query(`
      INSERT INTO trade_progress (
        project_id, 
        trade_id, 
        status, 
        completed_at
      ) VALUES ($1, $2, $3, NOW())
      ON CONFLICT (project_id, trade_id)
      DO UPDATE SET 
        status = $3,
        completed_at = NOW()
    `, [projectId, tradeId, lvGenerated ? 'lv_generated' : 'questions_completed']);
    
    // Update LV status wenn vorhanden
    if (lvGenerated) {
      await query(
        'UPDATE lvs SET status = $1, questions_completed = $2 WHERE project_id = $3 AND trade_id = $4',
        ['generated', true, projectId, tradeId]
      );
    }
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error marking trade complete:', error);
    res.status(500).json({ error: 'Fehler beim Markieren des Gewerks' });
  }
});

// NEU: Skip trade
app.post('/api/projects/:projectId/trades/:tradeId/skip', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    // Markiere als übersprungen
    await query(`
      INSERT INTO trade_progress (
        project_id,
        trade_id,
        status,
        completed_at
      ) VALUES ($1, $2, 'skipped', NOW())
      ON CONFLICT (project_id, trade_id)
      DO UPDATE SET
        status = 'skipped',
        completed_at = NOW()
    `, [projectId, tradeId]);
    
    // Update LV falls vorhanden
    await query(
      'UPDATE lvs SET skipped = TRUE WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error skipping trade:', error);
    res.status(500).json({ error: 'Fehler beim Überspringen' });
  }
});

// NEU: Mark LV as reviewed (nach den anderen neuen Endpoints)
app.post('/api/projects/:projectId/trades/:tradeId/review-complete', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    // Update trade_progress
    await query(`
      UPDATE trade_progress 
      SET status = 'reviewed', reviewed_at = NOW()
      WHERE project_id = $1 AND trade_id = $2
    `, [projectId, tradeId]);
    
    // Falls kein Eintrag existiert, erstelle einen
    const result = await query(
      'SELECT * FROM trade_progress WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (result.rows.length === 0) {
      await query(`
        INSERT INTO trade_progress (project_id, trade_id, status, reviewed_at, completed_at)
        VALUES ($1, $2, 'reviewed', NOW(), NOW())
      `, [projectId, tradeId]);
    }
    
    // Update LV
    await query(
      'UPDATE lvs SET reviewed_at = NOW(), status = $1 WHERE project_id = $2 AND trade_id = $3',
      ['reviewed', projectId, tradeId]
    );
    
    // Update project last_reviewed_at
    await query(
      'UPDATE projects SET last_reviewed_at = NOW() WHERE id = $1',
      [projectId]
    );
    
    // Prüfe ob alle Trades reviewed sind
    const allTrades = await query(`
      SELECT COUNT(*) as total
      FROM project_trades pt
      JOIN trades t ON pt.trade_id = t.id
      WHERE pt.project_id = $1 AND t.code != 'INT'
    `, [projectId]);
    
    const reviewedTrades = await query(`
      SELECT COUNT(*) as reviewed
      FROM trade_progress
      WHERE project_id = $1 AND status = 'reviewed'
    `, [projectId]);
    
    const allReviewed = allTrades.rows[0].total === reviewedTrades.rows[0].reviewed;
    
    if (allReviewed) {
      await query(
        'UPDATE projects SET all_trades_completed = TRUE WHERE id = $1',
        [projectId]
      );
    }
    
    res.json({ 
      success: true,
      allReviewed: allReviewed,
      message: allReviewed ? 'Alle Gewerke wurden überprüft' : 'Gewerk als überprüft markiert'
    });
    
  } catch (error) {
    console.error('Error marking review complete:', error);
    res.status(500).json({ error: 'Fehler beim Markieren der Review' });
  }
});

// Generate Intake Questions
app.post('/api/projects/:projectId/intake/questions', async (req, res) => {
  try {
    const { projectId } = req.params;

    const projectResult = await query('SELECT * FROM projects WHERE id = $1', [projectId]);
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    const project = projectResult.rows[0];

    const intTrade = await query(`SELECT id FROM trades WHERE code = 'INT' LIMIT 1`);
    if (intTrade.rows.length === 0) {
      return res.status(500).json({ error: 'INT trade missing in DB' });
    }
    const tradeId = intTrade.rows[0].id;
    
    await ensureProjectTrade(projectId, tradeId, 'intake');
    
    // Lade erkannte Gewerke
    const detectedTrades = await query(
      `SELECT t.code, t.name 
       FROM trades t 
       JOIN project_trades pt ON t.id = pt.trade_id 
       WHERE pt.project_id = $1 AND t.code != 'INT'`,
      [projectId]
    );

    // Erweitere Projektkontext mit erkannten Gewerken
    const projectContext = {
      category: project.category,
      subCategory: project.sub_category,
      description: project.description,
      timeframe: project.timeframe,
      budget: project.budget,
      detectedTrades: detectedTrades.rows
    };
    
    // NEU: Berechne intelligente Fragenanzahl basierend auf Gewerke-Anzahl
    const tradeCount = detectedTrades.rows.length;
    let targetQuestionCount;
    
    if (tradeCount === 1) {
      targetQuestionCount = 16;  // 14-18 Fragen für Einzelgewerk
    } else if (tradeCount <= 3) {
      targetQuestionCount = 18;  // 16-20 Fragen für 2-3 Gewerke
    } else if (tradeCount <= 5) {
      targetQuestionCount = 21;  // 18-24 Fragen für 4-5 Gewerke
    } else {
      targetQuestionCount = 25;  // 22-28 Fragen für 6+ Gewerke
    }
    
    // Modifiziere Projektkontext mit Ziel-Fragenanzahl
    const modifiedProjectContext = {
      ...projectContext,
      targetQuestionCount: targetQuestionCount,
      tradeCount: tradeCount
    };
    
    let questions;
    try {
      // WICHTIG: Verwende modifiedProjectContext statt projectContext
      questions = await generateQuestions(tradeId, modifiedProjectContext);
    } catch (err) {
      console.error('[INTAKE] generateQuestions error:', err);
      return res.status(500).json({ 
        error: 'Fehler beim Generieren der Intake-Fragen',
        details: err.message 
      });
    }
    
    // Parse questions wenn es ein String ist
    if (typeof questions === 'string') {
      try {
        questions = JSON.parse(questions);
      } catch (e) {
        console.error('[INTAKE] Failed to parse questions:', e);
        return res.status(500).json({ error: 'Fehler beim Generieren der Fragen' });
      }
    }

    // Stelle sicher dass es ein Array ist
    if (!Array.isArray(questions)) {
      console.error('[INTAKE] Questions is not an array:', typeof questions);
      return res.status(500).json({ error: 'Fehler beim Generieren der Fragen' });
    }
    
    // Speichere Fragen mit erweiterten Feldern
    let saved = 0;
    for (const q of questions) {
      // ZUERST in intake_questions speichern für spätere Verwendung
      const intakeQuestionResult = await query(
        `INSERT INTO intake_questions (question_text, question_type, sort_order, is_required, options)
         VALUES ($1, $2, $3, $4, $5)
         RETURNING id`,
        [
          q.question || q.text,
          q.type || 'text',
          saved + 1,  // sort_order basierend auf Position
          q.required !== undefined ? q.required : true,
          q.options ? JSON.stringify(q.options) : null
        ]
      );
      
      const intakeQuestionId = intakeQuestionResult.rows[0].id;
      
      // DANN in questions speichern mit Referenz zur intake_question_id
      await query(
        `INSERT INTO questions (project_id, trade_id, question_id, text, type, required, options)
         VALUES ($1,$2,$3,$4,$5,$6,$7)
         ON CONFLICT (project_id, trade_id, question_id)
         DO UPDATE SET text=$4, type=$5, required=$6, options=$7`,
        [
          projectId,
          tradeId,
          `INT-${intakeQuestionId}`,  // Verwende intake_questions.id als Referenz
          q.question || q.text,
          q.type || 'text',
          q.required !== undefined ? q.required : true,
          q.options ? JSON.stringify(q.options) : null
        ]
      );
      saved++;
    }

    // Hole die echten IDs aus der Datenbank
    const savedQuestions = await query(
      `SELECT question_id FROM questions 
       WHERE project_id = $1 AND trade_id = $2 
       ORDER BY question_id`,
      [projectId, tradeId]
    );

    // Mappe die echten IDs zu den Fragen
    const questionsWithIds = questions.map((q, idx) => ({
      ...q,
      id: savedQuestions.rows[idx]?.question_id || `INT-${idx + 1}`
    }));

    res.json({
      ok: true,
      tradeCode: 'INT',
      questions: questionsWithIds,
      saved,
      targetCount: targetQuestionCount,  // Verwende berechnete Anzahl
      tradeCount: tradeCount,            // Sende Gewerke-Anzahl zurück
      completeness: tradeCount <= 2 ? 'EINFACH' : tradeCount <= 5 ? 'MITTEL' : 'HOCH'
    });
    
  } catch (err) {
    console.error('intake/questions failed:', err);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// Intake Summary
app.get('/api/projects/:projectId/intake/summary', async (req, res) => {
  try {
    const { projectId } = req.params;

    const project = (await query('SELECT * FROM projects WHERE id=$1', [projectId])).rows[0];
    if (!project) return res.status(404).json({ error: 'Project not found' });

    const intTrade = (await query(`SELECT id FROM trades WHERE code='INT'`)).rows[0];
    if (!intTrade) return res.status(500).json({ error: 'INT trade missing' });

    const answers = (await query(
      `SELECT q.text as question, a.answer_text as answer
       FROM answers a
       JOIN questions q ON q.project_id = a.project_id 
         AND q.trade_id = a.trade_id 
         AND q.question_id = a.question_id
       WHERE a.project_id=$1 AND a.trade_id=$2
       ORDER BY q.question_id`,
      [projectId, intTrade.id]
    )).rows;

    const availableTrades = await getAvailableTrades();
    const validCodes = availableTrades.map(t => t.code).filter(c => c !== 'INT');

    const master = await getPromptByName('master');

    const system = `${master}

Analysiere die Intake-Antworten und empfehle die benötigten Gewerke.

VERFÜGBARE GEWERKE (NUR DIESE für "trades"):
${availableTrades.filter(t => t.code !== 'INT').map(t => `- ${t.code}: ${t.name}`).join('\n')}

OUTPUT (NUR valides JSON):
{
  "recommendations": ["Empfehlungen für zusätzliche Experten"],
  "risks": ["Identifizierte Projektrisiken"],
  "missingInfo": ["Fehlende wichtige Informationen"],
  "trades": [
    {
      "code": "SAN",
      "reason": "Begründung warum dieses Gewerk benötigt wird",
      "priority": "hoch|mittel|niedrig",
      "estimatedQuestions": 25
    }
  ],
  "projectCharacteristics": {
    "complexity": "SEHR_HOCH|HOCH|MITTEL|NIEDRIG|EINFACH",
    "estimatedDuration": "4-6 Wochen",
    "criticalPath": ["SAN", "ELEKT"]
  }
}`;

    const user = `Projekt:
${JSON.stringify(project, null, 2)}

Intake-Antworten (${answers.length}):
${answers.map(a => `- ${a.question}: ${a.answer}`).join('\n')}

Analysiere und empfehle benötigte Gewerke.`;

    const raw = await llmWithPolicy('summary', [
      { role: 'system', content: system },
      { role: 'user', content: user }
    ], { maxTokens: 4000, temperature: 0.3, jsonMode: true });

    const cleanedResponse = raw
      .replace(/```json\n?/g, '')
      .replace(/```\n?/g, '')
      .trim();

    const summary = JSON.parse(cleanedResponse);

    // Filtere und validiere Trades
if (summary.trades && Array.isArray(summary.trades)) {
  summary.trades = summary.trades.filter(t => validCodes.includes(t.code));
  
  // Füge geschätzte Fragenanzahl hinzu
  summary.trades = summary.trades.map(t => ({
    ...t,
    estimatedQuestions: t.estimatedQuestions || 
      getTradeQuestionCount(t.code, summary.projectCharacteristics?.complexity || 'MITTEL')
  }));
}

// ========== NEUE VALIDIERTE GEWERKE-ERKENNUNG ==========
// Hole NUR die ERFORDERLICHEN Gewerke (nicht die empfohlenen!)
const requiredTradesResult = await query(
  `SELECT t.code FROM project_trades pt 
   JOIN trades t ON pt.trade_id = t.id 
   WHERE pt.project_id = $1 
   AND t.code != 'INT'
   AND (pt.is_ai_recommended = false OR pt.is_ai_recommended IS NULL)`,
  [projectId]
);
const requiredTradesForValidation = requiredTradesResult.rows.map(r => r.code); // NUR die Code-Strings!

// Nutze neue Validierungsfunktion
const projectDescription = project.description || '';
const validationResult = detectAndValidateTradesFromIntake(
  answers,
  requiredTradesForValidation,  // GEÄNDERT: Neuer Name
  projectDescription
);

// Filtere bereits empfohlene Trades heraus
const alreadyRecommended = await query(
  `SELECT t.code FROM project_trades pt 
   JOIN trades t ON pt.trade_id = t.id 
   WHERE pt.project_id = $1 AND pt.is_ai_recommended = true`,
  [projectId]
);
const recommendedCodes = new Set(alreadyRecommended.rows.map(r => r.code));

// Filtere und verwende nur eine Variable
const additionalTrades = validationResult.trades.filter(t => 
  !recommendedCodes.has(t.code)
);

const rejectedTrades = validationResult.rejected;
    
// Für Kompatibilität mit bestehendem Code
const relevantAnswers = answers
  .filter(a => a.answer.length > 15 && !['ja', 'nein', 'keine', 'vorhanden'].includes(a.answer.toLowerCase().trim()))
  .map(a => ({ question: a.question, answer: a.answer }));

// Definiere allAnswersText für Keyword-Matching
const allAnswersText = answers.map(a => `${a.question} ${a.answer}`).join(' ').toLowerCase();
    
console.log('[INTAKE-VALIDATION] Erkannt:', additionalTrades.length, 'Gewerke');
if (rejectedTrades.length > 0) {
  console.log('[INTAKE-VALIDATION] Abgelehnt:', rejectedTrades.map(r => 
    `${r.code}: ${r.reason}`
  ));
}
// ========== ENDE NEUE VALIDIERUNG ==========

// Debug-Logs NACH den Definitionen
console.log('[DEBUG] additionalTrades found:', additionalTrades.length);
console.log('[DEBUG] relevantAnswers count:', relevantAnswers.length);

// LLM-basierte Analyse für intelligente Begründungen
if (additionalTrades.length > 0) {
  console.log('[INTAKE-SUMMARY] Starte LLM-Analyse für', additionalTrades.length, 'Trades');
  
  const tradeNames = {
    'ELEKT': 'Elektroinstallationen',
    'SAN': 'Sanitärinstallationen', 
    'HEI': 'Heizungsinstallation',
    'KLIMA': 'Klimatechnik',
    'TIS': 'Tischlerarbeiten',
    'FLI': 'Fliesenarbeiten',
    'MAL': 'Malerarbeiten',
    'BOD': 'Bodenbelagsarbeiten',
    'TRO': 'Trockenbauarbeiten',
    'FEN': 'Fensterarbeiten',
    'ROH': 'Rohbauarbeiten',
    'DACH': 'Dacharbeiten',
    'FASS': 'Fassadenarbeiten',
    'GER': 'Gerüstbau',
    'ZIMM': 'Zimmererarbeiten',
    'ESTR': 'Estricharbeiten',
    'SCHL': 'Schlosserarbeiten',
    'AUSS': 'Außenanlagen',
    'PV': 'Photovoltaik-Installation',
    'ABBR': 'Abbrucharbeiten'
  };
  
  try {
    // Sammle relevante Nutzerantworten für den Kontext
    const contextAnswers = relevantAnswers
      .slice(0, 6)
      .map(qa => qa.answer)
      .join(' | ');
    
    // Erstelle Trades-Info für Prompt
    const tradesInfo = additionalTrades.map(t => {
      const relevantAnswer = relevantAnswers.find(qa => 
        t.matchedKeywords.some(kw => qa.answer.toLowerCase().includes(kw))
      );
      return `${t.code}: gefunden wegen "${t.matchedKeywords.slice(0,2).join(', ')}" in Antwort "${relevantAnswer ? relevantAnswer.answer.substring(0,50) : 'diverse Angaben'}"`;
    }).join('\n');

    const prompt = `Basierend auf diesen Nutzerangaben:
"${contextAnswers}"

Erstelle kurze, spezifische Begründungen für diese Gewerke:
${tradesInfo}

Gib für jedes Gewerk eine vollständige, verständliche Begründung (15-25 Wörter) die erklärt, 
warum dieses Gewerk basierend auf den konkreten Nutzerangaben benötigt wird.

Beispiel-Format:
{
  "ELEKT": "Zusätzliche Steckdosen im Wohnzimmer benötigen Elektroinstallation",
  "SAN": "Neues WC im Keller erfordert Sanitärarbeiten"
}

Antworte NUR mit validem JSON.`;

    const llmResult = await llmWithPolicy('analysis', [
      { role: 'user', content: prompt }
    ], { maxTokens: 1000, temperature: 0.3, jsonMode: true });
    
    console.log('[LLM] Raw response:', llmResult);
    const reasons = JSON.parse(llmResult);
    
    // Weise die Begründungen zu
    additionalTrades.forEach(trade => {
      trade.reason = reasons[trade.code] || `${tradeNames[trade.code]} basierend auf Ihren Angaben empfohlen`;
      console.log(`[LLM] ${trade.code}: ${trade.reason}`);
    });

    // WICHTIG: Auch validationResult updaten!
if (validationResult && validationResult.trades) {
  validationResult.trades.forEach(trade => {
    if (reasons[trade.code]) {
      trade.reason = reasons[trade.code];
    }
  });
}
    
  } catch (error) {
    console.error('[INTAKE-SUMMARY] LLM failed:', error);
    // Fallback mit Keywords
    additionalTrades.forEach(trade => {
      const keywords = trade.matchedKeywords.slice(0, 2).join(' und ');
      trade.reason = `Wegen erwähnter Begriffe: ${keywords}`;
    });
  }
}

// Sammle ALLE empfohlenen Trades
const allRecommendedTrades = [];

// 1. Speichere neu erkannte Trades
for (const trade of additionalTrades) {
  const tradeInfo = await query('SELECT id, name FROM trades WHERE code = $1', [trade.code]);
  if (tradeInfo.rows[0]) {
    await query(
      `INSERT INTO project_trades (project_id, trade_id, is_ai_recommended)
       VALUES ($1, $2, true)
       ON CONFLICT (project_id, trade_id) 
       DO UPDATE SET is_ai_recommended = true`,
      [projectId, tradeInfo.rows[0].id]
    );
    
    allRecommendedTrades.push({
      id: tradeInfo.rows[0].id,
      code: trade.code,
      name: tradeInfo.rows[0].name,
      reason: trade.reason,
      confidence: trade.confidence,
      matchedKeywords: trade.matchedKeywords
    });
  }
}

// 2. Hole ALLE gespeicherten empfohlenen Trades
const allRecommendedFromDB = await query(
  `SELECT t.id, t.code, t.name
   FROM project_trades pt 
   JOIN trades t ON pt.trade_id = t.id 
   WHERE pt.project_id = $1 
   AND pt.is_ai_recommended = true`,
  [projectId]
);

// Definiere tradeKeywords aus TRADE_DETECTION_RULES
const tradeKeywords = {};
for (const [code, keywords] of Object.entries(TRADE_DETECTION_RULES.exclusive)) {
  tradeKeywords[code] = keywords.slice(0, 10);
}    
    
// 3. Füge gespeicherte hinzu (ohne Duplikate)
const newCodesSet = new Set(additionalTrades.map(t => t.code));
for (const trade of allRecommendedFromDB.rows) {
  if (!newCodesSet.has(trade.code)) {
    const keywords = tradeKeywords[trade.code] || [];
    const matchedKeywords = keywords.filter(kw => allAnswersText.includes(kw));
    
    allRecommendedTrades.push({
      id: trade.id,
      code: trade.code,
      name: trade.name,
      reason: matchedKeywords.length > 0 
        ? `Begriffe gefunden: ${matchedKeywords.join(', ')}` 
        : 'Aus vorheriger Analyse erkannt',
      confidence: 85,
      matchedKeywords: matchedKeywords
    });
  }
}

// 4. Hole erforderliche Trades
const requiredTrades = await query(
  `SELECT t.id, t.code, t.name
   FROM project_trades pt 
   JOIN trades t ON pt.trade_id = t.id 
   WHERE pt.project_id = $1 
   AND (pt.is_ai_recommended = false OR pt.is_ai_recommended IS NULL)
   AND t.code != 'INT'`,
  [projectId]
);

// 5. Erstelle Response mit verbesserter Kategorisierung
// Prüfe ob die Trades aus detectAndValidateTradesFromIntake source/category Info haben
const tradesWithSourceInfo = validationResult?.trades?.some(t => t.source !== undefined);
let groupedTrades; // WICHTIG: Variable außerhalb deklarieren

if (tradesWithSourceInfo) {
  // Hole IDs für die Trades aus validationResult
  const tradesWithIds = await Promise.all(
    validationResult.trades.map(async (trade) => {
      const dbResult = await query(
        'SELECT id, name FROM trades WHERE code = $1',
        [trade.code]
      );
      return {
        ...trade,
        id: dbResult.rows[0]?.id,
        name: dbResult.rows[0]?.name || trade.code
      };
    })
  );
  
  // Neue Version mit IDs
  const allDetectedTrades = [
    ...requiredTrades.rows.map(t => ({ ...t, source: 'description' })),
    ...tradesWithIds  // Jetzt mit IDs!
  ];
  
  groupedTrades = {
    required: allDetectedTrades.filter(t => 
      t.source === 'description' || t.category === 'required'
    ),
    recommended: allDetectedTrades.filter(t => 
      t.source === 'intake' || t.category === 'recommended'
    )
  };
} else {  // <- Direkt nach der schließenden Klammer vom if
  // Fallback: Alte Version ohne source tracking
  groupedTrades = {
    required: requiredTrades.rows.map(trade => ({
      ...trade,
      reason: 'Direkt aus Ihrer Projektbeschreibung erkannt'
    })),
    recommended: allRecommendedTrades
  };
}

console.log('[INTAKE-SUMMARY] Required trades:', groupedTrades.required.length);
console.log('[INTAKE-SUMMARY] Recommended trades:', groupedTrades.recommended.length);

res.json({ 
  ok: true, 
  summary,
  groupedTrades,
  additionalTradesDetected: allRecommendedTrades
});

  } catch (err) {
    console.error('intake/summary failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// Confirm trades for project
app.post('/api/projects/:projectId/trades/confirm', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { confirmedTrades, manuallyAddedTrades = [], aiRecommendedTrades = [], isAdditional } = req.body;
    
    if (!Array.isArray(confirmedTrades) || confirmedTrades.length === 0) {
      return res.status(400).json({ error: 'Keine Gewerke ausgewählt' });
    }
    
    // Start transaction for data consistency
    await query('BEGIN');
    
   try {
  const intTradeResult = await query(`SELECT id FROM trades WHERE code = 'INT'`);
  const intTradeId = intTradeResult.rows[0]?.id;
  
  // Bei zusätzlichen Gewerken: Nicht löschen
  if (!isAdditional) {
    // CLEANUP: Stelle sicher, dass ALLE abhängigen Daten gelöscht werden
    const allTradeIds = await query(
      'SELECT DISTINCT trade_id FROM project_trades WHERE project_id = $1',
      [projectId]
    );
    
    const existingTradeIds = allTradeIds.rows.map(r => r.trade_id);
    const toDelete = existingTradeIds.filter(id => 
      id !== intTradeId && !confirmedTrades.includes(id)
    );
    
    // Lösche für ALLE nicht-bestätigten Trades
    if (toDelete.length > 0) {
      await query('DELETE FROM questions WHERE project_id = $1 AND trade_id = ANY($2::int[])', 
        [projectId, toDelete]);
      await query('DELETE FROM answers WHERE project_id = $1 AND trade_id = ANY($2::int[])', 
        [projectId, toDelete]);
      await query('DELETE FROM lvs WHERE project_id = $1 AND trade_id = ANY($2::int[])', 
        [projectId, toDelete]);
    }
    
    // DANN die normalen DELETE Statements
    // 1. Lösche questions (abhängig von project_trades)
    await query(
      `DELETE FROM questions 
       WHERE project_id = $1 
       AND trade_id != $2
       AND trade_id NOT IN (SELECT unnest($3::int[]))`,
      [projectId, intTradeId || -1, confirmedTrades]
    );
    
    // 2. Lösche answers
    await query(
      `DELETE FROM answers 
       WHERE project_id = $1 
       AND trade_id != $2 
       AND trade_id NOT IN (SELECT unnest($3::int[]))`,
      [projectId, intTradeId || -1, confirmedTrades]
    );
    
    // 3. Lösche lvs falls vorhanden
    await query(
      `DELETE FROM lvs 
       WHERE project_id = $1 
       AND trade_id NOT IN (SELECT unnest($2::int[]))`,
      [projectId, confirmedTrades]
    );
    
    // 4. ZULETZT: Lösche project_trades
    await query(
      `DELETE FROM project_trades 
       WHERE project_id = $1 
       AND trade_id != $2`,
      [projectId, intTradeId || -1]
    );
  }
      
      // Füge bestätigte Trades hinzu
      if (isAdditional) {
        // Bei zusätzlichen Gewerken nur neue hinzufügen
        const existing = await query('SELECT trade_id FROM project_trades WHERE project_id = $1', [projectId]);
        const existingIds = existing.rows.map(r => r.trade_id);
        const newTrades = confirmedTrades.filter(id => !existingIds.includes(id));
        
        for (const tradeId of newTrades) {
          const isManual = manuallyAddedTrades.includes(tradeId);
          const isAiRecommended = aiRecommendedTrades.includes(tradeId);
          
          await query(
  `INSERT INTO project_trades (project_id, trade_id, is_manual, is_ai_recommended)
   VALUES ($1, $2, $3, $4)
   ON CONFLICT (project_id, trade_id) 
   DO UPDATE SET 
     is_manual = EXCLUDED.is_manual, 
     is_ai_recommended = EXCLUDED.is_ai_recommended`,
  [projectId, tradeId, isManual, isAiRecommended]  // KORRIGIERT!
);
        }
      } else {
        // Normale Bestätigung: Alle hinzufügen
        for (const tradeId of confirmedTrades) {
          const isManual = manuallyAddedTrades.includes(tradeId);
          const isAiRecommended = aiRecommendedTrades.includes(tradeId);
          
          await query(
  `INSERT INTO project_trades (project_id, trade_id, is_manual, is_ai_recommended)
   VALUES ($1, $2, $3, $4)
   ON CONFLICT (project_id, trade_id) 
   DO UPDATE SET is_manual = $3, is_ai_recommended = $4`,
  [projectId, tradeId, isManual, isAiRecommended]  // KORRIGIERT!
);

console.log(`[TRADES] Added trade ${tradeId}: manual=${isManual}, AI=${isAiRecommended}`);
        }
      }
      
      await query('COMMIT');
      
      console.log(`[TRADES] User confirmed ${confirmedTrades.length} trades for project ${projectId}`);
      
      res.json({ 
        success: true, 
        confirmedCount: confirmedTrades.length,
        message: 'Gewerke erfolgreich bestätigt'
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      throw innerErr;
    }
    
  } catch (err) {
    console.error('Failed to confirm trades:', err);
    res.status(500).json({ 
      error: 'Fehler beim Bestätigen der Gewerke',
      details: err.message 
    });
  }
});

// Add single trade to project (for additional trades)
app.post('/api/projects/:projectId/trades/add-single', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { tradeId, isAdditional } = req.body;
    
    // Prüfe ob Trade bereits existiert
    const existing = await query(
      'SELECT * FROM project_trades WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (existing.rows.length > 0) {
      return res.status(400).json({ error: 'Gewerk bereits vorhanden' });
    }
    
    // Füge Trade hinzu mit additional flag
    await query(
      `INSERT INTO project_trades (project_id, trade_id, is_manual, is_additional)
       VALUES ($1, $2, $3, $4)`,
      [projectId, tradeId, true, isAdditional || false]
    );
    
    res.json({ success: true });
    
  } catch (err) {
    console.error('Error adding single trade:', err);
    res.status(500).json({ error: 'Fehler beim Hinzufügen des Gewerks' });
  }
});

// Generate adaptive questions for a specific trade
app.post('/api/projects/:projectId/trades/:tradeId/questions', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const {
      includeIntakeContext,
      isManuallyAdded: manualFromBody,
      isAiRecommended: aiRecommendedFromBody,
      isAdditional: additionalFromBody,  
      projectDescription: descriptionFromBody,
      projectCategory: categoryFromBody,
      projectBudget: budgetFromBody
    } = req.body;
    
    // NEU: Prüfe ob Fragen bereits existieren
    const existingQuestions = await query(
      'SELECT COUNT(*) as count FROM questions WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (existingQuestions.rows[0].count > 0) {
      console.log(`[QUESTIONS] Questions already exist for trade ${tradeId}, loading from DB`);
      
      const savedQuestions = await query(
  `SELECT question_id as id, text as question, type, required, options, 
          explanation, upload_helpful, upload_hint, category,
          depends_on, show_if
   FROM questions 
   WHERE project_id = $1 AND trade_id = $2
   ORDER BY sort_order ASC`,
  [projectId, tradeId]
);
      
      const formattedQuestions = savedQuestions.rows.map(q => ({
        ...q,
        options: q.options ? (typeof q.options === 'string' ? JSON.parse(q.options) : q.options) : null,
        uploadHelpful: q.upload_helpful,
        uploadHint: q.upload_hint,
        dependsOn: q.depends_on,
        showIf: q.show_if
      }));
      
      const tradeInfo = await query('SELECT name FROM trades WHERE id = $1', [tradeId]);
      
      return res.json({ 
        questions: formattedQuestions,
        actualCount: formattedQuestions.length,
        tradeName: tradeInfo.rows[0]?.name,
        fromCache: true
      });
    }
    
    // Prüfe Trade-Status
    const tradeStatusResult = await query(
      `SELECT is_manual, is_ai_recommended, is_additional   
       FROM project_trades 
       WHERE project_id = $1 AND trade_id = $2`,
      [projectId, tradeId]
    );
    
    const tradeStatus = tradeStatusResult.rows[0] || {};
    
    // Kombiniere Body-Werte mit DB-Werten (DB hat Vorrang)
    const isManuallyAdded = tradeStatus.is_manual || manualFromBody || false;
    const isAiRecommended = tradeStatus.is_ai_recommended || aiRecommendedFromBody || false;
    const isAdditional = tradeStatus.is_additional || additionalFromBody || false; 
    
    console.log('[QUESTIONS-API] Generating NEW questions for trade:', {
      tradeId,
      isManuallyAdded,
      isAiRecommended,
      isAdditional
    });
    
    const isAssigned = await isTradeAssignedToProject(projectId, tradeId);
    const tradeInfo = await query('SELECT code, name FROM trades WHERE id = $1', [tradeId]);
    const tradeCode = tradeInfo.rows[0]?.code;
    const tradeName = tradeInfo.rows[0]?.name;
    
    if (!isAssigned && tradeCode !== 'INT') {
      console.log(`[QUESTIONS] Trade ${tradeId} not assigned to project ${projectId}, adding it now`);
      await ensureProjectTrade(projectId, tradeId, 'questions_request');
    }
    
    const projectResult = await query('SELECT * FROM projects WHERE id = $1', [projectId]);
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    const project = projectResult.rows[0];
    
    // Parse metadata
    if (project.metadata && typeof project.metadata === 'string') {
      project.metadata = JSON.parse(project.metadata);
    }
    
    // Lade intakeContext
    let intakeContext = '';
    if (tradeCode !== 'INT') {
      const intakeAnswers = await query(
        `SELECT q.text as question, a.answer_text as answer
         FROM answers a
         JOIN questions q ON q.project_id = a.project_id 
           AND q.trade_id = a.trade_id 
           AND q.question_id = a.question_id
         JOIN trades t ON t.id = a.trade_id
         WHERE a.project_id = $1 
         AND t.code = 'INT'`,
        [projectId]
      );
      
      if (intakeAnswers.rows.length > 0) {
        intakeContext = intakeAnswers.rows
          .map(a => `${a.question}: ${a.answer}`)
          .join('\n');
      }
    }
    
    // Lade Projekt-Trades
    const projectTrades = await query(
      `SELECT t.code, t.name FROM trades t 
       JOIN project_trades pt ON t.id = pt.trade_id 
       WHERE pt.project_id = $1`,
      [projectId]
    );
    
    // Erstelle projectContext
    const projectContext = {
      category: req.body.projectCategory || project.category,
      subCategory: project.sub_category,
      description: req.body.projectDescription || project.description,
      timeframe: project.timeframe,
      budget: req.body.projectBudget || project.budget,
      projectId: projectId,
      isManuallyAdded: isManuallyAdded,    
      isAiRecommended: isAiRecommended,    
      isAdditional: isAdditional,          
      intakeContext: intakeContext,
      hasIntakeAnswers: intakeContext.length > 0,
      trades: projectTrades.rows,
      complexity: project.metadata?.complexity?.level || 'MITTEL',
      metadata: project.metadata
    };
    
    const questions = await generateQuestions(tradeId, projectContext);
    
    // Filter anwenden
    const filteredQuestions = filterDuplicateQuestions(questions, projectContext.intakeData || []);
    console.log(`[QUESTIONS] Filtered ${questions.length - filteredQuestions.length} duplicate questions`);
    
   // NEU: Speichere Fragen MIT ALLEN FELDERN inkl. sort_order
// VOR dem Loop
console.log('[DEBUG] filteredQuestions.length:', filteredQuestions.length);
console.log('[DEBUG] First 3 question IDs:', filteredQuestions.slice(0, 3).map(q => q.id));

for (let i = 0; i < filteredQuestions.length; i++) {
  const question = filteredQuestions[i];
  
  console.log(`[DEBUG] Saving ${question.id} with sort_order=${i}`); // WICHTIG!
  
  await query(
    `INSERT INTO questions (
      project_id, trade_id, question_id, text, type, required, options, 
      depends_on, show_if, explanation, upload_helpful, upload_hint, category, sort_order
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
    ON CONFLICT (project_id, trade_id, question_id) 
    DO UPDATE SET 
      text = $4, type = $5, required = $6, options = $7, 
      depends_on = $8, show_if = $9, explanation = $10,
      upload_helpful = $11, upload_hint = $12, category = $13, sort_order = $14`,
    [
      projectId,
      tradeId,
      question.id,
      question.question || question.text,
      question.multiSelect ? 'multiselect' : (question.type || 'text'),
      question.required !== undefined ? question.required : false,
      question.options ? JSON.stringify({
        values: question.options,
        multiSelect: question.multiSelect || false,
        dependsOn: question.dependsOn || null,
        showIf: question.showIf || null
      }) : null,
      question.dependsOn || null,
      question.showIf || null,
      question.explanation || null,
      question.uploadHelpful || false,
      question.uploadHint || null,
      question.category || null,
      i  // sort_order
    ]
  );
}

console.log('[DEBUG] Finished saving all questions');
    
    // Setze Status auf "questions_ready"
    await query(
      `INSERT INTO trade_progress (project_id, trade_id, status, updated_at)
       VALUES ($1, $2, 'questions_ready', NOW())
       ON CONFLICT (project_id, trade_id)
       DO UPDATE SET status = 'questions_ready', updated_at = NOW()`,
      [projectId, tradeId]
    );
    
    const intelligentCount = getIntelligentQuestionCount(tradeCode, projectContext, []);
    
    res.json({ 
      questions: filteredQuestions,
      targetCount: intelligentCount.count,
      actualCount: questions.length,
      completeness: intelligentCount.completeness,
      missingInfo: intelligentCount.missingInfo,
      tradeName: tradeName
    });
    
  } catch (err) {
    console.error('Failed to generate questions:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get questions for a trade
app.get('/api/projects/:projectId/trades/:tradeId/questions', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    const isAssigned = await isTradeAssignedToProject(projectId, tradeId);
    
    const tradeInfo = await query('SELECT code FROM trades WHERE id = $1', [tradeId]);
    const tradeCode = tradeInfo.rows[0]?.code;
    
    if (!isAssigned && tradeCode !== 'INT') {
      console.warn(`[QUESTIONS] Trade ${tradeId} not assigned to project ${projectId}`);
      return res.status(403).json({ error: 'Trade not assigned to project' });
    }
    
    const result = await query(
  `SELECT q.*, t.name as trade_name, t.code as trade_code
   FROM questions q
   JOIN trades t ON t.id = q.trade_id
   WHERE q.project_id = $1 AND q.trade_id = $2
   ORDER BY q.sort_order ASC`,
  [projectId, tradeId]
);
    
    const questions = result.rows.map(q => {
  const parsedOptions = q.options ? 
    (typeof q.options === 'string' ? JSON.parse(q.options) : q.options) : null;
  
  return {
    id: q.question_id,
    question: q.text,
    text: q.text,
    type: q.type,
    required: q.required,
    options: parsedOptions,
    dependsOn: q.depends_on || null,
    showIf: q.show_if || null,
    explanation: q.explanation,
    uploadHelpful: q.upload_helpful,
    uploadHint: q.upload_hint,
    category: q.category
  };
});
    
    res.json({ 
  questions,
  tradeName: result.rows[0]?.trade_name, 
  tradeCode: result.rows[0]?.trade_code 
});
    
  } catch (err) {
    console.error('Failed to fetch questions:', err);
    res.status(500).json({ error: 'Failed to fetch questions' });
  }
});

// Save answers with validation
app.post('/api/projects/:projectId/trades/:tradeId/answers', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { answers } = req.body;
    
    if (!Array.isArray(answers)) {
      return res.status(400).json({ error: 'Answers must be an array' });
    }
    
    const isAssigned = await isTradeAssignedToProject(projectId, tradeId);
    
    const tradeInfo = await query('SELECT code FROM trades WHERE id = $1', [tradeId]);
    const tradeCode = tradeInfo.rows[0]?.code;
    
    if (!isAssigned && tradeCode !== 'INT') {
      console.warn(`[ANSWERS] Trade ${tradeId} not assigned to project ${projectId}`);
      return res.status(403).json({ error: 'Trade not assigned to project' });
    }
    
    // Speichere Antworten mit Annahmen
    const savedAnswers = [];
    for (const answer of answers) {
      // Prüfe ob "unsicher" angegeben wurde
      const isUncertain = answer.answer === 'unsicher' || 
                         answer.answer?.toLowerCase?.() === 'unsicher' ||
                         answer.answer?.toLowerCase?.()?.includes('weiß nicht');
      
      let assumption = answer.assumption || null;
      let finalAnswer = answer.answer;
      
      // Bei Unsicherheit: Schätzung generieren
      if (isUncertain) {
        assumption = 'Nutzer war unsicher - Standardwert angenommen';
        // Hier könnte eine intelligente Schätzung erfolgen
        finalAnswer = 'Standardannahme getroffen';
      }
      
      await query(
        `INSERT INTO answers (project_id, trade_id, question_id, answer_text, assumption)
         VALUES ($1, $2, $3, $4, $5)
         ON CONFLICT (project_id, trade_id, question_id)
         DO UPDATE SET answer_text = $4, assumption = $5, updated_at = NOW()`,
        [
          projectId,
          tradeId,
          answer.questionId,
          finalAnswer,
          assumption
        ]
      );
      
      savedAnswers.push({
        questionId: answer.questionId,
        answer: finalAnswer,
        assumption
      });
    }
    
    res.json({ 
      success: true, 
      saved: savedAnswers.length,
      answers: savedAnswers
    });
    
  } catch (err) {
    console.error('Failed to save answers:', err);
    res.status(500).json({ error: err.message });
  }
});

// Save intake answers specifically
app.post('/api/projects/:projectId/intake/answers', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { answers } = req.body;
    
    if (!Array.isArray(answers)) {
      return res.status(400).json({ error: 'Answers must be an array' });
    }
    
    const intTrade = await query(`SELECT id FROM trades WHERE code = 'INT' LIMIT 1`);
    if (intTrade.rows.length === 0) {
      return res.status(500).json({ error: 'INT trade missing' });
    }
    const tradeId = intTrade.rows[0].id;
    
    const savedAnswers = [];
    
    for (const answer of answers) {
      // Hole den Fragetext aus questions
      const questionResult = await query(
        'SELECT text FROM questions WHERE project_id = $1 AND trade_id = $2 AND question_id = $3',
        [projectId, tradeId, answer.questionId]
      );
      
      const questionText = questionResult.rows[0]?.text || '';
      
      // Speichere in intake_responses
      await query(
  `INSERT INTO intake_responses (project_id, question_id, question_text, answer_text)
   VALUES ($1, $2, $3, $4)`,
  [
    projectId,
    parseInt(answer.questionId.replace('INT-', '')),  // Extrahiere die intake_questions.id
    questionText,
    answer.answer
  ]
);
      
      // Speichere auch in answers für Kompatibilität
      await query(
        `INSERT INTO answers (project_id, trade_id, question_id, answer_text)
         VALUES ($1, $2, $3, $4)
         ON CONFLICT (project_id, trade_id, question_id)
         DO UPDATE SET answer_text = $4, updated_at = NOW()`,
        [
          projectId,
          tradeId,
          answer.questionId,
          answer.answer
        ]
      );
      
      savedAnswers.push({
        questionId: answer.questionId,
        answer: answer.answer
      });
    }
    
    res.json({ 
      success: true, 
      saved: savedAnswers.length,
      answers: savedAnswers
    });
    
  } catch (err) {
    console.error('Failed to save intake answers:', err);
    res.status(500).json({ error: err.message });
  }
});

app.post('/api/projects/:projectId/trades/:tradeId/context-questions', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { contextAnswer, isAdditional, isManuallyAdded, isAiRecommended } = req.body;
    
    if (!contextAnswer) {
      return res.status(400).json({ error: 'Kontextantwort fehlt' });
    }
    
    console.log('[CONTEXT-QUESTIONS] Processing:', {
      tradeId,
      isAdditional,
      isManuallyAdded,
      isAiRecommended
    });
    
    // Speichere Kontextantwort SOFORT
    const tradeInfo = await query('SELECT code FROM trades WHERE id = $1', [tradeId]);
    const tradeCode = tradeInfo.rows[0]?.code;
    
    await query(
      `INSERT INTO answers (project_id, trade_id, question_id, answer_text)
       VALUES ($1, $2, $3, $4)
       ON CONFLICT (project_id, trade_id, question_id)
       DO UPDATE SET answer_text = $4, updated_at = NOW()`,
      [projectId, tradeId, `${tradeCode}-CONTEXT`, contextAnswer]
    );
    
    // Generiere Folgefragen
    const questions = await generateContextBasedQuestions(
      tradeId, 
      projectId, 
      contextAnswer,
      { 
        isManuallyAdded: isManuallyAdded || false,
        isAdditional: isAdditional || false,
        isAiRecommended: isAiRecommended || false
      }
    );
    
    // NEU: Speichere die neuen Fragen MIT ALLEN FELDERN
    for (let i = 0; i < questions.length; i++) {
  const q = questions[i];
  await query(
    `INSERT INTO questions (
      project_id, trade_id, question_id, text, type, required, options,
      explanation, upload_helpful, upload_hint, category, sort_order
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
    ON CONFLICT (project_id, trade_id, question_id)
    DO UPDATE SET 
      text=$4, type=$5, required=$6, options=$7,
      explanation=$8, upload_helpful=$9, upload_hint=$10, category=$11, sort_order=$12`,
    [
      projectId, 
      tradeId, 
      q.id, 
      q.question || q.text, 
      q.type || 'text', 
      q.required ?? true, 
      q.options ? JSON.stringify(q.options) : null,
      q.explanation || null,
      q.uploadHelpful || false,
      q.uploadHint || null,
      q.category || null,
      i  // ← sort_order
    ]
  );
}
    
    // Setze Status
    await query(
      `INSERT INTO trade_progress (project_id, trade_id, status, updated_at)
       VALUES ($1, $2, 'questions_ready', NOW())
       ON CONFLICT (project_id, trade_id)
       DO UPDATE SET status = 'questions_ready', updated_at = NOW()`,
      [projectId, tradeId]
    );
    
    res.json({ 
      questions, 
      count: questions.length,
      isAdditional: !!isAdditional,
      isManuallyAdded: !!isManuallyAdded,
      isAiRecommended: !!isAiRecommended
    });
    
  } catch (err) {
    console.error('Context questions generation failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// NEU: Trigger Fragengenerierung im Hintergrund
app.post('/api/projects/:projectId/trades/:tradeId/generate-questions-background', async (req, res) => {
  console.log('[ROUTE] generate-questions-background called');
  
  try {
    const { projectId, tradeId } = req.params;
    console.log('[ROUTE] Params:', projectId, tradeId);
    
    // NEU: Prüfe Trade-Flags ZUERST
    const tradeCheck = await query(
      'SELECT is_manual, is_ai_recommended, is_additional FROM project_trades WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    const isSpecial = tradeCheck.rows[0]?.is_manual || 
                     tradeCheck.rows[0]?.is_ai_recommended || 
                     tradeCheck.rows[0]?.is_additional;
    
    if (isSpecial) {
      console.log('[ROUTE] Special trade detected - skipping background generation');
      return res.json({ 
        status: 'skipped',
        message: 'Special trades require context question flow',
        requiresContext: true
      });
    }
    
    // Prüfe ob bereits Fragen existieren
    const existing = await query(
      'SELECT COUNT(*) as count FROM questions WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    console.log('[ROUTE] Existing questions:', existing.rows[0].count);
    
    if (existing.rows[0].count > 0) {
      console.log('[ROUTE] Questions already exist, returning');
      return res.json({ 
        success: true, 
        message: 'Fragen existieren bereits',
        status: 'ready'
      });
    }
    
    console.log('[ROUTE] Setting status to generating...');    
    
    // Setze Status auf "generating"
    await query(
      `INSERT INTO trade_progress (project_id, trade_id, status, updated_at)
       VALUES ($1, $2, 'generating_questions', NOW())
       ON CONFLICT (project_id, trade_id)
       DO UPDATE SET status = 'generating_questions', updated_at = NOW()`,
      [projectId, tradeId]
    );
    
    console.log('[ROUTE] Calling background function...');
    
    // Starte im Hintergrund (nicht awaiten!)
    generateQuestionsInBackground(projectId, tradeId);
    
    console.log('[ROUTE] Background function triggered, returning response');
    
    res.json({ 
      success: true, 
      message: 'Fragengenerierung gestartet',
      status: 'generating'
    });
    
  } catch (err) {
    console.error('Error starting background generation:', err);
    res.status(500).json({ error: err.message });
  }
});

// NEU: Status-Check
app.get('/api/projects/:projectId/trades/:tradeId/questions-status', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    // NEU: Prüfe ob Special Trade
    const tradeCheck = await query(
      'SELECT is_manual, is_ai_recommended, is_additional FROM project_trades WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    console.log('[QUESTIONS-STATUS] Trade check for', tradeId, ':', tradeCheck.rows[0]);
    
    const isSpecial = tradeCheck.rows[0]?.is_manual || 
                     tradeCheck.rows[0]?.is_ai_recommended || 
                     tradeCheck.rows[0]?.is_additional;

    console.log('[QUESTIONS-STATUS] isSpecial:', isSpecial);
    
    const statusRes = await query(
      'SELECT status, current_question_index FROM trade_progress WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    const questionCountRes = await query(
      'SELECT COUNT(*) as count FROM questions WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    const answerCountRes = await query(
      'SELECT COUNT(*) as count FROM answers WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    const status = statusRes.rows[0]?.status || 'not_started';
const questionCount = parseInt(questionCountRes.rows[0]?.count || 0);
const answerCount = parseInt(answerCountRes.rows[0]?.count || 0);
const currentIndex = statusRes.rows[0]?.current_question_index || 0;

const responseData = {
  status,
  questionCount,
  answerCount,
  currentIndex,
  ready: questionCount > 0,
  inProgress: answerCount > 0 && answerCount < questionCount,
  requiresContext: isSpecial && questionCount === 0
};

console.log('[QUESTIONS-STATUS] Response data:', responseData);

res.json(responseData);
    
  } catch (err) {
    console.error('Error checking status:', err);
    res.status(500).json({ error: err.message });
  }
});

// NEU: Progress speichern
app.post('/api/projects/:projectId/trades/:tradeId/save-progress', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { currentQuestionIndex, answers } = req.body;
    
    // Speichere alle Antworten
    for (const answer of answers) {
      if (answer && answer.answer) {
        await query(
          `INSERT INTO answers (project_id, trade_id, question_id, answer_text, assumption)
           VALUES ($1, $2, $3, $4, $5)
           ON CONFLICT (project_id, trade_id, question_id)
           DO UPDATE SET answer_text = $4, assumption = $5, updated_at = NOW()`,
          [projectId, tradeId, answer.questionId, answer.answer, answer.assumption || null]
        );
      }
    }
    
    // Update Progress
    await query(
      `INSERT INTO trade_progress (project_id, trade_id, current_question_index, updated_at)
       VALUES ($1, $2, $3, NOW())
       ON CONFLICT (project_id, trade_id)
       DO UPDATE SET current_question_index = $3, updated_at = NOW()`,
      [projectId, tradeId, currentQuestionIndex]
    );
    
    res.json({ success: true });
    
  } catch (err) {
    console.error('Error saving progress:', err);
    res.status(500).json({ error: err.message });
  }
});

// NEU: Progress laden
app.get('/api/projects/:projectId/trades/:tradeId/progress', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    const answersRes = await query(
      `SELECT question_id, COALESCE(llm_context, answer_text) as answer_text, assumption 
       FROM answers 
       WHERE project_id = $1 AND trade_id = $2
         AND (answer_text IS NOT NULL OR llm_context IS NOT NULL)
         ORDER BY updated_at`,
      [projectId, tradeId]
    );
    
    const progressRes = await query(
      'SELECT current_question_index FROM trade_progress WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    const answers = answersRes.rows.map(a => ({
      questionId: a.question_id,
      answer: a.answer_text,
      assumption: a.assumption
    }));
    
    res.json({
      answers,
      currentQuestionIndex: progressRes.rows[0]?.current_question_index || 0
    });
    
  } catch (err) {
    console.error('Error loading progress:', err);
    res.status(500).json({ error: err.message });
  }
});

// Hintergrund-Funktion für Fragengenerierung
async function generateQuestionsInBackground(projectId, tradeId) {
  console.log(`[BG] FUNCTION CALLED for project ${projectId}, trade ${tradeId}`);
  try {
    console.log(`[BG] Starting question generation for trade ${tradeId}`);
    
    // 1. Lade Trade-Status aus DB
    const tradeStatusResult = await query(
      `SELECT is_manual, is_ai_recommended, is_additional   
       FROM project_trades 
       WHERE project_id = $1 AND trade_id = $2`,
      [projectId, tradeId]
    );
    
    const tradeStatus = tradeStatusResult.rows[0] || {};
    const isManuallyAdded = tradeStatus.is_manual || false;
    const isAiRecommended = tradeStatus.is_ai_recommended || false;
    const isAdditional = tradeStatus.is_additional || false;
    
    // NEU: Stoppe wenn Special Trade
    if (isManuallyAdded || isAiRecommended || isAdditional) {
      console.log('[BG] Special trade - should not generate in background, stopping');
      await query(
        `UPDATE trade_progress SET status = 'requires_context', updated_at = NOW()
         WHERE project_id = $1 AND trade_id = $2`,
        [projectId, tradeId]
      );
      return; // WICHTIG: Stoppe hier!
    }
    
    // 2. Lade Trade-Info
    const tradeInfo = await query('SELECT code, name FROM trades WHERE id = $1', [tradeId]);
    const tradeCode = tradeInfo.rows[0]?.code;
    const tradeName = tradeInfo.rows[0]?.name;
    
    // 3. Lade Projekt
    const projectResult = await query('SELECT * FROM projects WHERE id = $1', [projectId]);
    if (projectResult.rows.length === 0) {
      throw new Error('Project not found');
    }
    
    const project = projectResult.rows[0];
    
    // Parse metadata
    if (project.metadata && typeof project.metadata === 'string') {
      project.metadata = JSON.parse(project.metadata);
    }
    
    // 4. Lade Intake-Context
    let intakeContext = '';
    if (tradeCode !== 'INT') {
      const intakeAnswers = await query(
        `SELECT q.text as question, a.answer_text as answer
         FROM answers a
         JOIN questions q ON q.project_id = a.project_id 
           AND q.trade_id = a.trade_id 
           AND q.question_id = a.question_id
         JOIN trades t ON t.id = a.trade_id
         WHERE a.project_id = $1 
         AND t.code = 'INT'`,
        [projectId]
      );
      
      if (intakeAnswers.rows.length > 0) {
        intakeContext = intakeAnswers.rows
          .map(a => `${a.question}: ${a.answer}`)
          .join('\n');
      }
    }
    
    // 5. Lade Projekt-Trades
    const projectTrades = await query(
      `SELECT t.code, t.name FROM trades t 
       JOIN project_trades pt ON t.id = pt.trade_id 
       WHERE pt.project_id = $1`,
      [projectId]
    );
    
    // 6. Erstelle projectContext
    const projectContext = {
      category: project.category,
      subCategory: project.sub_category,
      description: project.description,
      timeframe: project.timeframe,
      budget: project.budget,
      projectId: projectId,
      isManuallyAdded: isManuallyAdded,
      isAiRecommended: isAiRecommended,
      isAdditional: isAdditional,
      intakeContext: intakeContext,
      hasIntakeAnswers: intakeContext.length > 0,
      trades: projectTrades.rows,
      complexity: project.metadata?.complexity?.level || 'MITTEL',
      metadata: project.metadata
    };
    
    // 7. Prüfe ob Kontextfrage oder normale Fragen
    let questions;
    
    if (isManuallyAdded || isAiRecommended || isAdditional) {
      // Erstelle Kontextfrage
      const getContextExplanation = (tradeCode, tradeName) => {
        const explanations = {
          'TIS': 'Wichtig für Materialkalkulation und Arbeitsaufwand bei Tischlerarbeiten',
          'FEN': 'Bestimmt Anzahl, Maße und Ausführung der Fenster für präzise Kalkulation',
          'SAN': 'Definiert Umfang der Sanitärarbeiten für Material- und Zeitplanung',
          'ELEKT': 'Legt fest welche Elektroinstallationen für Kalkulation berücksichtigt werden',
          'MAL': 'Bestimmt zu streichende Flächen und Qualität für Materialberechnung',
          'FLI': 'Definiert Fliesenbereiche und -arten für Mengen- und Preiskalkulation',
          'HEI': 'Legt Umfang der Heizungsarbeiten für Komponentenwahl und Kalkulation fest',
          'DACH': 'Bestimmt Art und Umfang der Dacharbeiten für Material- und Zeitplanung',
          'FASS': 'Definiert Fassadenarbeiten für Dämmstärke und Flächenberechnung',
          'TRO': 'Legt fest welche Trockenbauarbeiten für Material- und Arbeitszeitkalkulation',
          'BOD': 'Bestimmt Bodenbelagsart und -flächen für präzise Materialkalkulation',
          'ROH': 'Definiert Rohbauarbeiten für statische Anforderungen und Materialbedarf',
          'GER': 'Legt Gerüstumfang für Höhe, Fläche und Standzeit-Kalkulation fest',
          'SCHL': 'Bestimmt Schlosserarbeiten für Material, Maße und Montageart',
          'ABBR': 'Definiert Abbruch-Umfang für Entsorgungsmengen und Arbeitsaufwand',
          'ZIMM': 'Legt Zimmererarbeiten für Holzkonstruktion und Materialbedarf fest',
          'PV': 'Bestimmt PV-Anlage für Leistung, Modulmenge und Systemkomponenten',
          'KLIMA': 'Legt fest welche Klimaanlage/Lüftung für Raumgröße und Kühlleistung',
          'AUSS': 'Definiert Außenanlagen für Flächenberechnung und Materialauswahl',
          'ESTR': 'Bestimmt Estricharbeiten für Fläche, Stärke und Materialwahl'
        };
        return explanations[tradeCode] || `Wichtig für die präzise Kalkulation der ${tradeName}-Arbeiten`;
      };
      
      questions = [{
        id: `${tradeCode}-CONTEXT`,
        question: `Sie haben das Gewerk ${tradeName} ${isAdditional ? 'nachträglich hinzugefügt' : isManuallyAdded ? 'manuell hinzugefügt' : 'als optionales Gewerk ausgewählt'}. Was genau soll in diesem Bereich gemacht werden?`,
        type: 'text',
        required: true,
        category: 'Projektkontext',
        explanation: getContextExplanation(tradeCode, tradeName),
        tradeId: parseInt(tradeId),
        tradeName: tradeName,
        trade_name: tradeName,
        trade_code: tradeCode,
        isContextQuestion: true,
        requiresFollowUp: true,
        uploadHelpful: true,
        uploadHint: "Optional: Fotos, Pläne oder Dokumente zur besseren Einschätzung hochladen"
      }];
    } else {
      // 8. Generiere normale Fragen
      questions = await generateQuestions(tradeId, projectContext);
      
      // Filter Duplikate
      questions = filterDuplicateQuestions(questions, projectContext.intakeData || []);
    }
    
    // 9. Speichere Fragen in DB
   for (let i = 0; i < questions.length; i++) {
  const question = questions[i];
  await query(
    `INSERT INTO questions (
      project_id, trade_id, question_id, text, type, required, options, 
      depends_on, show_if, explanation, upload_helpful, upload_hint, category, sort_order
    )
    VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
    ON CONFLICT (project_id, trade_id, question_id) 
    DO UPDATE SET 
      text = $4, type = $5, required = $6, options = $7, 
      depends_on = $8, show_if = $9, explanation = $10,
      upload_helpful = $11, upload_hint = $12, category = $13, sort_order = $14`,
    [
      projectId,
      tradeId,
      question.id,
      question.question || question.text,
      question.multiSelect ? 'multiselect' : (question.type || 'text'),
      question.required !== undefined ? question.required : false,
      question.options ? JSON.stringify({
        values: question.options,
        multiSelect: question.multiSelect || false,
        dependsOn: question.dependsOn || null,
        showIf: question.showIf || null
      }) : null,
      question.dependsOn || null,
      question.showIf || null,
      question.explanation || null,
      question.uploadHelpful || false,
      question.uploadHint || null,
      question.category || null,
      i  // ← sort_order
    ]
  );
}
    
    // 10. Update Status auf "ready"
    await query(
      `INSERT INTO trade_progress (project_id, trade_id, status, updated_at)
       VALUES ($1, $2, 'questions_ready', NOW())
       ON CONFLICT (project_id, trade_id)
       DO UPDATE SET status = 'questions_ready', updated_at = NOW()`,
      [projectId, tradeId]
    );
    
    console.log(`[BG] ✓ Generated and saved ${questions.length} questions for trade ${tradeId} (${tradeName})`);
    
  } catch (err) {
    console.error(`[BG] ✗ Failed for trade ${tradeId}:`, err);
    
    // Setze Error-Status
    await query(
      `UPDATE trade_progress SET status = 'error', updated_at = NOW()
       WHERE project_id = $1 AND trade_id = $2`,
      [projectId, tradeId]
    ).catch(console.error);
  }
}

// Endpoint für Rückfragen zu Fragen - "Frage zur Frage" Feature
app.post('/api/projects/:projectId/trades/:tradeId/question-clarification', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { questionText, questionContext, userQuery } = req.body;
    
    if (!questionText || !userQuery) {
      return res.status(400).json({ 
        error: 'Frage und Rückfrage sind erforderlich' 
      });
    }
    
    // Hole Trade-Info für Kontext
    const tradeInfo = await query(
      'SELECT name, code FROM trades WHERE id = $1', 
      [tradeId]
    );
    
    if (tradeInfo.rows.length === 0) {
      return res.status(404).json({ error: 'Gewerk nicht gefunden' });
    }
    
    const tradeName = tradeInfo.rows[0].name;
    const tradeCode = tradeInfo.rows[0].code;
    
    // Hole Projekt für zusätzlichen Kontext
    const projectResult = await query(
      'SELECT description, category, budget FROM projects WHERE id = $1', 
      [projectId]
    );
    const project = projectResult.rows[0];
    
    const systemPrompt = `Du bist ein geduldiger Experte für ${tradeName}, der Laien hilft.
    
KONTEXT:
- Gewerk: ${tradeName} (${tradeCode})
- Gestellte Frage: "${questionText}"
- Projekt: ${project?.description || 'Keine Beschreibung'}
- Kategorie: ${project?.category || 'Nicht angegeben'}

AUFGABE:
Beantworte die Rückfrage des Nutzers zur gestellten Frage.
Erkläre in einfachen Worten, gib praktische Tipps.
Maximal 150 Wörter. Sei konkret und hilfreich.

WICHTIG:
- Keine Fachbegriffe ohne Erklärung
- Praktische Beispiele aus dem Alltag
- Schritt-für-Schritt wenn nach Anleitung gefragt
- Produktbeispiele wenn nach Qualität gefragt
- Preisrahmen wenn nach Kosten gefragt`;

    const userPrompt = `Original-Frage an den Nutzer: "${questionText}"
${questionContext ? `\nKontext: ${questionContext}` : ''}

Nutzer-Rückfrage: "${userQuery}"

Gib eine hilfreiche, verständliche Antwort die dem Laien weiterhilft.`;

    const response = await llmWithPolicy('clarification', [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], { 
      maxTokens: 1000,
      temperature: 0.3 
    });
    
    console.log(`[CLARIFICATION] Question clarified for trade ${tradeCode}`);
    
    res.json({ 
      success: true, 
      response: response,
      tradeInfo: {
        name: tradeName,
        code: tradeCode
      }
    });
    
  } catch (err) {
    console.error('Question clarification failed:', err);
    res.status(500).json({ 
      error: 'Fehler bei der Beantwortung Ihrer Rückfrage' 
    });
  }
});

app.post('/api/analyze-file', upload.single('file'), async (req, res) => {
  console.log('[FILE-ANALYZE] Starting analysis');
  console.log('[FILE-ANALYZE] File:', req.file ? req.file.originalname : 'NO FILE');
  
  const { questionId, questionText, tradeCode, projectId, tradeId } = req.body;
  const file = req.file;
  
  if (!file) {
    return res.status(400).json({ error: 'Keine Datei hochgeladen' });
  }
  
  if (!questionText || !tradeCode) {
    return res.status(400).json({ error: 'Fehlende Parameter' });
  }
  
  try {
    let extractedAnswer = '';
    let llmContext = '';  // ← NEU: Für LLM mit Anweisungen
    let structuredData = null;
    let analysis = '';
    let confidence = 0.7;
    let documentType = null;
    let detectedItems = [];
    let suggestions = null;
    
    // BILD-ANALYSE
    if (file.mimetype.startsWith('image/')) {
      console.log('[FILE-ANALYZE] Processing image:', file.originalname);
      
      const optimizedBuffer = await sharp(file.buffer)
        .resize(1920, 1920, { 
          fit: 'inside',
          withoutEnlargement: true 
        })
        .jpeg({ quality: 85 })
        .toBuffer();
      
      const base64 = optimizedBuffer.toString('base64');
      const result = await analyzeImageWithClaude(base64, questionText, tradeCode, questionId);
      
      // NEU: Strukturierte Extraktion aus Bild
      const imageStructure = await extractStructuredDataFromImage(
        result.answer, 
        tradeCode, 
        questionText
      );
      
      // ═══════════════════════════════════════════════════════════════════
      // NEU: Trenne Nutzer-Text von LLM-Context
      // ═══════════════════════════════════════════════════════════════════
      extractedAnswer = imageStructure.userDisplayText || imageStructure.enhancedText || result.answer;
      llmContext = imageStructure.llmContextText || imageStructure.enhancedText || result.answer;
      
      // NEU: Log für Debugging
      if (imageStructure.structured?.hasQuantities) {
        console.log(`[FILE-ANALYZE] ✓ ${imageStructure.items?.length || 0} Mengenangaben extrahiert`);
        console.log(`[FILE-ANALYZE] User text: ${extractedAnswer.length} chars`);
        console.log(`[FILE-ANALYZE] LLM context: ${llmContext.length} chars`);
      }
      
      structuredData = imageStructure.structured;
      detectedItems = imageStructure.items;
      suggestions = imageStructure.suggestions;
      analysis = `Bild analysiert: ${detectedItems.length} Elemente erkannt`;
      confidence = result.confidence || 0.85;
      documentType = 'IMAGE';
    }

// EXCEL/CSV-ANALYSE
else if (file.originalname.match(/\.(xlsx?|csv)$/i)) {
  console.log('[FILE-ANALYZE] Processing spreadsheet:', file.originalname);
  
  const workbook = xlsx.read(file.buffer);
  
  try {
    // LLM-basierte Analyse
    const result = await parseSpreadsheetContent(workbook, tradeCode, questionText);
    
    console.log('[FILE-ANALYZE] parseSpreadsheetContent result:', {
      hasText: !!result.text,
      hasStructured: !!result.structured,
      structuredType: result.structured?.type,
      itemsCount: result.structured?.items?.length
    });
    
    // ═══════════════════════════════════════════════════════════════════
    // SICHERER ZUGRIFF AUF RESULT
    // ═══════════════════════════════════════════════════════════════════
    
    structuredData = result.structured || { type: 'generic', items: [] };
    documentType = structuredData.type || 'SPREADSHEET';
    detectedItems = structuredData.items || [];
    
    // Prüfe ob Items gefunden wurden
if (detectedItems.length > 0) {
  confidence = 0.95;
  
  console.log(`[FILE-ANALYZE] Excel: ${detectedItems.length} items found`);
  
  // Verwende direkt das Ergebnis vom spreadsheetParser
  if (result.text) {
    // Der Parser liefert bereits eine formatierte Zusammenfassung
    extractedAnswer = result.text;
    
    // Für LLM: Füge strukturierte Daten als Kontext hinzu
    if (structuredData && structuredData.items && structuredData.items.length > 0) {
      llmContext = result.text + '\n\nSTRUKTURIERTE DATEN FÜR LV:\n' + 
                   JSON.stringify(structuredData.items, null, 2);
    } else {
      llmContext = result.text;
    }
    
    console.log(`[FILE-ANALYZE] Excel: User text: ${extractedAnswer.length} chars`);
    console.log(`[FILE-ANALYZE] Excel: LLM context: ${llmContext.length} chars`);
  } else {
    // Fallback falls kein Text generiert wurde
    extractedAnswer = `${detectedItems.length} Einträge aus Excel extrahiert`;
    llmContext = extractedAnswer;
  }
  
  analysis = `${detectedItems.length} Einträge aus Excel extrahiert`;
  suggestions = generateDataSuggestions ? generateDataSuggestions(detectedItems, tradeCode) : null;
  
} else {
  // Keine Items gefunden
  console.warn('[FILE-ANALYZE] Excel: No items extracted');
  
  extractedAnswer = result.text || 'Excel analysiert, keine strukturierten Daten gefunden';
  llmContext = extractedAnswer;
  confidence = 0.7;
  analysis = 'Excel-Daten extrahiert (keine Items)';
}

// Prüfe Metadata
if (result.metadata?.quality) {
  confidence = result.metadata.quality.score / 100;
}

  } catch (excelError) {
    console.error('[FILE-ANALYZE] Excel parsing error:', excelError);
    console.error('[FILE-ANALYZE] Error stack:', excelError.stack);
    
    // Fehlerfall: Setze Defaults
    extractedAnswer = 'Excel-Analyse fehlgeschlagen: ' + excelError.message;
    llmContext = extractedAnswer;
    structuredData = { type: 'error', items: [], error: excelError.message };
    documentType = 'SPREADSHEET';
    detectedItems = [];
    confidence = 0.3;
    analysis = 'Excel-Analyse fehlgeschlagen';
    suggestions = null;
  }
}  // <- Diese Klammer schließt den Excel-Block
  
    // PDF-ANALYSE
    else if (file.mimetype === 'application/pdf') {
      console.log('[FILE-ANALYZE] Processing PDF:', file.originalname);
      
      const result = await analyzePdfWithClaude(file.buffer, questionText, tradeCode, questionId);
      
      // NEU: Strukturierte Extraktion aus PDF
      const pdfStructure = await extractStructuredDataFromText(
        result.text,
        tradeCode,
        questionText
      );
      
      // ═══════════════════════════════════════════════════════════════════
      // NEU: Trenne Nutzer-Text von LLM-Context
      // ═══════════════════════════════════════════════════════════════════
      extractedAnswer = pdfStructure.userDisplayText || pdfStructure.enhancedText || result.text;
      llmContext = pdfStructure.llmContextText || pdfStructure.enhancedText || result.text;
      
      // NEU: Log für Debugging
      if (pdfStructure.structured?.hasQuantities) {
        console.log(`[FILE-ANALYZE] ✓ ${pdfStructure.items?.length || 0} Mengenangaben extrahiert`);
        console.log(`[FILE-ANALYZE] User text: ${extractedAnswer.length} chars`);
        console.log(`[FILE-ANALYZE] LLM context: ${llmContext.length} chars`);
      }
      
      structuredData = pdfStructure.structured;
      detectedItems = pdfStructure.items;
      suggestions = pdfStructure.suggestions;
      documentType = result.metadata?.documentType || 'PDF';
      analysis = `${documentType}: ${detectedItems.length} Elemente erkannt`;
      confidence = result.metadata?.confidence || 0.8;
    }
    
    else {
      return res.status(400).json({ 
        error: 'Dateityp nicht unterstützt',
        supportedTypes: ['image/*', '.xlsx', '.xls', '.csv', '.pdf']
      });
    }
    
    // Validierung
    if (!extractedAnswer || extractedAnswer.trim().length === 0) {
      return res.status(422).json({
        error: 'Keine verwertbaren Informationen gefunden'
      });
    }
    
    // ═══════════════════════════════════════════════════════════════════
    // NEU: Speichere in answers Tabelle mit llm_context
    // ═══════════════════════════════════════════════════════════════════
    if (projectId && tradeId && questionId) {
      try {
        // Prüfe ob bereits eine Antwort existiert
        const existingAnswer = await query(`
          SELECT id FROM answers 
          WHERE project_id = $1 AND trade_id = $2 AND question_id = $3
        `, [projectId, tradeId, questionId]);
        
        if (existingAnswer.rows.length > 0) {
          // UPDATE: Bestehende Antwort aktualisieren
          await query(`
            UPDATE answers 
            SET 
              answer_text = $1,
              llm_context = $2,
              assumption = $3,
              updated_at = NOW()
            WHERE project_id = $4 
              AND trade_id = $5 
              AND question_id = $6
          `, [
            extractedAnswer,
            llmContext,
            structuredData ? JSON.stringify(structuredData) : null,
            projectId,
            tradeId,
            questionId
          ]);
          
          console.log('[FILE-ANALYZE] Updated existing answer with llm_context');
        } else {
          // INSERT: Neue Antwort erstellen
          await query(`
            INSERT INTO answers 
            (project_id, trade_id, question_id, answer_text, llm_context, assumption)
            VALUES ($1, $2, $3, $4, $5, $6)
          `, [
            projectId,
            tradeId,
            questionId,
            extractedAnswer,
            llmContext,
            structuredData ? JSON.stringify(structuredData) : null
          ]);
          
          console.log('[FILE-ANALYZE] Created new answer with llm_context');
        }
        
      } catch (dbError) {
        console.error('[FILE-ANALYZE] answers table error:', dbError.message);
        // Nicht kritisch, fahre fort
      }
    }
    
    // In file_uploads speichern (optional, für History)
    if (projectId && tradeId) {
      try {
        await query(`DELETE FROM file_uploads WHERE project_id = $1 AND trade_id = $2 AND question_id = $3`, 
          [projectId, tradeId, questionId]);
        
        await query(`
          INSERT INTO file_uploads 
          (project_id, trade_id, question_id, file_name, file_type, analysis_result, extracted_data, confidence, document_type)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
        `, [
          projectId, 
          tradeId, 
          questionId, 
          file.originalname, 
          file.mimetype,
          JSON.stringify({ answer: extractedAnswer, analysis: analysis }),
          structuredData ? JSON.stringify(structuredData) : null,
          confidence,
          documentType
        ]);
      } catch (dbError) {
        console.error('[FILE-ANALYZE] file_uploads error:', dbError.message);
      }
    }
    
    // NEU: Erweiterte Response mit allen Daten
    res.json({
      success: true,
      extractedAnswer,        // Nur Nutzer-Version (ohne LV-Anweisungen)
      structuredData,
      detectedItems,
      suggestions,
      analysis,
      confidence,
      documentType,
      requiresConfirmation: detectedItems.length > 0,
      metadata: {
        fileName: file.originalname,
        fileType: file.mimetype,
        fileSize: file.size,
        itemCount: detectedItems.length,
        hasLvInstructions: llmContext.length > extractedAnswer.length  // Info ob LV-Anweisungen vorhanden
      }
    });
    
  } catch (error) {
    console.error('[FILE-ANALYZE] Error:', error);
    res.status(500).json({ 
      success: false,
      error: 'Analyse fehlgeschlagen',
      details: error.message
    });
  }
});

function generateLVInstructions(items, originalText) {
  if (!items || items.length === 0) {
    return '';
  }
  
  // Filtere nur Items mit Mengenangaben
  const quantityItems = items.filter(item => {
    return (item.menge && item.einheit) || 
           (item.quantity && item.unit) ||
           (item.anzahl && item.einheit) ||
           (item.flaeche && item.einheit);
  });
  
  if (quantityItems.length === 0) {
    return '';
  }
  
  // Erkenne Fläche/Umfang aus originalText (universell)
  let analyseUmfang = '';
  const flächeMatch = originalText.match(/(\d+)[-–\s]*(\d*)\s*m²/i);
  
  if (flächeMatch) {
    const flaeche = flächeMatch[2] ? 
      Math.round((parseInt(flächeMatch[1]) + parseInt(flächeMatch[2])) / 2) : 
      flächeMatch[1];
    analyseUmfang = `ca. ${flaeche} m²`;
  }
  
  // Erkenne Art des Dokuments (universell)
  let dokumentTyp = 'analysiertes Dokument/Plan';
  if (originalText.match(/wohnung|apartment/i)) dokumentTyp = 'analysierte Wohnung';
  else if (originalText.match(/haus|einfamilienhaus|efh/i)) dokumentTyp = 'analysiertes Gebäude';
  else if (originalText.match(/geschoss|etage|og|eg/i)) dokumentTyp = 'analysiertes Geschoss';
  else if (originalText.match(/raum|zimmer|bereich/i)) dokumentTyp = 'analysierter Bereich';
  else if (originalText.match(/gewerbe|laden|büro/i)) dokumentTyp = 'analysierte Gewerbeeinheit';

  let instructions = `

═══════════════════════════════════════════════════════════════════
🔴🔴🔴 KRITISCH: VERBINDLICHE MENGEN FÜR LV-KALKULATION 🔴🔴🔴
═══════════════════════════════════════════════════════════════════

╔══════════════════════════════════════════════════════════════════╗
║  ⚠️⚠️⚠️  ABSOLUTE REGEL - MENGEN NICHT HOCHRECHNEN  ⚠️⚠️⚠️      ║
╚══════════════════════════════════════════════════════════════════╝

🎯 ANALYSIERTER UMFANG: ${dokumentTyp}${analyseUmfang ? ' (' + analyseUmfang + ')' : ''}

Die unten stehenden Mengen wurden aus dem hochgeladenen Dokument/Plan 
extrahiert und gelten EXAKT FÜR DIESEN ANALYSIERTEN UMFANG.

⚠️  KRITISCHE REGEL:
   Diese Mengen sind FINAL und VOLLSTÄNDIG für den analysierten Bereich.
   
   → KEINE Hochrechnung auf weitere/andere Bereiche
   → KEINE Multiplikation mit "Anzahl Einheiten/Wohnungen/Geschosse"
   → KEINE Annahmen über nicht-analysierte Bereiche
   → KEINE "Typischen Werte" für Gesamtprojekt einsetzen

🔴 AUCH WENN IM PROJEKT-KONTEXT STEHT:
   "X Wohneinheiten", "Y Geschosse", "Mehrfamilienhaus", "Gesamtgebäude"
   
   GILT FÜR DIESE MENGEN:
   → Sie beziehen sich NUR auf den analysierten Umfang
   → NICHT auf das Gesamtprojekt hochrechnen
   → NICHT mit Projekt-Umfang multiplizieren

📌 PRINZIP:
   Dokument zeigt → 4 Sanitärobjekte
   LV erstellt → 4 Sanitärobjekte
   
   NICHT:
   Dokument zeigt → 4 Sanitärobjekte
   Projekt hat → 5 Einheiten
   LV erstellt → 20 Objekte (× 5) ❌ FALSCH!

`;

  // Füge die extrahierten Positionen ein
  instructions += `
Die folgenden ${quantityItems.length} Positionen wurden extrahiert und sind
ABSOLUT VERBINDLICH für die LV-Erstellung:

`;

  quantityItems.forEach((item, index) => {
    const typ = item.typ || item.type || item.kategorie || item.name || 'Position';
    const menge = item.menge || item.quantity || item.anzahl || item.flaeche;
    const einheit = item.einheit || item.unit || 'Stk';
    const bereich = item.bereich || item.range || item.bereichText;
    const beschreibung = item.beschreibung || item.details?.beschreibung || item.description || '';
    
    instructions += `
${index + 1}. Position: ${typ}
   → Analysierte Menge: ${bereich || menge} ${einheit}
   → VERWENDE FÜR LV: ${menge} ${einheit}
   → Quelle: Datenextraktion aus hochgeladenem Dokument
   ⛔ NICHT hochrechnen auf Projekt-Gesamtumfang!`;
    
    if (beschreibung) {
      instructions += `
   → Details: ${beschreibung}`;
    }
    
    instructions += `\n`;
  });

  instructions += `
───────────────────────────────────────────────────────────────────
⚠️  ABSOLUT VERBINDLICH - KEINE ABWEICHUNGEN ERLAUBT!
───────────────────────────────────────────────────────────────────

KRITISCHE REGELN FÜR LV-ERSTELLUNG:

✅ PFLICHT-REGELN:
   ✓ Die oben genannten Mengen MÜSSEN EXAKT übernommen werden
   ✓ Maximal ±10% Abweichung (nur für sinnvolle Rundungen)
   ✓ Bei Bereichen (z.B. "85-95"): Verwende den angegebenen Mittelwert
   ✓ Alle ${quantityItems.length} Positionen MÜSSEN im LV enthalten sein
   ✓ Diese Mengen sind FINAL - gelten für analysierten Umfang

❌ VERBOTE:
   ✗ VERBOTEN: Eigene Schätzungen verwenden
   ✗ VERBOTEN: "Typische Werte" aus Templates einsetzen
   ✗ VERBOTEN: Mengen ohne Begründung ändern
   ✗ VERBOTEN: Hochrechnung auf "Gesamt-Projekt"
   ✗ VERBOTEN: Multiplikation mit "Anzahl X" (Einheiten/Wohnungen/Geschosse)
   ✗ VERBOTEN: Annahmen über nicht-analysierte Bereiche
   ✗ VERBOTEN: Text wie "in X Einheiten" oder "für X Bereiche" hinzufügen
   ✗ VERBOTEN: Positionen weglassen oder vergessen

📋 POSITIONS-PFLICHT:
   → Oben stehen ${quantityItems.length} Positionen
   → LV MUSS mindestens ${quantityItems.length} Positionen enthalten
   → JEDE Position oben = 1 Position im LV
   → Fehlende Positionen = KRITISCHER FEHLER

KONKRETE FEHLER-BEISPIELE:

❌ TYPISCHE FEHLER - SO NICHT:

1. Hochrechnung/Multiplikation:
   • Analyse: "4 Sanitärobjekte"
     Projekt-Info: "5 Einheiten"
     LV erstellt: "20 Sanitärobjekte in 5 Bädern" (× 5 multipliziert!)
     → ❌ FEHLER! Menge wurde hochgerechnet!

   • Analyse: "87 m² Bodenbelag"
     Projekt-Info: "5 Wohnungen"
     LV erstellt: "435 m² Bodenbelag" (× 5 multipliziert!)
     → ❌ FEHLER! Fläche wurde hochgerechnet!

   • Analyse: "7 Türen"
     Projekt-Info: "3 Geschosse"
     LV erstellt: "21 Türen in 3 Etagen" (× 3 multipliziert!)
     → ❌ FEHLER! Anzahl wurde hochgerechnet!

2. Fehlende Positionen:
   • Analyse: 12 Positionen (inkl. "7 Türen entfernen")
     LV erstellt: 11 Positionen - Türen fehlen
     → ❌ FEHLER! Position wurde vergessen!

3. Falsche Beschreibungen:
   • Analyse: "4 Sanitärobjekte"
     LV: "Sanitärobjekte in 5 Bädern demontieren"
     → ❌ FEHLER! "in 5 Bädern" hinzugefügt!

✅ RICHTIG - SO MUSS ES SEIN:

1. Exakte Übernahme:
   • Analyse: "4 Sanitärobjekte"
     LV erstellt: "Sanitärobjekte demontieren, 4 Stück"
     → ✅ KORREKT! Exakte Menge übernommen

   • Analyse: "87 m² Bodenbelag"
     LV erstellt: "Bodenbelag entfernen, 87 m²"
     → ✅ KORREKT! Exakte Fläche übernommen

   • Analyse: "7 Türen"
     LV erstellt: "Innentüren mit Zargen entfernen, 7 Stück"
     → ✅ KORREKT! Exakte Anzahl übernommen

2. Alle Positionen vorhanden:
   • Analyse: 12 Positionen
     LV erstellt: 12+ Positionen
     → ✅ KORREKT! Alle Positionen enthalten

3. Neutrale Beschreibungen:
   • ✅ RICHTIG: "Sanitärobjekte demontieren inkl. Anschlüsse"
   • ✅ RICHTIG: "Badewanne, WC, Waschbecken und Dusche demontieren"
   • ❌ FALSCH: "Sanitärobjekte in X Einheiten demontieren"
   • ❌ FALSCH: "Je Y Objekte pro Bereich in X Bereichen"

VALIDIERUNGS-CHECKLISTE VOR LV-ERSTELLUNG:

□ Habe ich alle ${quantityItems.length} Positionen erstellt?
□ Habe ich alle Mengen EXAKT übernommen (max. ±10% Rundung)?
□ Habe ich KEINE Menge mit Projekt-Umfang multipliziert?
□ Habe ich KEINE Hochrechnung auf Gesamt-Projekt gemacht?
□ Sind meine Beschreibungen neutral (ohne "in X Einheiten")?
□ Habe ich KEINE Position vergessen oder weggelassen?

───────────────────────────────────────────────────────────────────
Bei Nichtbeachtung dieser Regeln: LV gilt als FEHLERHAFT!

WICHTIG: Diese Anweisungen haben ABSOLUTE PRIORITÄT vor:
- Projekt-Beschreibung (z.B. "X Einheiten gesamt")
- LV-Templates ("typische Werte")
- Eigenen Annahmen oder Schätzungen
- Jeglichen anderen Informationen

Die analysierten Mengen sind FINAL und VERBINDLICH!
═══════════════════════════════════════════════════════════════════
`;

  return instructions;
}

// Extrahiere strukturierte Daten aus Bild-Analyse-Text
async function extractStructuredDataFromImage(analysisText, tradeCode, questionText) {
  try {
    const prompt = `Du bist ein Experte für Baudaten-Extraktion.
Analysiere folgenden Text aus einer Bildanalyse und extrahiere strukturierte Daten:
TEXT: "${analysisText}"
KONTEXT: ${tradeCode} - ${questionText}

WICHTIG: Extrahiere ALLE Mengenangaben mit Einheiten!
- Flächen in m² (z.B. Bodenbeläge, Estrich, Fliesen)
- Längen in m (z.B. Wände, Leitungen)
- Anzahlen als Stk (z.B. Türen, Fenster, Sanitärobjekte)
- Volumen in m³ (z.B. Schutt, Beton)

Wenn du einen Bereich findest (z.B. "85-95 m²"), berechne den Mittelwert für "menge".

Antworte NUR mit diesem JSON-Format:
{
  "items": [
    {
      "typ": "Bodenbelag entfernen",
      "menge": 90,
      "einheit": "m²",
      "bereich": "85-95",
      "beschreibung": "Alle Räume außer Balkone"
    }
  ],
  "suggestions": ["Hinweis wenn nötig"]
}

WICHTIG: 
- Jedes Item MUSS "typ", "menge" und "einheit" haben
- Bei Bereichen: "bereich" als String UND "menge" als Mittelwert`;

    const response = await llmWithPolicy('questions', [
      { role: 'user', content: prompt }
    ], { 
      maxTokens: 2000,
      temperature: 0.3,
      jsonMode: true 
    });
    
    // Bereinige Markdown-Code-Blocks
    let cleanedResponse = response.trim();
    if (cleanedResponse.startsWith('```json')) {
      cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/```\s*$/, '');
    } else if (cleanedResponse.startsWith('```')) {
      cleanedResponse = cleanedResponse.replace(/^```\s*/, '').replace(/```\s*$/, '');
    }

    const parsed = JSON.parse(cleanedResponse);
    
    // NEU: Generiere LV-Anweisungen (NUR für LLM)
    const lvInstructions = generateLVInstructions(parsed.items, analysisText);
    
    // NEU: Separate Texte
    const userDisplayText = analysisText; // NUR die Original-Analyse
    const llmContextText = analysisText + lvInstructions; // Analyse + Anweisungen
    
    const itemsWithQuantities = parsed.items.filter(item => item.menge && item.einheit);
    if (itemsWithQuantities.length > 0) {
      console.log(`[IMAGE-STRUCTURE] ✓ ${itemsWithQuantities.length} Mengenangaben extrahiert`);
      itemsWithQuantities.forEach(item => {
        console.log(`  - ${item.typ}: ${item.menge} ${item.einheit}`);
      });
    }
    
    return {
      structured: { 
        type: 'IMAGE_EXTRACTION', 
        items: parsed.items,
        hasQuantities: itemsWithQuantities.length > 0
      },
      items: parsed.items || [],
      suggestions: parsed.suggestions || [],
      userDisplayText: userDisplayText,      // NEU: Für Nutzer
      llmContextText: llmContextText,        // NEU: Für LV-Generator
      enhancedText: llmContextText           // Backwards compatibility
    };
    
  } catch (err) {
    console.error('[IMAGE-STRUCTURE] Error:', err);
    return {
      structured: null,
      items: [],
      suggestions: [],
      userDisplayText: analysisText,
      llmContextText: analysisText,
      enhancedText: analysisText
    };
  }
}

// Extrahiere strukturierte Daten aus PDF-Text
async function extractStructuredDataFromText(text, tradeCode, questionText) {
  try {
    const prompt = `Du bist ein Experte für Baudaten-Extraktion aus Dokumenten.
Extrahiere aus folgendem PDF-Text alle relevanten strukturierten Daten:
TEXT: "${text.substring(0, 5000)}"
KONTEXT: ${tradeCode} - ${questionText}

WICHTIG: Suche nach Listen, Tabellen, Mengen, Maßen, Spezifikationen.
Extrahiere ALLE Mengenangaben mit Einheiten!

Antworte NUR mit diesem JSON-Format:
{
  "items": [...],
  "suggestions": [...]
}`;

    const response = await llmWithPolicy('questions', [
      { role: 'user', content: prompt }
    ], { 
      maxTokens: 2000,
      temperature: 0.3,
      jsonMode: true 
    });
    
    let cleanedResponse = response.trim();
    if (cleanedResponse.startsWith('```json')) {
      cleanedResponse = cleanedResponse.replace(/^```json\s*/, '').replace(/```\s*$/, '');
    } else if (cleanedResponse.startsWith('```')) {
      cleanedResponse = cleanedResponse.replace(/^```\s*/, '').replace(/```\s*$/, '');
    }

    const parsed = JSON.parse(cleanedResponse);
    
    // NEU: Generiere LV-Anweisungen (NUR für LLM)
    const lvInstructions = generateLVInstructions(parsed.items, text);
    
    // NEU: Separate Texte
    const userDisplayText = text.substring(0, 5000);
    const llmContextText = text.substring(0, 5000) + lvInstructions;
    
    const itemsWithQuantities = parsed.items.filter(item => item.menge && item.einheit);
    if (itemsWithQuantities.length > 0) {
      console.log(`[PDF-STRUCTURE] ✓ ${itemsWithQuantities.length} Mengenangaben extrahiert`);
    }
    
    return {
      structured: { 
        type: 'PDF_EXTRACTION', 
        items: parsed.items,
        hasQuantities: itemsWithQuantities.length > 0
      },
      items: parsed.items || [],
      suggestions: parsed.suggestions || [],
      userDisplayText: userDisplayText,      // NEU: Für Nutzer
      llmContextText: llmContextText,        // NEU: Für LV-Generator
      enhancedText: llmContextText
    };
    
  } catch (err) {
    console.error('[PDF-STRUCTURE] Error:', err);
    return {
      structured: null,
      items: [],
      suggestions: [],
      userDisplayText: text.substring(0, 5000),
      llmContextText: text.substring(0, 5000),
      enhancedText: text.substring(0, 5000)
    };
  }
}

// Generiere Verbesserungsvorschläge
function generateDataSuggestions(items, tradeCode) {
  const suggestions = [];
  
  if (items.length === 0) {
    suggestions.push('Keine Elemente erkannt - bitte Datei prüfen');
    return suggestions;
  }
  
  // NEU: Prüfe ob Mengenangaben vorhanden sind
  const itemsWithQuantities = items.filter(item => 
    (item.menge && item.einheit) || 
    (item.quantity && item.unit) ||
    (item.anzahl && item.einheit)
  );
  
  if (itemsWithQuantities.length === 0) {
    suggestions.push('⚠️ Keine Mengenangaben gefunden - manuelle Eingabe erforderlich');
  } else {
    suggestions.push(`✓ ${itemsWithQuantities.length} Mengenangaben extrahiert und für LV vorbereitet`);
  }
  
  // Prüfe fehlende Standardfelder
  const firstItem = items[0];
  
  if (tradeCode === 'FEN' || tradeCode === 'TIS') {
    if (!firstItem.breite && !firstItem.width) {
      suggestions.push('💡 Breiten-Angaben fehlen teilweise');
    }
    if (!firstItem.hoehe && !firstItem.height) {
      suggestions.push('💡 Höhen-Angaben fehlen teilweise');
    }
    if (!firstItem.material) {
      suggestions.push('💡 Material-Angaben könnten ergänzt werden');
    }
  }
  
  return suggestions;
}

// NEUE ROUTE: Füge nach der bestehenden '/question-clarification' Route ein (ca. Zeile 2500+)
app.post('/api/projects/:projectId/trades/:tradeId/question-explanation', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { questionText, questionId, shortExplanation, questionCategory } = req.body;
    
    // Trade-Info holen
    const tradeResult = await query(
      'SELECT name, code FROM trades WHERE id = $1',
      [tradeId]
    );
    
    if (!tradeResult.rows[0]) {
      return res.status(404).json({ error: 'Trade nicht gefunden' });
    }
    
    const tradeName = tradeResult.rows[0].name;
    const tradeCode = tradeResult.rows[0].code;
    const isIntake = tradeCode === 'INT';
    
    const systemPrompt = `Du bist ein Experte für ${isIntake ? 'Bauprojektaufnahme' : tradeName}.
    
Erstelle eine AUSFÜHRLICHE, HILFREICHE Erklärung für diese Frage.
Die Erklärung soll Laien helfen, die Frage richtig zu verstehen und zu beantworten.

STRUKTUR (100-200 Wörter insgesamt):

1. KONTEXT & ZWECK (20-30 Wörter):
   - Warum wird diese Information benötigt?
   - Wie beeinflusst sie Kosten und Aufwand?
   - Welche Folgearbeiten hängen davon ab?

2. LAIENVERSTÄNDLICHE ERKLÄRUNG (40-60 Wörter):
   - Fachbegriffe in Alltagssprache übersetzen
   - Vergleiche mit bekannten Dingen ("wie ein...")
   - Visuelle Beschreibung ("sieht aus wie...")
   - Wo man es im Gebäude findet

3. PRAKTISCHE ANLEITUNG (30-50 Wörter):
   - WO genau messen/schauen/prüfen?
   - WIE messen? (Zollstock anlegen von...bis...)
   - WOMIT messen? (Werkzeuge)
   - Häufige Fehler vermeiden

4. KONKRETE BEISPIELE (30-40 Wörter):
   Bei Qualitätsfragen IMMER Produkte/Marken zur Orientierung:
   
   SANITÄR:
   - Standard: "Baumarkt-Eigenmarken, Grohe Start, Ideal Standard Connect"
   - Gehoben: "Duravit D-Code, Hansgrohe Focus, Keramag Renova"
   - Premium: "Villeroy & Boch Subway, Dornbracht, Kaldewei, Bette"
   
   FLIESEN:
   - Standard: "Baumarkt-Fliesen (15-25 €/m²)"
   - Gehoben: "Deutsche Markenhersteller wie Agrob Buchtal (30-50 €/m²)"
   - Premium: "Italienische Feinsteinzeug, Großformate 120x120cm (60-120 €/m²)"
   
   FENSTER:
   - Standard: "Kunststoff weiß, Veka/Rehau Profile (400-500 €/m²)"
   - Gehoben: "Kunststoff mit Dekor oder Holz (500-700 €/m²)"
   - Premium: "Holz-Alu Kombination, Internorm/Unilux (700-1000 €/m²)"
   
   BODENBELÄGE:
   - Standard: "Laminat Klasse 31 (20-35 €/m²)"
   - Gehoben: "3-Schicht Parkett Eiche (60-90 €/m²)"
   - Premium: "Massivparkett, Fischgrät verlegt (100-150 €/m²)"
   
   TÜREN:
   - Standard: "Dekor-Türen CPL/Laminat (150-250 €/Stück)"
   - Gehoben: "Echtholz furniert oder lackiert (300-500 €/Stück)"
   - Premium: "Massivholz, Sonderanfertigungen (600-1200 €/Stück)"
   
   PREISANGABEN:
   - IMMER relative Unterschiede: "Gehoben ist 40-60% teurer als Standard"
   - IMMER mit Einheit: €/m², €/Stück, €/lfdm
   - NIE absolute Preise ohne Größenangabe
   
e) EMPFEHLUNG BEI UNSICHERHEIT (20-30 Wörter):
   - "Bei Unsicherheit empfehlen wir: [konkreter Wert]"
   - "80% unserer Kunden wählen: [Option]"
   - "Für Ihr Projekt passend wäre: [Empfehlung]"

BEISPIEL EINER VOLLSTÄNDIGEN ERKLÄRUNG:

Frage: "Welche Qualitätsstufe wünschen Sie für die Sanitärausstattung?"

explanation: "Die Qualitätsstufe bestimmt Preis und Lebensdauer Ihrer Badausstattung erheblich. Je nach Wahl variieren die Kosten zwischen 800€ (Standard) und 5000€ (Premium) pro Bad. 
Standard-Qualität wie Grohe Start (WC ~150€) oder Ideal Standard (Waschtisch ~120€) bietet solide Funktionalität für Mietobjekte. Gehobene Qualität wie Hansgrohe (Armaturen ~180€) oder Duravit (WC ~300€) verbindet Design mit Komfort - ideal für Eigennutzung. Premium-Marken wie Dornbracht (Armaturen ~500€) oder Villeroy & Boch (WC ~600€) bieten Luxus und 15+ Jahre Haltbarkeit.
Die Qualität beeinflusst auch Wartungskosten: Standard braucht alle 3-5 Jahre Service, Premium erst nach 8-10 Jahren. Bei Unsicherheit empfehlen wir für Eigennutzung die gehobene Qualität - bestes Preis-Leistungs-Verhältnis."

Frage: "Ist ein Ringbalken/Ringanker vorhanden?"

explanation: "Ein Ringbalken ist ein umlaufender Betonbalken oben auf den Mauern - wie ein stabilisierender Gürtel ums Haus. Er verteilt Dachlasten gleichmäßig und verhindert, dass Wände auseinanderdriften.
Sie erkennen ihn als durchgehenden grauen Betonstreifen (20-30cm hoch) auf der Mauerkrone. Gehen Sie dazu auf den Dachboden und schauen Sie, wo die Dachbalken aufliegen. Dort sollte ein durchgehender Betonbalken sichtbar sein.
Bei Altbauten vor 1960 meist nicht vorhanden, ab 1970 Standard. Ohne Ringbalken sind bei Dacharbeiten Verstärkungen nötig (Mehrkosten 3000-5000€). Falls unsicher: Machen Sie Fotos vom Dachboden, besonders vom Übergang Wand/Dach. Wir gehen im Zweifel von 'nicht vorhanden' aus."

Frage: "Welche Qualitätsstufe wünschen Sie für die Sanitärausstattung?"

explanation: "Die Qualitätsstufe bestimmt Preis, Haltbarkeit und Design erheblich. Standard-Qualität (Baumarkt-Eigenmarken, Grohe Start, Ideal Standard Connect) bietet solide Funktionalität - ein WC kostet 150-250€, Waschtisch 100-200€. Gehobene Qualität (Duravit D-Code, Hansgrohe Focus, Keramag Icon) verbindet Design mit Komfort - WC 300-450€, Waschtisch 250-400€. Premium (Villeroy & Boch Subway, Dornbracht, Kaldewei) bietet exklusives Design und beste Materialien - WC 500-800€, Waschtisch 400-700€. Die Preisdifferenz zwischen Standard und Gehoben beträgt etwa 50-70%, zu Premium 150-200%. Wartungsintervalle: Standard alle 5 Jahre, Premium erst nach 10-15 Jahren. Für Mietobjekte empfehlen wir Standard, für Eigennutzung Gehoben als beste Preis-Leistung."

Frage: "Welche Öffnungsart wünschen Sie für die Fenster?"

explanation: "Die Öffnungsart bestimmt Komfort, Sicherheit und Preis. Dreh-Kipp-Fenster (Standard) bieten optimale Lüftung und Reinigungsmöglichkeit. Nur-Kipp ist etwa 20% günstiger, aber eingeschränkt nutzbar. Festverglasung spart 40-50% gegenüber Dreh-Kipp, erlaubt aber keine Lüftung. Schiebefenster kosten 30-40% mehr als Dreh-Kipp, sparen aber Platz. Die Preise variieren stark nach Größe und Material: Kunststoff-Dreh-Kipp kostet 400-600€/m², Holz 25-30% mehr, Holz-Alu 50-70% mehr. Ein 1,2x1,4m Fenster hat ca. 1,7m². Für Wohnräume empfehlen wir Dreh-Kipp, für Bäder Kipp (Sichtschutz). Bei Unsicherheit: Dreh-Kipp als flexibelste Lösung."

FALSCH: "Dreh-Kipp-Fenster kosten 600€" (Welche Größe? Material?)
RICHTIG: "Kunststoff-Dreh-Kipp: 400-600€/m², bei 1,5m² Fenster also 600-900€"

FALSCH: "Parkett kostet 80€"
RICHTIG: "Parkett: 50-120€/m² Material plus 25-40€/m² Verlegung"

WICHTIG: Diese ausführlichen Erklärungen sind PFLICHT für jede Frage!

KRITISCH - STRUCTURE DER EXPLANATION (IMMER 100-200 WÖRTER):

1. KONTEXT (20-30 Wörter): Warum ist diese Info wichtig für die Kalkulation?
2. LAIEN-ERKLÄRUNG (40-60 Wörter): Was bedeutet das in einfachen Worten?
3. MESS-/PRÜFANLEITUNG (30-50 Wörter): Wo und wie genau messen/prüfen?
4. BEISPIELE (30-40 Wörter): Bei Qualität: Konkrete Produkte mit Preisen
5. EMPFEHLUNG (20-30 Wörter): "Bei Unsicherheit empfehlen wir..."

BEISPIEL EINER PERFEKTEN EXPLANATION:
"Die Qualitätsstufe bestimmt Preis und Lebensdauer erheblich - zwischen 800€ (Standard) und 5000€ (Premium) pro Bad. Standard wie Grohe Start (WC ~150€) oder Ideal Standard (Waschtisch ~120€) ist solide für Mietobjekte. Gehoben wie Hansgrohe (Armaturen ~180€) oder Duravit (WC ~300€) verbindet Design mit Komfort. Premium wie Dornbracht (Armaturen ~500€) oder Villeroy & Boch (WC ~600€) bietet Luxus und 15+ Jahre Haltbarkeit. Die Wahl beeinflusst auch Wartung: Standard braucht alle 3-5 Jahre Service, Premium erst nach 8-10 Jahren. Bei Unsicherheit empfehlen wir gehobene Qualität für Eigennutzung - bestes Preis-Leistungs-Verhältnis."

${tradeCode === 'FEN' ? 'Beachte: Bei Fenstern sind Einzelmaße wichtig für präzise Kalkulation.' : ''}
${tradeCode === 'SAN' ? 'Beachte: Nenne konkrete Sanitärmarken als Orientierung (Standard/Gehoben/Premium).' : ''}

Antworte als JSON-Objekt mit strukturierten Feldern.`;

    const userPrompt = `Frage: "${questionText}"
Bisheriger Kurzhinweis: "${shortExplanation}"
Kategorie: ${questionCategory || 'Allgemein'}
Gewerk: ${tradeName} (${tradeCode})

Erstelle eine vollständige, hilfreiche Erklärung die alle wichtigen Aspekte abdeckt.`;

    const response = await llmWithPolicy('question-explanation', [
      { role: 'system', content: systemPrompt },
      { role: 'user', content: userPrompt }
    ], { 
      maxTokens: 3000,  // ERHÖHT von 2000!
      temperature: 0.3,
      jsonMode: true
    });
    
    // Aggressive Bereinigung
    let cleanedResponse = response
      .replace(/```json\s*/gi, '')
      .replace(/```\s*/gi, '')
      .replace(/\n/g, ' ')  // Ersetze alle Zeilenumbrüche
      .trim();
    
    // JSON Start finden
    const jsonStart = cleanedResponse.indexOf('{');
    const jsonEnd = cleanedResponse.lastIndexOf('}');
    
    if (jsonStart === -1 || jsonEnd === -1) {
      throw new Error('No valid JSON found in response');
    }
    
    cleanedResponse = cleanedResponse.substring(jsonStart, jsonEnd + 1);
    
    // Parse mit mehreren Versuchen
    let details;
    try {
      details = JSON.parse(cleanedResponse);
    } catch (firstError) {
      // Zweiter Versuch: Escape problematische Zeichen
      try {
        const escaped = cleanedResponse
          .replace(/\\/g, '\\\\')
          .replace(/"/g, '\\"')
          .replace(/\t/g, ' ')
          .replace(/\r/g, ' ');
        details = JSON.parse(`{"fullExplanation": "${escaped}"}`);
      } catch (secondError) {
        console.error('All parse attempts failed');
        details = {
          fullExplanation: "Die ausführliche Erklärung konnte leider nicht geladen werden. Bitte versuchen Sie es erneut oder kontaktieren Sie den Support.",
          measurementGuide: null,
          productExamples: null,
          visualHint: null,
          commonMistakes: null,
          defaultRecommendation: null
        };
      }
    }
    
    // Response senden - mit Längen-Sicherheit
    res.json({
      fullExplanation: (details.fullExplanation || details.explanation || "Keine Erklärung verfügbar").substring(0, 2000),
      measurementGuide: details.measurementGuide ? String(details.measurementGuide).substring(0, 1000) : null,
      productExamples: details.productExamples ? String(details.productExamples).substring(0, 1000) : null,
      visualHint: details.visualHint ? String(details.visualHint).substring(0, 500) : null,
      commonMistakes: details.commonMistakes ? String(details.commonMistakes).substring(0, 500) : null,
      defaultRecommendation: details.defaultRecommendation ? String(details.defaultRecommendation).substring(0, 500) : null
    });
    
  } catch (error) {
    console.error('Error generating detailed explanation:', error);
    res.status(500).json({ 
      error: 'Fehler beim Laden der ausführlichen Erklärung',
      details: error.message 
    });
  }
});

// Generate detailed LV for a trade
app.post('/api/projects/:projectId/trades/:tradeId/lv', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    const isAssigned = await isTradeAssignedToProject(projectId, tradeId);
    
    const tradeInfo = await query('SELECT code FROM trades WHERE id = $1', [tradeId]);
    const tradeCode = tradeInfo.rows[0]?.code;
    
    if (!isAssigned && tradeCode !== 'INT') {
      console.log(`[LV] Trade ${tradeId} not assigned to project ${projectId}, adding it now`);
      await ensureProjectTrade(projectId, tradeId, 'lv_generation');
    }
    
    // Generiere detailliertes LV
    const lv = await generateDetailedLVWithRetry(projectId, tradeId);
    
    // Speichere LV in DB
await query(
  `INSERT INTO lvs (project_id, trade_id, content)
   VALUES ($1,$2,$3)
   ON CONFLICT (project_id, trade_id)
   DO UPDATE SET content=$3, updated_at=NOW()`,
  [projectId, tradeId, JSON.stringify(lv)]  // <-- JSON.stringify() hinzugefügt!
);
    
    console.log(`[LV] Generated for trade ${tradeId}: ${lv.positions?.length || 0} positions, Total: €${lv.totalSum || 0}`);
    
    res.json({ 
      ok: true, 
      trade: { 
        id: tradeId, 
        code: tradeCode, 
        name: tradeInfo.rows[0]?.name 
      }, 
      lv
    });
    
  } catch (err) {
    console.error('Generate LV failed:', err);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// DELETE TRADE - Gewerk komplett löschen
app.delete('/api/projects/:projectId/trades/:tradeId/delete', async (req, res) => {
  const { projectId, tradeId } = req.params;
  
  console.log(`[DELETE-TRADE] Deleting trade ${tradeId} from project ${projectId}`);
  
  try {
    // Optional: Logging was gelöscht wird
    const answersCheck = await query(
      'SELECT COUNT(*) FROM answers WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    const questionsCheck = await query(
      'SELECT COUNT(*) FROM questions WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    const lvsCheck = await query(
      'SELECT COUNT(*) FROM lvs WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    console.log(`[DELETE-TRADE] Will delete: ${answersCheck.rows[0].count} answers, ${questionsCheck.rows[0].count} questions, ${lvsCheck.rows[0].count} lvs`);
    
    // EINE Query - CASCADE löscht den Rest automatisch
    const result = await query(
      'DELETE FROM project_trades WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (result.rowCount === 0) {
      return res.status(404).json({ error: 'Gewerk nicht gefunden' });
    }
    
    console.log(`[DELETE-TRADE] ✅ Successfully deleted trade ${tradeId} (CASCADE cleaned all related data)`);
    
    res.json({ 
      success: true, 
      message: `Gewerk ${tradeId} erfolgreich gelöscht`,
      deletedTradeId: parseInt(tradeId)
    });
    
  } catch (error) {
    console.error('[DELETE-TRADE] Error:', error);
    res.status(500).json({ 
      error: 'Fehler beim Löschen des Gewerks',
      details: error.message 
    });
  }
});

// ANPASSUNG des bestehenden Endpoints: Get aggregated LVs for a project
app.get('/api/projects/:projectId/lv', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { includeSkipped } = req.query; // NEU: Optional Parameter
    
    // ANGEPASSTE Query mit Filter für übersprungene Trades
    let query_string = `
      SELECT 
        l.trade_id, 
        t.code, 
        t.name, 
        l.content,
        l.status as lv_status,
        l.reviewed_at,
        l.questions_completed,
        l.skipped,
        tp.status as progress_status
      FROM lvs l 
      JOIN trades t ON t.id = l.trade_id
      LEFT JOIN trade_progress tp ON l.trade_id = tp.trade_id AND l.project_id = tp.project_id
      WHERE l.project_id = $1
    `;
    
    // NEU: Filtere übersprungene, außer explizit angefordert
    if (includeSkipped !== 'true') {
      query_string += ` AND (l.skipped = FALSE OR l.skipped IS NULL)`;
    }
    
    query_string += ` ORDER BY t.name`;
    
    const rows = (await query(query_string, [projectId])).rows;

    const lvs = rows.map(row => ({
      ...row,
      trade_id: row.trade_id, // Wichtig für Frontend
      trade_name: row.name,    // Wichtig für Frontend
      trade_code: row.code,    // Wichtig für Frontend
      content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content,
      // NEU: Zusätzliche Status-Informationen
      isReviewed: !!row.reviewed_at,
      isSkipped: row.skipped || false,
      progressStatus: row.progress_status || 'pending'
    }));
    
    // NEU: Berechne Summen mit NEP-Berücksichtigung
    let totalSum = 0;
    let totalNepSum = 0;
    let totalPositions = 0;
    
    lvs.forEach(lv => {
      if (lv.content) {
        totalSum += parseFloat(lv.content.totalSum) || 0;
        totalNepSum += parseFloat(lv.content.nepSum) || 0;
        totalPositions += lv.content.positions?.length || 0;
      }
    });
    
    // NEU: Erweiterte Summary
    const summary = {
      totalTrades: lvs.length,
      totalPositions,
      totalSum,
      totalNepSum,  // NEU
      vat: totalSum * 0.19,
      grandTotal: totalSum * 1.19,
      reviewedCount: lvs.filter(lv => lv.isReviewed).length,  // NEU
      skippedCount: lvs.filter(lv => lv.isSkipped).length     // NEU
    };
    
    res.json({ 
      ok: true, 
      lvs,
      summary
    });
    
  } catch (err) {
    console.error('aggregate LV failed:', err);
    res.status(500).json({ ok: false, error: err.message });
  }
});

// ZUSÄTZLICH: Neuer Endpoint für einzelnes LV (für Review-Page)
app.get('/api/projects/:projectId/trades/:tradeId/lv', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    const result = await query(`
      SELECT 
        l.*,
        t.name as trade_name,
        t.code as trade_code,
        tp.status as progress_status,
        tp.reviewed_at as review_date
      FROM lvs l
      JOIN trades t ON l.trade_id = t.id
      LEFT JOIN trade_progress tp ON l.trade_id = tp.trade_id AND l.project_id = tp.project_id
      WHERE l.project_id = $1 AND l.trade_id = $2
    `, [projectId, tradeId]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'LV nicht gefunden' });
    }
    
    const lv = result.rows[0];
    lv.content = typeof lv.content === 'string' ? JSON.parse(lv.content) : lv.content;
    
    res.json({ 
      lv: {
        ...lv,
        isReviewed: !!lv.review_date,
        progressStatus: lv.progress_status || 'pending'
      }
    });
    
  } catch (error) {
    console.error('Error fetching single LV:', error);
    res.status(500).json({ error: 'Fehler beim Laden des LVs' });
  }
});

// Get all LVs for a project
app.get('/api/projects/:projectId/lvs', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT l.*, t.name as trade_name, t.code as trade_code
       FROM lvs l
       JOIN trades t ON t.id = l.trade_id
       WHERE l.project_id = $1`,
      [projectId]
    );
    
    const lvs = result.rows.map(row => ({
      ...row,
      content: typeof row.content === 'string' ? JSON.parse(row.content) : row.content
    }));
    
    res.json({ lvs });
    
  } catch (err) {
    console.error('Failed to fetch LVs:', err);
    res.status(500).json({ error: err.message });
  }
});

// Update LV positions (für Edit und Delete)
app.post('/api/projects/:projectId/trades/:tradeId/lv/update', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { positions, totalSum } = req.body;
    
    // Hole existierendes LV
    const existing = await query(
      'SELECT content FROM lvs WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (existing.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }
    
    const existingContent = typeof existing.rows[0].content === 'string' 
      ? JSON.parse(existing.rows[0].content) 
      : existing.rows[0].content;
    
    // NEU: Berechne Summen mit NEP-Berücksichtigung
    let calculatedSum = 0;
    let nepSum = 0;
    
    const updatedPositions = positions.map(pos => {
      if (!pos.isNEP) {
        calculatedSum += parseFloat(pos.totalPrice) || 0;
      } else {
        nepSum += parseFloat(pos.totalPrice) || 0;
      }
      return pos;
    });
    
    // Update mit neuen Daten
    const updatedContent = {
      ...existingContent,
      positions: updatedPositions,
      totalSum: calculatedSum,
      nepSum: nepSum
    };
    
    // Speichere in DB
    await query(
      'UPDATE lvs SET content = $1, updated_at = NOW() WHERE project_id = $2 AND trade_id = $3',
      [JSON.stringify(updatedContent), projectId, tradeId]
    );
    
    res.json({ ok: true });
    
  } catch (err) {
    console.error('Update LV failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// Export LV with or without prices
app.get('/api/projects/:projectId/trades/:tradeId/lv/export', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { withPrices } = req.query;
    
    const result = await query(
      `SELECT l.content, t.name as trade_name, t.code as trade_code, p.description as project_description
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id
       JOIN projects p ON p.id = l.project_id
       WHERE l.project_id = $1 AND l.trade_id = $2`,
      [projectId, tradeId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }
    
    const { content, trade_name, trade_code, project_description } = result.rows[0];
    const lv = typeof content === 'string' ? JSON.parse(content) : content;
    
    if (withPrices === 'false') {
      lv.positions = lv.positions.map(pos => ({
        ...pos,
        unitPrice: '________',
        totalPrice: '________'
      }));
      lv.exportType = 'Angebotsanfrage';
      lv.note = 'Bitte tragen Sie Ihre Preise in die markierten Felder ein.';
    } else {
      lv.exportType = 'Kalkulation';
    }
    
    res.json({
      ok: true,
      tradeName: trade_name,
      tradeCode: trade_code,
      projectDescription: project_description,
      withPrices: withPrices !== 'false',
      lv
    });
    
  } catch (err) {
    console.error('Export LV failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// Generate PDF for LV
app.get('/api/projects/:projectId/trades/:tradeId/lv.pdf', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { withPrices } = req.query;
    
    const result = await query(
      `SELECT l.content, t.name as trade_name, t.code as trade_code, p.description as project_description
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id
       JOIN projects p ON p.id = l.project_id
       WHERE l.project_id = $1 AND l.trade_id = $2`,
      [projectId, tradeId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }
    
    const { content, trade_name, trade_code, project_description } = result.rows[0];
    const lv = typeof content === 'string' ? JSON.parse(content) : content;
    
    const pdfBuffer = await generateLVPDF(
      lv,
      trade_name,
      trade_code,
      project_description,
      withPrices !== 'false'
    );
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="LV_${trade_code}_${withPrices !== 'false' ? 'mit' : 'ohne'}_Preise.pdf"`);
    res.send(pdfBuffer);
    
  } catch (err) {
    console.error('PDF generation failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// Generate complete PDF with all LVs for a project
app.get('/api/projects/:projectId/lv-complete.pdf', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { withPrices } = req.query;
    
    // Hole Projektdaten und alle LVs
    const projectResult = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    const project = projectResult.rows[0];
    
    const lvsResult = await query(
      `SELECT l.content, t.name as trade_name, t.code as trade_code
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id
       WHERE l.project_id = $1
       ORDER BY t.name`,
      [projectId]
    );
    
    if (lvsResult.rows.length === 0) {
      return res.status(404).json({ error: 'No LVs found for this project' });
    }
    
    // Erstelle komplettes PDF
    const pdfBuffer = await generateCompleteLVPDF(
      project,
      lvsResult.rows,
      withPrices !== 'false'
    );
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="Projekt_${projectId}_Komplett_LV_${withPrices !== 'false' ? 'mit' : 'ohne'}_Preise.pdf"`);
    res.send(pdfBuffer);
    
  } catch (err) {
    console.error('Complete PDF generation failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// Update LV (für Editierung im Frontend)
app.put('/api/projects/:projectId/trades/:tradeId/lv', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { positions } = req.body;
    
    // Hole aktuelles LV
    const currentLV = await query(
      'SELECT content FROM lvs WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (currentLV.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }
    
    let lv = typeof currentLV.rows[0].content === 'string' 
      ? JSON.parse(currentLV.rows[0].content) 
      : currentLV.rows[0].content;
    
    // Update Positionen
    lv.positions = positions;
    
    // Neuberechnung der Summe
    let totalSum = 0;
    lv.positions = lv.positions.map((pos, idx) => {
      // Stelle sicher dass Positionsnummer vorhanden ist
      if (!pos.pos) {
        pos.pos = `${idx + 1}.00`;
      }
      
      // Berechne Gesamtpreis wenn nötig
      if (pos.quantity && pos.unitPrice && !pos.totalPrice) {
        pos.totalPrice = Math.round(pos.quantity * pos.unitPrice * 100) / 100;
      }
      
      totalSum += pos.totalPrice || 0;
      return pos;
    });
    
    lv.totalSum = Math.round(totalSum * 100) / 100;
    lv.lastModified = new Date().toISOString();
    lv.modifiedBy = 'user';
    
    // Speichere aktualisiertes LV
    await query(
      `UPDATE lvs 
       SET content = $1, updated_at = NOW()
       WHERE project_id = $2 AND trade_id = $3`,
      [lv, projectId, tradeId]
    );
    
    res.json({ 
      ok: true, 
      message: 'LV erfolgreich aktualisiert',
      lv 
    });
    
  } catch (err) {
    console.error('Failed to update LV:', err);
    res.status(500).json({ error: err.message });
  }
});

// Einzelne Position hinzufügen
app.post('/api/projects/:projectId/trades/:tradeId/lv/position', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const newPosition = req.body;
    
    const currentLV = await query(
      'SELECT content FROM lvs WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (currentLV.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }
    
    let lv = typeof currentLV.rows[0].content === 'string' 
      ? JSON.parse(currentLV.rows[0].content) 
      : currentLV.rows[0].content;
    
    if (!lv.positions || !Array.isArray(lv.positions)) {
      lv.positions = [];
    }
    
    // Füge neue Position hinzu mit NEP-Unterstützung
    const nextPos = lv.positions.length + 1;
    const positionToAdd = {
      pos: newPosition.pos || `${nextPos}.00`,
      title: newPosition.title || 'Neue Position',
      description: newPosition.description || '',
      quantity: parseFloat(newPosition.quantity) || 1,
      unit: newPosition.unit || 'Stk',
      unitPrice: parseFloat(newPosition.unitPrice) || 0,
      totalPrice: 0,
      dataSource: 'manual',
      notes: 'Manuell hinzugefügt',
      isNEP: newPosition.isNEP || false  // NEU: NEP-Flag übernehmen
    };
    
    // Berechne totalPrice
    positionToAdd.totalPrice = Math.round(
      positionToAdd.quantity * positionToAdd.unitPrice * 100
    ) / 100;
    
    lv.positions.push(positionToAdd);
    
    // NEU: Neuberechnung mit NEP-Berücksichtigung
    let calculatedSum = 0;
    let nepSum = 0;
    
    lv.positions.forEach(pos => {
      if (pos.isNEP) {
        nepSum += pos.totalPrice || 0;
      } else {
        calculatedSum += pos.totalPrice || 0;
      }
    });
    
    lv.totalSum = Math.round(calculatedSum * 100) / 100;
    lv.nepSum = Math.round(nepSum * 100) / 100;
    
    lv.lastModified = new Date().toISOString();
    
    // Speichere aktualisiertes LV
    await query(
      `UPDATE lvs 
       SET content = $1, updated_at = NOW()
       WHERE project_id = $2 AND trade_id = $3`,
      [JSON.stringify(lv), projectId, tradeId]
    );
    
    res.json({ 
      ok: true,
      success: true,
      message: 'Position hinzugefügt',
      position: positionToAdd,
      totalSum: lv.totalSum,
      nepSum: lv.nepSum,  // NEU: NEP-Summe zurückgeben
      lv
    });
    
  } catch (err) {
    console.error('Failed to add position:', err);
    res.status(500).json({ error: err.message });
  }
});

// Position löschen
app.delete('/api/projects/:projectId/trades/:tradeId/lv/position/:positionId', async (req, res) => {
  try {
    const { projectId, tradeId, positionId } = req.params;
    
    const currentLV = await query(
      'SELECT content FROM lvs WHERE project_id = $1 AND trade_id = $2',
      [projectId, tradeId]
    );
    
    if (currentLV.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }
    
    let lv = typeof currentLV.rows[0].content === 'string' 
      ? JSON.parse(currentLV.rows[0].content) 
      : currentLV.rows[0].content;
    
    // Entferne Position
    lv.positions = lv.positions.filter(pos => pos.pos !== positionId);
    
    // Neuberechnung
    lv.totalSum = lv.positions.reduce((sum, pos) => sum + (pos.totalPrice || 0), 0);
    lv.lastModified = new Date().toISOString();
    
    // Nummeriere Positionen neu
    lv.positions = lv.positions.map((pos, idx) => {
      pos.pos = `${idx + 1}.00`;
      return pos;
    });
    
    await query(
      `UPDATE lvs 
       SET content = $1, updated_at = NOW()
       WHERE project_id = $2 AND trade_id = $3`,
      [lv, projectId, tradeId]
    );
    
    res.json({ 
      ok: true, 
      message: 'Position gelöscht',
      totalSum: lv.totalSum
    });
    
  } catch (err) {
    console.error('Failed to delete position:', err);
    res.status(500).json({ error: err.message });
  }
});

// Get project cost summary
app.get('/api/projects/:projectId/cost-summary', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const lvsResult = await query(
      `SELECT l.content, t.name as trade_name, t.code as trade_code
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id
       WHERE l.project_id = $1`,
      [projectId]
    );

    // Projekt-Daten laden (NEUER CODE)
    const projectResult = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    const project = projectResult.rows[0];    
    
    const summary = {
      trades: [],
      totalCost: 0,
      budget: project.budget,  // DIESE ZEILE HINZUFÜGEN
      pricesComplete: true,
      dataQuality: {
        measured: 0,
        estimated: 0,
        assumed: 0
      }
    };
    
    for (const row of lvsResult.rows) {
      const lv = typeof row.content === 'string' 
        ? JSON.parse(row.content) 
        : row.content;
      
      const tradeCost = parseFloat(lv.totalSum) || 
  (lv.positions || []).reduce((sum, pos) => 
    sum + (parseFloat(pos.totalPrice) || 0), 0
  );
      
      // Zähle Datenqualität
      if (lv.positions) {
        lv.positions.forEach(pos => {
          if (pos.dataSource === 'measured') summary.dataQuality.measured++;
          else if (pos.dataSource === 'estimated') summary.dataQuality.estimated++;
          else summary.dataQuality.assumed++;
        });
      }
      
      summary.trades.push({
  name: row.trade_name,
  code: row.trade_code,
  cost: parseFloat(tradeCost) || 0,
  hasPrice: tradeCost > 0,
  positionCount: lv.positions?.length || 0,
  confidence: lv.dataQuality?.confidence || 0.5
});

summary.totalCost = summary.totalCost + (parseFloat(tradeCost) || 0);
      
      if (tradeCost === 0) {
        summary.pricesComplete = false;
      }
    }
    
    // Berechne Gesamtdatenqualität
    const totalPositions = summary.dataQuality.measured + 
                          summary.dataQuality.estimated + 
                          summary.dataQuality.assumed;
    
    summary.dataQuality.confidence = totalPositions > 0
      ? (summary.dataQuality.measured / totalPositions)
      : 0;
    
    summary.additionalCosts = {
      planningCosts: summary.totalCost * 0.10,
      contingency: summary.totalCost * 0.05,
      vat: summary.totalCost * 0.19
    };
    
    summary.grandTotal = summary.totalCost + 
      summary.additionalCosts.planningCosts +
      summary.additionalCosts.contingency +
      summary.additionalCosts.vat;
    
    res.json({ ok: true, summary });
    
  } catch (err) {
    console.error('Cost summary failed:', err);
    res.status(500).json({ error: err.message });
  }
});

function formatCurrency(value) {
  return new Intl.NumberFormat('de-DE', {
    style: 'currency',
    currency: 'EUR'
  }).format(value || 0);
}

// Helper-Funktion für Gewerk-Beschreibungen
function getTradeDescription(tradeCode) {
  const descriptions = {
    'ABBR': 'Abbruch, Entkernung, Rückbau, Entsorgung',
    'ROH': 'Rohbau, Mauerarbeiten, Betonarbeiten, Fundamente',
    'GER': 'Gerüstbau, Arbeitsplattformen, Absturzsicherung',
    'ZIMM': 'Zimmererarbeiten, Gauben, Dachstuhl, Holzkonstruktionen, Carports, Holzrahmenbau',
    'DACH': 'Dachdeckerarbeiten, Abdichtungen, Terrassen, Flachdach',
    'FEN': 'Fenster, Außentüren, Haustüren, Montage, Rollläden',
    'FASS': 'Fassadenbau, Fassadensanierung, WDVS',
    'AUSS': 'Außenanlagen, Garten- und Landschaftsbau, Pflasterarbeiten',
    'ELEKT': 'Elektroinstallation, Schalter, Steckdosen, Beleuchtung',
    'SAN': 'Sanitärinstallation, Armaturen, Rohre, Bad, WC',
    'HEI': 'Heizungsinstallation, Heizkörper, Thermostate, Warmwasser',
    'KLIMA': 'Lüftung, Klimatechnik, Kühlung, Be- und Entlüftung',
    'PV': 'Photovoltaik, Solarmodule, Wechselrichter, Batteriespeicher',
    'ESTR': 'Estricharbeiten, Bodenaufbau, Dämmung, Fußbodenheizung',
    'TRO': 'Trockenbau, Wände, Decken, Dämmung, Schallschutz',
    'FLI': 'Fliesen, Plattenarbeiten, Verfugung, Abdichtung',
    'TIS': 'Innentüren, Wohnungseingangstüren, Innenausbau, Einbaumöbel, Holzarbeiten',
    'BOD': 'Bodenbeläge, Parkett, Laminat, Vinyl, Teppich, PVC',
    'MAL': 'Malerarbeiten, Lackieren, Tapezieren, Spachteln',
    'SCHL': 'Schlosserarbeiten, Metallbau, Geländer, Treppengeländer, Stahlkonstruktionen',
    'INT': 'Allgemeine Projektaufnahme, Bestandserfassung'
  };
  return descriptions[tradeCode] || 'Allgemeine Bauarbeiten';
}

// Vereinfachte Budget-Übersicht - zeigt nur Zusammenfassung
app.post('/api/projects/:projectId/budget-optimization', async (req, res) => {
  console.log('[BUDGET-OVERVIEW] Generating optimization overview for project:', req.params.projectId);
  
  try {
    const { projectId } = req.params;
    const { currentTotal, targetBudget, lvBreakdown } = req.body;
    
    const overspend = currentTotal - targetBudget;
    const percentOver = ((overspend / targetBudget) * 100).toFixed(1);
    
    // Einfache Übersicht ohne Details
    const overview = {
      summary: {
        currentTotal,
        targetBudget,
        overspend,
        percentOver,
        message: `Budget um ${formatCurrency(overspend)} (${percentOver}%) überschritten`
      },
      tradesPotential: lvBreakdown.map(lv => {
        // Grobe Schätzung des Einsparpotenzials pro Gewerk (10-20% je nach Gewerk)
        const potentialPercent = getTypicalSavingPercent(lv.tradeCode);
        const potentialAmount = Math.round(lv.total * potentialPercent / 100);
        
        return {
          tradeCode: lv.tradeCode,
          tradeName: lv.tradeName,
          currentCost: lv.total,
          estimatedPotential: potentialAmount,
          potentialPercent,
          hint: getSavingHint(lv.tradeCode)
        };
      }).sort((a, b) => b.estimatedPotential - a.estimatedPotential),
      totalEstimatedPotential: 0,
      recommendation: ''
    };
    
    // Berechne Gesamtpotenzial
    overview.totalEstimatedPotential = overview.tradesPotential.reduce(
      (sum, t) => sum + t.estimatedPotential, 0
    );
    
    // Empfehlung
    if (overview.totalEstimatedPotential >= overspend) {
      overview.recommendation = 'Die Budgetüberschreitung kann durch gezielte Optimierungen ausgeglichen werden.';
    } else {
      overview.recommendation = 'Eine vollständige Kompensation der Überschreitung erfordert größere Einschnitte.';
    }
    
    res.json(overview);
    
  } catch (err) {
    console.error('Overview generation failed:', err);
    res.status(500).json({ error: 'Fehler bei der Übersichtserstellung' });
  }
});

// Detaillierte Analyse für einzelnes Gewerk
app.post('/api/projects/:projectId/trades/:tradeId/optimize', async (req, res) => {
  console.log('[TRADE-OPTIMIZE] Detailed analysis for trade:', req.params.tradeId);
  
  try {
    const { projectId, tradeId } = req.params;
    const { targetSaving } = req.body;
    
    // Lade LV mit Positionen
    const lvData = await query(
      `SELECT l.*, t.name as trade_name, t.code as trade_code 
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id 
       WHERE l.project_id = $1 AND l.trade_id = $2`,
      [projectId, tradeId]
    );
    
    if (!lvData.rows[0]) {
      return res.status(404).json({ error: 'LV nicht gefunden' });
    }
    
    const lv = lvData.rows[0];
    
    // KORREKTUR: Sichere Verarbeitung des content Feldes
    let lvContent;
    if (typeof lv.content === 'string') {
      try {
        lvContent = JSON.parse(lv.content);
      } catch (parseError) {
        console.error('[TRADE-OPTIMIZE] Failed to parse LV content as string:', parseError);
        return res.status(500).json({ error: 'LV-Daten fehlerhaft' });
      }
    } else if (typeof lv.content === 'object' && lv.content !== null) {
      // Ist bereits ein Objekt
      lvContent = lv.content;
    } else {
      console.error('[TRADE-OPTIMIZE] Invalid LV content type:', typeof lv.content);
      return res.status(500).json({ error: 'LV-Daten ungültig' });
    }
    
    // Validiere dass positions existiert
    if (!lvContent.positions || !Array.isArray(lvContent.positions)) {
      console.error('[TRADE-OPTIMIZE] No positions found in LV');
      return res.status(400).json({ error: 'Keine Positionen im LV gefunden' });
    }
    
    // Lade Projekt-Kontext
    const projectData = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    // Lade ursprüngliche Antworten
    const answers = await query(
      `SELECT q.text as question, a.answer_text as answer 
       FROM answers a
       JOIN questions q ON q.question_id = a.question_id 
         AND q.trade_id = a.trade_id
       WHERE a.project_id = $1 AND a.trade_id = $2`,
      [projectId, tradeId]
    );
    
    // System-Prompt für Claude
    const systemPrompt = `Du bist ein erfahrener Baukostenoptimierer spezialisiert auf ${lv.trade_name}.

AUFGABE: Analysiere jede Position des LVs und finde KONKRETE, UMSETZBARE Einsparmöglichkeiten.

WICHTIGE REGELN:
1. Beziehe dich IMMER auf die konkrete Position (Pos-Nr und Titel)
2. Unterscheide klar zwischen:
   - MATERIAL: Günstigere Alternative bei gleicher Funktion
   - EIGENLEISTUNG: Was kann der Bauherr selbst machen
   - VERZICHT: Was ist wirklich verzichtbar ohne Funktionsverlust
   - REDUZIERUNG: Weniger Menge/Umfang
   - VERSCHIEBUNG: Kann später gemacht werden

3. Bewerte jede Alternative nach:
   - Einsparpotenzial in Euro und Prozent
   - Qualitätsauswirkung (keine/gering/mittel/hoch)
   - Machbarkeit für Laien bei Eigenleistung
   - Risiken und Nachteile

GEWERK-SPEZIFISCHE OPTIMIERUNGEN für ${lv.trade_code}:
${getDetailedTradeRules(lv.trade_code)}

AUSGABE als JSON:
{
  "optimizations": [
    {
      "positionRef": "Exakte Pos-Nr aus LV",
      "originalPosition": "Exakter Titel der Position",
      "originalCost": Zahl,
      "category": "material|eigenleistung|verzicht|reduzierung|verschiebung",
      "measure": "Kurze prägnante Maßnahme",
      "alternativeDescription": "Detaillierte Beschreibung der Alternative mit konkreten Produkten/Methoden",
      "savingAmount": Zahl (realistisch!),
      "savingPercent": Zahl,
      "qualityImpact": "keine|gering|mittel|hoch",
      "feasibility": "einfach|mittel|schwer",
      "timeNeeded": "Zeitaufwand in Stunden bei Eigenleistung",
      "risks": "Konkrete Risiken und Nachteile",
      "recommendation": "empfohlen|bedingt|nur_notfall",
      "prerequisites": "Was wird benötigt (Werkzeug, Kenntnisse)"
    }
  ],
  "summary": {
    "totalPossibleSaving": Zahl,
    "recommendedSaving": Zahl (nur empfohlene Maßnahmen),
    "qualityPreservedSaving": Zahl (ohne/geringe Qualitätseinbuße),
    "eigenleistungSaving": Zahl (nur Eigenleistung),
    "topThree": ["Die drei wirkungsvollsten Maßnahmen"]
  }
}

WICHTIG: Sei REALISTISCH! Keine Fantasie-Einsparungen!

KRITISCH: Antworte NUR mit validem JSON ohne Markdown-Codeblocks!
Gib das JSON direkt aus, keine zusätzliche Formatierung.`;
    
    const userPrompt = `LEISTUNGSVERZEICHNIS ${lv.trade_name}:

${lvContent.positions.map((pos, idx) => 
  `Position ${pos.pos}:
   Titel: ${pos.title}
   Beschreibung: ${pos.description || 'Keine Details'}
   Menge: ${pos.quantity} ${pos.unit}
   Einzelpreis: ${pos.unitPrice}€
   Gesamtpreis: ${pos.totalPrice}€
   ${pos.isNEP ? '(NEP - Eventualposition)' : ''}
   ---`
).join('\n')}

GESAMTSUMME LV: ${lvContent.totalSum}€

PROJEKT-KONTEXT:
Kategorie: ${projectData.rows[0]?.category || 'Sanierung'}
${answers.rows.map(a => `- ${a.question}: ${a.answer}`).join('\n')}

${targetSaving ? `ZIEL-EINSPARUNG: ${targetSaving}€` : 'ZIEL: Maximale sinnvolle Einsparung ohne große Qualitätsverluste'}

Analysiere JEDE Position und finde konkrete Einsparmöglichkeiten!`;

    // Claude API Call
const anthropic = new Anthropic({
  apiKey: process.env.ANTHROPIC_API_KEY
});

console.log('[TRADE-OPTIMIZE] Calling Claude for detailed analysis...');
const response = await anthropic.messages.create({
  model: 'claude-sonnet-4-5-20250929',
  max_tokens: 16000,          
  temperature: 0.3,
  system: systemPrompt,      
  messages: [
    { 
      role: 'user', 
      content: userPrompt    // ← Nur User-Content!
    }
  ]
});

let optimizations;
try {
  let responseText = response.content[0].text.trim();
  
  // Einfache Bereinigung (reicht jetzt)
  responseText = responseText
    .replace(/^```json\s*\n?/, '')
    .replace(/^```\s*\n?/, '')
    .replace(/\n?```\s*$/, '')
    .trim();
  
  console.log('[TRADE-OPTIMIZE] Response length:', responseText.length);
  
  optimizations = JSON.parse(responseText);
  
} catch (parseError) {
  console.error('[TRADE-OPTIMIZE] Parse error:', parseError.message);
  console.error('[TRADE-OPTIMIZE] Response snippet:', response.content[0].text.substring(0, 500));
  
  return res.status(500).json({ 
    error: 'Fehler bei der Analyse', 
    details: parseError.message 
  });
}
    
    // Validierung und Bereinigung
    if (optimizations.optimizations) {
      optimizations.optimizations = optimizations.optimizations
        .filter(opt => opt.savingAmount > 50) // Mindestens 50€ Ersparnis
        .map(opt => ({
          ...opt,
          savingAmount: Math.round(opt.savingAmount),
          savingPercent: Math.round(opt.savingPercent * 10) / 10
        }));
    }
    
    // Speichere in DB
    await query(
      `INSERT INTO trade_optimizations (project_id, trade_id, suggestions, created_at)
       VALUES ($1, $2, $3, NOW())
       ON CONFLICT (project_id, trade_id) 
       DO UPDATE SET suggestions = $3, created_at = NOW()`,
      [projectId, tradeId, JSON.stringify(optimizations)]
    );
    
    console.log(`[TRADE-OPTIMIZE] Found ${optimizations.optimizations?.length || 0} optimizations`);
    res.json(optimizations);
    
  } catch (err) {
    console.error('[TRADE-OPTIMIZE] Analysis failed:', err);
    res.status(500).json({ 
      error: 'Optimierung fehlgeschlagen',
      details: err.message 
    });
  }
});

// Helper-Funktionen für die Übersicht
function getTypicalSavingPercent(tradeCode) {
  const typicalSavings = {
    'FEN': 25,    // Fenster: Material-Alternativen
    'TIS': 20,    // Türen: Material-Alternativen
    'DACH': 18,   // Dach: Materialwahl
    'MAL': 35,    // Maler: Hohe Eigenleistung möglich
    'FLI': 25,    // Fliesen: Material + Eigenleistung
    'SAN': 20,    // Sanitär: Armaturen-Alternativen
    'HEI': 15,    // Heizung: Optimierung möglich
    'ELEKT': 18,  // Elektro: Umfang reduzierbar
    'BOD': 22,    // Boden: Material-Alternativen
    'FASS': 15,   // Fassade: Begrenzt
    'GER': 5,     // Gerüst: Kaum Spielraum
    'ROH': 8,     // Rohbau: Wenig Spielraum
    'ZIMM': 12,   // Zimmerer: Begrenzt
    'ESTR': 10    // Estrich: Begrenzt
  };
  return typicalSavings[tradeCode] || 15;
}

function getSavingHint(tradeCode) {
  const hints = {
    'FEN': 'Materialwahl und Anzahl prüfen',
    'TIS': 'Türqualität optimieren',
    'DACH': 'Ziegel-Alternative prüfen',
    'MAL': 'Hohe Eigenleistung möglich',
    'FLI': 'Material + Eigenleistung',
    'SAN': 'Armaturenwahl überdenken',
    'HEI': 'Heizkörper optimieren',
    'ELEKT': 'Ausstattung reduzieren',
    'BOD': 'Günstigere Beläge wählen',
    'FASS': 'Dämmstärke prüfen',
    'GER': 'Standzeit optimieren',
    'ROH': 'Wenig Einsparpotenzial',
    'ZIMM': 'Konstruktion vereinfachen',
    'ESTR': 'Standardausführung wählen'
  };
  return hints[tradeCode] || 'Detailanalyse empfohlen';
}

// Erweiterte Helper-Funktion mit detaillierten Regeln
function getDetailedTradeRules(tradeCode) {
  const rules = {
    'FEN': `
    MATERIAL-ALTERNATIVEN:
    - Kunststoff statt Holz: 30-40% günstiger, pflegeleichter
    - Kunststoff statt Holz-Alu: 50% günstiger
    - 2-fach statt 3-fach Verglasung: 15% günstiger (Achtung: EnEV prüfen!)
    - Standard-Beschläge statt RC2: 200-300€ pro Fenster
    - Standardmaße statt Sondermaße: 20% günstiger
    
    EIGENLEISTUNG:
    - Demontage Altfenster: 50-80€ pro Fenster
    - Entsorgung selbst: 30€ pro Fenster
    - Fensterbank-Montage innen: 50€ pro Fenster
    
    VERZICHT/REDUZIERUNG:
    - Einzelne Fenster weglassen/später
    - Festverglasungen statt Flügel wo möglich
    - Rollläden weglassen: 400-600€ pro Fenster`,
    
    'DACH': `
    MATERIAL-ALTERNATIVEN:
    - Betondachsteine statt Tonziegel: 15-20€/m² günstiger
    - Standardziegel statt Premiumziegel: 20-40€/m² Unterschied
    - PVC-Dachrinnen statt Zink: 60% günstiger
    - Standarddämmung statt Premium: 10-15€/m² 
    
    EIGENLEISTUNG:
    - Dämmung verlegen (nur Geschossdecke!): 25-30€/m²
    - Alte Ziegel abdecken: 15€/m²
    - Entrümpelung Dachboden: 200-500€
    
    VERZICHT:
    - Dachfenster reduzieren: 1.500-3.000€ pro Stück
    - Gauben später: 8.000-15.000€ pro Gaube
    - Schneefanggitter nur wo nötig`,
    
    'SAN': `
    MATERIAL-ALTERNATIVEN:
    - Standard-Armaturen statt Grohe/Hansgrohe: 50-70% günstiger
    - Acryl-Duschwanne statt Mineralguss: 200-400€ Differenz
    - Standard-WC statt Dusch-WC: 2.000-3.000€
    - Aufputz-Spülkasten wo möglich: 150€ günstiger
    
    EIGENLEISTUNG:
    - Demontage alte Sanitärobjekte: 100% Arbeitskosten
    - Fliesenspiegel selbst: 50€/m²
    - Silikonfugen ziehen: 15€/m
    
    REDUZIERUNG:
    - Einhebelmischer statt Thermostat: 100-200€
    - Duschwanne statt bodengleich: 800-1.500€
    - Kleinerer Waschtisch: 200-400€`,
    
    'MAL': `
    EIGENLEISTUNG (SEHR HOCH!):
    - Komplette Malerarbeiten selbst: 25-40€/m² sparen
    - Tapeten entfernen: 8-12€/m²
    - Grundierung: 5€/m²
    - Streichen: 15-20€/m²
    - Spachteln Q2: 10€/m²
    
    MATERIAL:
    - Dispersionsfarbe statt Silikat: 5€/m²
    - Raufaser statt Vlies: 8€/m²
    - Standardfarbe statt Öko-Premium: 30-50%
    
    REDUZIERUNG:
    - Q2 statt Q3 Qualität: 5-8€/m²
    - Nur Wände, Decken später
    - Nebenräume einfacher`,

    'FASS': `
MATERIAL-ALTERNATIVEN:
- EPS statt Mineralwolle WDVS: 20-30€/m² günstiger
- Dünnere Dämmstärke (EnEV-Minimum): 15-25€/m² sparen
- Kunstharzputz statt Silikatputz: 8-12€/m²
- Standardfarbe statt Silikatfarbe: 5-8€/m²
- Verzicht auf Sockelprofile Alu: 15€/m

EIGENLEISTUNG:
- Alte Fassade reinigen: 10€/m²
- Grundierung auftragen: 8€/m²
- Kleinere Ausbesserungen: 20€/m²

REDUZIERUNG:
- Nur Wetterseiten dämmen: 40% sparen
- Sockeldämmung weglassen: 80-120€/m
- Teilflächen später: flexibel`,

'ELEKT': `
MATERIAL-ALTERNATIVEN:
- Standard-Schalterserie (Busch-Jaeger) statt Premium: 15-25€ pro Stelle
- Aufputz in Keller/Garage: 30% günstiger
- LED-Einbaustrahler Standard statt Premium: 20-40€ pro Stück
- Normale Steckdosen statt USB-Kombi: 30€ pro Stück

EIGENLEISTUNG:
- Schlitze stemmen: 15-20€/m
- Dosen setzen: 10€ pro Dose
- Kabel einziehen (mit Elektriker): 8€/m
- Alte Installation demontieren: 100% Arbeitskosten

REDUZIERUNG:
- Mindestausstattung statt Komfort: 2.000-4.000€
- Weniger Steckdosen (nur DIN-Minimum): 30%
- Smart-Home später nachrüsten: 3.000-5.000€`,

'FLI': `
MATERIAL-ALTERNATIVEN:
- Baumarkt-Fliesen statt Markenfliesen: 20-60€/m²
- Feinsteinzeug statt Naturstein: 40-80€/m²
- Großformate (weniger Fugen): 10€/m² Verlegung sparen
- Standardformat 30x60 statt Mosaik: 30€/m²

EIGENLEISTUNG:
- Alte Fliesen entfernen: 15-25€/m²
- Grundierung/Ausgleich: 10€/m²
- Sockelfliesen selbst: 15€/m
- Verfugen: 8-10€/m²

REDUZIERUNG:
- Nur Nassbereiche fliesen: 50% sparen
- Teilverfliesung statt raumhoch: 30%
- Einfaches Verlegemuster: 10€/m²`,

'TIS': `
MATERIAL-ALTERNATIVEN:
- CPL-Türen statt Echtholz: 200-400€ pro Tür
- Röhrenspan statt Vollspan: 50-80€ pro Tür
- Standard-Zarge statt Blockzarge: 80-150€
- Buntbart statt Profilzylinder: 40€ pro Tür
- Standardmaße statt Sondermaße: 30%

EIGENLEISTUNG:
- Demontage alte Türen: 50€ pro Tür
- Türblätter einhängen (vorbereitet): 30€ pro Tür
- Beschläge montieren: 20€ pro Tür

VERZICHT:
- Schiebetüren vermeiden: 800-1.500€ Mehrpreis
- Glastüren reduzieren: 300-500€ Mehrpreis
- Schallschutz nur wo nötig: 150€ pro Tür`,

'SCHL': `
MATERIAL-ALTERNATIVEN:
- Stahl verzinkt statt Edelstahl: 40% günstiger
- Standardprofile statt Sonderanfertigung: 30%
- Gitterrost statt Lochblech: 25% günstiger
- Pulverbeschichtung statt feuerverzinkt: 20%

EIGENLEISTUNG:
- Demontage Altgeländer: 30€/m
- Grundierung Handlauf: 10€/m
- Montage vorbereiten: 20€/m

REDUZIERUNG:
- Einfache Füllung statt aufwendig: 50€/m
- Standardhöhe 90cm statt 110cm: 20%
- Handlauf nur einseitig: 40€/m`,

'TRO': `
MATERIAL-ALTERNATIVEN:
- Standardplatten 12,5mm statt Spezial: 3-5€/m²
- Metallständer Standard statt verstärkt: 5€/m²
- Mineralwolle statt Spezial-Dämmung: 8€/m²
- Q2 statt Q3 Verspachtelung: 5€/m²

EIGENLEISTUNG:
- Alte Verkleidungen entfernen: 10€/m²
- Grundierung auftragen: 5€/m²
- Dämmung einlegen: 8€/m²
- Erste Spachtelgänge: 10€/m²

REDUZIERUNG:
- Einfache statt doppelte Beplankung: 15€/m²
- Ohne Dämmung wo nicht nötig: 10€/m²
- Direktbeplankung statt Ständerwerk: 20€/m²`,

'PV': `
MATERIAL-ALTERNATIVEN:
- Standard-Module statt Premium: 50-80€/kWp
- String-Wechselrichter statt Optimizer: 100€/kWp
- Standardmontage statt Indach: 200€/kWp
- Einfacher Zählerschrank: 500-800€

EIGENLEISTUNG:
- Kabelwege vorbereiten: 20€/m
- DC-Verkabelung unterstützen: 15€/m
- Dokumentation erstellen: 200€

REDUZIERUNG:
- Kleinere Anlage (nur Eigenverbrauch): 30%
- Speicher später nachrüsten: 6.000-10.000€
- Nur Südseite belegen: 20-40%`,

'KLIMA': `
MATERIAL-ALTERNATIVEN:
- Split-Geräte statt zentrale Anlage: 40% günstiger
- Standard-Geräte statt Premium: 30%
- Einzelraumgeräte statt Multi-Split: 25%
- Kanalgeräte statt Kassetten: 20%

EIGENLEISTUNG:
- Wanddurchbrüche vorbereiten: 100€/Stück
- Kabelkanäle verlegen: 15€/m
- Kondensat-Ableitung vorbereiten: 50€/Gerät

REDUZIERUNG:
- Nur Haupträume klimatisieren: 50%
- Mobile Geräte für Übergang: 60% günstiger
- Kleinere Leistung wählen: 20%`,

'HEI': `
MATERIAL-ALTERNATIVEN:
- Heizkörper Typ 11 statt 22 (wo möglich): 30%
- Standard-Thermostate statt Smart: 50€/Stück
- Stahl-Heizkörper statt Design: 40%
- Standard-Pumpe statt Hocheffizienz: 200€

EIGENLEISTUNG:
- Alte Heizkörper demontieren: 50€/Stück
- Heizkörper grundieren: 30€/Stück
- Dämmung Heizungsleitungen: 10€/m

REDUZIERUNG:
- FBH nur in Bad: 2.000-3.000€ sparen
- Anzahl Heizkreise reduzieren: 300€/Kreis
- Pufferspeicher kleiner: 500-1.000€`,

'BOD': `
MATERIAL-ALTERNATIVEN:
- Laminat statt Parkett: 30-50€/m²
- Vinyl statt Echtholz: 40-60€/m²
- 2-Schicht statt 3-Schicht Parkett: 20-30€/m²
- Click statt verklebt: 15€/m² Verlegung

EIGENLEISTUNG:
- Alte Beläge entfernen: 10-15€/m²
- Ausgleichsmasse gießen: 10€/m²
- Sockelleisten montieren: 8€/m
- Click-Laminat selbst verlegen: 25€/m²

REDUZIERUNG:
- Teppich in Schlafzimmern belassen: 30%
- Nur Haupträume neu: 40%
- Standardformate statt Sonderwünsche: 20%`,

'AUSS': `
MATERIAL-ALTERNATIVEN:
- Betonstein statt Naturstein: 40-60€/m²
- Kies statt Pflaster in Nebenflächen: 30€/m²
- Standard-Zaun statt Sichtschutz: 50%
- Rasengitter statt Pflaster: 25€/m²

EIGENLEISTUNG:
- Aushub Terrasse: 25€/m³
- Splittbett verteilen: 15€/m²
- Pflaster verlegen (einfach): 30€/m²
- Zaun streichen: 10€/m²

REDUZIERUNG:
- Kleinere Terrasse: flexibel
- Carport statt Garage: 10.000€
- Wege schmaler anlegen: 30%`,

'ABBR': `
EIGENLEISTUNG (SEHR HOCH!):
- Nicht-tragende Wände selbst: 30-40€/m²
- Bodenbeläge entfernen: 15€/m²
- Tapeten/Putz abschlagen: 10€/m²
- Sanitär demontieren: 80€/Objekt
- Entsorgung Container selbst: 50%

OPTIMIERUNG:
- Wertstoffe separat: 20€/m³
- Verkauf Altmaterial: variabel

REDUZIERUNG:
- Nur notwendige Bereiche: variabel
- Teilentkernung: 30-50%
- Erhaltenswertes stehen lassen: flexibel`,

'ROH': `
MATERIAL-ALTERNATIVEN:
- Poroton statt KS-Stein: 10-15€/m²
- Fertigteile wo möglich: 20% Arbeitszeit
- Standardbeton statt Spezialmix: 20€/m³
- Filigrandecke statt Ortbeton: 15%`,    
   
    'DEFAULT': `
    ALLGEMEINE OPTIMIERUNGEN:
    - Standardprodukte statt Premium
    - Eigenleistung bei Vorarbeiten
    - Teilausführung/Reduzierung
    - Verschiebung auf später`
  };
  
  return rules[tradeCode] || rules['DEFAULT'];
}

// Route zum Anwenden ausgewählter Optimierungen auf das LV
app.post('/api/projects/:projectId/trades/:tradeId/apply-optimizations', async (req, res) => {
  console.log('[APPLY-OPT] Starting optimization application for trade:', req.params.tradeId);
  
  try {
    const { projectId, tradeId } = req.params;
    const { optimizations } = req.body;
    
    if (!optimizations || !Array.isArray(optimizations) || optimizations.length === 0) {
      return res.status(400).json({ error: 'Keine Optimierungen ausgewählt' });
    }
    
    // Lade aktuelles LV
    const lvData = await query(
      `SELECT * FROM lvs WHERE project_id = $1 AND trade_id = $2`,
      [projectId, tradeId]
    );
    
    if (!lvData.rows[0]) {
      return res.status(404).json({ error: 'LV nicht gefunden' });
    }
    
    const lv = lvData.rows[0];
    
    // Parse LV content
    let lvContent;
    if (typeof lv.content === 'string') {
      lvContent = JSON.parse(lv.content);
    } else {
      lvContent = lv.content;
    }
    
    if (!lvContent.positions || !Array.isArray(lvContent.positions)) {
      return res.status(400).json({ error: 'Keine Positionen im LV gefunden' });
    }
    
    console.log(`[APPLY-OPT] Applying ${optimizations.length} optimizations to ${lvContent.positions.length} positions`);
    
    // Kopie der Positionen für Bearbeitung
    let updatedPositions = [...lvContent.positions];
    let appliedCount = 0;
    let totalSavings = 0;
    
    // Verarbeite jede Optimierung
    for (const opt of optimizations) {
      console.log(`[APPLY-OPT] Processing optimization for position ${opt.positionRef}`);
      
      // Finde die betroffene Position
      const posIndex = updatedPositions.findIndex(pos => 
        pos.pos === opt.positionRef || 
        pos.title?.toLowerCase().includes(opt.originalPosition?.toLowerCase().substring(0, 20))
      );
      
      if (posIndex === -1) {
        console.warn(`[APPLY-OPT] Position not found: ${opt.positionRef}`);
        continue;
      }
      
      const position = updatedPositions[posIndex];
      const originalPrice = position.totalPrice || (position.quantity * position.unitPrice);
      
      // Wende Optimierung basierend auf Kategorie an
      switch (opt.category) {
        case 'material':
        // Material-Optimierung: Titel und Beschreibung anpassen, Preis reduzieren
        const cleanTitleMat = position.title.replace(/\s*\(optimiert\)\s*/g, '').split('Ursprünglich:')[0].trim();
        const cleanDescMat = (position.description || '').replace(/Ursprünglich:.*$/s, '').trim();
  
        position.title = cleanTitleMat + ' (optimiert)';
        position.description = `${opt.alternativeDescription}\n\nUrsprünglich: ${cleanDescMat}`;
        position.unitPrice = Math.round((position.unitPrice * (100 - opt.savingPercent) / 100) * 100) / 100;
        position.totalPrice = Math.round(position.quantity * position.unitPrice * 100) / 100;
        appliedCount++;
        break;
          
        case 'eigenleistung':
  // Eigenleistung: Position als Eigenleistung markieren, Arbeitskosten abziehen
  const cleanTitleEigen = position.title.replace(/\s*\(Eigenleistung\)\s*/g, '').split('EIGENLEISTUNG:')[0].trim();
  const cleanDescEigen = (position.description || '').replace(/EIGENLEISTUNG:.*?(?=\n\n|$)/s, '').trim();
  
  position.title = cleanTitleEigen + ' (Eigenleistung)';
  position.description = `EIGENLEISTUNG: ${opt.measure}\n\n${cleanDescEigen}`;
  // Reduziere nur Arbeitskosten (ca. 60-80% bei Eigenleistung)
  const laborReduction = opt.savingPercent || 70;
  position.unitPrice = Math.round((position.unitPrice * (100 - laborReduction) / 100) * 100) / 100;
  position.totalPrice = Math.round(position.quantity * position.unitPrice * 100) / 100;
  position.isEigenleistung = true;
  appliedCount++;
  break;
          
        case 'verzicht':
  // Verzicht: Position auf 0 setzen oder als NEP markieren
  const cleanTitleVerzicht = position.title.replace(/\s*\(ENTFÄLLT\)\s*/g, '').split('POSITION ENTFÄLLT:')[0].trim();
  const cleanDescVerzicht = (position.description || '').replace(/POSITION ENTFÄLLT:.*?(?=\n\n|$)/s, '').trim();
  
  position.title = cleanTitleVerzicht + ' (ENTFÄLLT)';
  position.description = `POSITION ENTFÄLLT: ${opt.measure}\n\n${cleanDescVerzicht}`;
  position.quantity = 0;
  position.totalPrice = 0;
  position.isNEP = true;
  appliedCount++;
  break;
          
        case 'reduzierung':
  // Reduzierung: Menge oder Umfang reduzieren
  const reductionFactor = (100 - opt.savingPercent) / 100;
  const cleanTitleReduz = position.title.replace(/\s*\(reduziert\)\s*/g, '').split('REDUZIERT:')[0].trim();
  const cleanDescReduz = (position.description || '').replace(/REDUZIERT:.*?(?=\n\n|$)/s, '').trim();
  
  position.title = cleanTitleReduz + ' (reduziert)';
  position.description = `REDUZIERT: ${opt.measure}\n\n${cleanDescReduz}`;
  
  // Entscheide ob Menge oder Preis reduziert wird
  if (opt.measure.toLowerCase().includes('menge') || 
      opt.measure.toLowerCase().includes('weniger') ||
      opt.measure.toLowerCase().includes('fläche')) {
    // Mengenreduzierung
    position.quantity = Math.round(position.quantity * reductionFactor * 100) / 100;
  } else {
    // Preisreduzierung (z.B. einfachere Ausführung)
    position.unitPrice = Math.round(position.unitPrice * reductionFactor * 100) / 100;
  }
  position.totalPrice = Math.round(position.quantity * position.unitPrice * 100) / 100;
  appliedCount++;
  break;
          
        case 'verschiebung':
  // Verschiebung: Als Eventualposition markieren
  const cleanTitleVersch = position.title.replace(/\s*\(Optional - spätere Ausführung\)\s*/g, '').split('OPTIONAL/SPÄTER:')[0].trim();
  const cleanDescVersch = (position.description || '').replace(/OPTIONAL\/SPÄTER:.*?(?=\n\n|$)/s, '').trim();
  
  position.title = cleanTitleVersch + ' (Optional - spätere Ausführung)';
  position.description = `OPTIONAL/SPÄTER: ${opt.measure}\n\n${cleanDescVersch}`;
  position.isNEP = true;
  appliedCount++;
  break;
          
        default:
          console.warn(`[APPLY-OPT] Unknown optimization category: ${opt.category}`);
      }
      
      // Berechne tatsächliche Ersparnis
      const newPrice = position.totalPrice || 0;
      const actualSaving = originalPrice - newPrice;
      totalSavings += actualSaving;
      
      console.log(`[APPLY-OPT] Applied ${opt.category} to position ${posIndex}: saved ${actualSaving}€`);
    }
    
    // Berechne neue Gesamtsumme
    const newTotalSum = updatedPositions.reduce((sum, pos) => {
      if (!pos.isNEP) {
        return sum + (pos.totalPrice || 0);
      }
      return sum;
    }, 0);
    
    const nepSum = updatedPositions.reduce((sum, pos) => {
      if (pos.isNEP) {
        return sum + (pos.totalPrice || 0);
      }
      return sum;
    }, 0);
    
    // Aktualisiere LV-Content
    lvContent.positions = updatedPositions;
    lvContent.totalSum = Math.round(newTotalSum * 100) / 100;
    lvContent.nepSum = Math.round(nepSum * 100) / 100;
    lvContent.optimizationsApplied = appliedCount;
    lvContent.totalSavings = Math.round(totalSavings * 100) / 100;
    lvContent.lastOptimized = new Date().toISOString();
    
    // Füge Optimierungs-Historie hinzu
    if (!lvContent.optimizationHistory) {
      lvContent.optimizationHistory = [];
    }
    lvContent.optimizationHistory.push({
      date: new Date().toISOString(),
      appliedCount: appliedCount,
      totalSavings: totalSavings,
      optimizations: optimizations.map(opt => ({
        position: opt.positionRef,
        category: opt.category,
        measure: opt.measure,
        saving: opt.savingAmount
      }))
    });
    
    // Speichere aktualisiertes LV
    await query(
      `UPDATE lvs 
       SET content = $1, 
           updated_at = NOW() 
       WHERE project_id = $2 AND trade_id = $3`,
      [JSON.stringify(lvContent), projectId, tradeId]
    );
    
    // Log für Audit
    await query(
      `INSERT INTO project_logs (project_id, action, details, created_at)
       VALUES ($1, $2, $3, NOW())`,
      [
        projectId, 
        'lv_optimized',
        JSON.stringify({
          tradeId: tradeId,
          appliedOptimizations: appliedCount,
          totalSavings: totalSavings,
          newTotal: newTotalSum
        })
      ]
    );
    
    console.log(`[APPLY-OPT] Successfully applied ${appliedCount} optimizations, saved ${totalSavings}€`);
    
    res.json({
      success: true,
      appliedCount: appliedCount,
      totalSavings: Math.round(totalSavings * 100) / 100,
      newTotal: newTotalSum,
      message: `${appliedCount} Optimierungen erfolgreich angewendet. Ersparnis: ${formatCurrency(totalSavings)}`
    });
    
  } catch (err) {
    console.error('[APPLY-OPT] Failed to apply optimizations:', err);
    res.status(500).json({ 
      error: 'Fehler beim Anwenden der Optimierungen',
      details: err.message 
    });
  }
});

// ============================================================================
// NEUE ROUTEN FÜR DIE ERWEITERTE PLATTFORM
// ============================================================================

// 1. AUTH ROUTES - Registrierung & Login für Bauherren/Handwerker
// ----------------------------------------------------------------------------

// Korrigierte Bauherr Registrierung Backend-Route
app.post('/api/bauherr/register', async (req, res) => {
  try {
    const { 
      email, 
      password, 
      name, 
      phone, 
      street, 
      houseNumber, 
      zipCode, 
      city,
      projectId
    } = req.body;
    
    // Validierung
    if (!email || !password || !name || !phone) {
      return res.status(400).json({ 
        error: 'Pflichtfelder fehlen' 
      });
    }
    
    // Check if user exists
    const userCheck = await query(
      'SELECT * FROM bauherren WHERE email = $1', 
      [email.toLowerCase()]
    );
    
    if (userCheck.rows.length > 0) {
      return res.status(400).json({ 
        error: 'E-Mail bereits registriert' 
      });
    }
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Generate email verification token
    const crypto = require('crypto');
    const emailVerificationToken = crypto.randomBytes(32).toString('hex');
    const emailVerificationExpires = new Date(Date.now() + 48 * 60 * 60 * 1000); // 48 Stunden
    
    // Insert bauherr mit Token
    const result = await query(
      `INSERT INTO bauherren (
        email, 
        password, 
        name, 
        phone, 
        street, 
        house_number, 
        zip, 
        city,
        email_verified,
        email_verification_token,
        email_verification_expires,
        created_at
      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, false, $9, $10, NOW())
      RETURNING id, email, name`,
      [
        email.toLowerCase(), 
        hashedPassword, 
        name, 
        phone, 
        street || null, 
        houseNumber || null, 
        zipCode || null, 
        city || null,
        emailVerificationToken,
        emailVerificationExpires
      ]
    );
    
    const bauherrId = result.rows[0].id;
    
    // Wenn projectId vorhanden, verknüpfe Projekt mit Bauherr
    if (projectId) {
      await query(
        'UPDATE projects SET bauherr_id = $1 WHERE id = $2',
        [bauherrId, projectId]
      );
    }

    // Hole Projektdetails falls projectId vorhanden
let projectDetails = null;
let projectResult = null; // Außerhalb definieren!
    
  if (projectId) {
  projectResult = await query(
    'SELECT category, sub_category, description FROM projects WHERE id = $1',
    [projectId]
  );
  
  if (projectResult.rows.length > 0) {
    const proj = projectResult.rows[0];
    projectDetails = `${proj.category}${proj.sub_category ? ' - ' + proj.sub_category : ''}: ${proj.description?.substring(0, 100)}`;
  }
}
    
    // E-Mail senden mit Token
    const emailService = require('./emailService');
    const emailResult = await emailService.sendBauherrRegistrationEmail({
    id: bauherrId,
    name: name,
    email: email,
    verificationToken: emailVerificationToken,
    projectDetails: projectResult.rows.length > 0 ? {
    category: projectResult.rows[0].category,
    subCategory: projectResult.rows[0].sub_category,
    description: projectResult.rows[0].description
  } : null
});
    
    // JWT Token für Session (aber E-Mail noch nicht verifiziert)
    const token = jwt.sign(
      { 
        id: bauherrId, 
        type: 'bauherr',
        email: email,
        name: name,
        emailVerified: false
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
    
    res.status(201).json({
      success: true,
      token,
      user: {
        id: bauherrId,
        email: email,
        name: name,
        emailVerified: false
      },
      message: 'Registrierung erfolgreich! Bitte bestätigen Sie Ihre E-Mail-Adresse.',
      emailSent: emailResult.success,
      requiresVerification: true
    });
    
  } catch (error) {
    console.error('Bauherr registration error:', error);
    res.status(500).json({ 
      error: 'Registrierung fehlgeschlagen' 
    });
  }
});

// Korrigierte Handwerker Registrierung mit E-Mail-Token
app.post('/api/handwerker/register', async (req, res) => {
  try {
    const {
      companyName, 
      email, 
      password,
      phone, 
      contactPerson,
      street, 
      houseNumber, 
      zipCode,
      city,
      companyType,
      registrationNumber,
      taxNumber,
      website,
      references,
      trades, 
      actionRadius, 
      maxProjectVolume,
      availableFrom,
      employees, 
      insurances, 
      certifications
    } = req.body;
    
    // Validierung
    if (!companyName || !email || !password || !phone || !contactPerson) {
      return res.status(400).json({ 
        error: 'Pflichtfelder fehlen' 
      });
    }
    
    // Check if email exists
    const existingCheck = await query(
      'SELECT * FROM handwerker WHERE email = $1', 
      [email.toLowerCase()]
    );
    
    if (existingCheck.rows.length > 0) {
      return res.status(400).json({ 
        error: 'Diese E-Mail-Adresse ist bereits registriert' 
      });
    }
    
    // Generate company ID
    const year = new Date().getFullYear();
    const random = Math.floor(Math.random() * 9000) + 1000;
    const companyId = `HW-${year}-${random}`;
    
    // Hash password
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // Generate email verification token
    const crypto = require('crypto');
    const emailVerificationToken = crypto.randomBytes(32).toString('hex');
    const emailVerificationExpires = new Date(Date.now() + 48 * 60 * 60 * 1000); // 48 Stunden
    
    // Start transaction
    await query('BEGIN');
    
    try {
      // Insert handwerker mit E-Mail-Token
      const result = await query(
        `INSERT INTO handwerker (
          company_id, 
          email, 
          password_hash,
          company_name, 
          contact_person, 
          phone,
          street, 
          house_number, 
          zip_code, 
          city, 
          company_type,
          registration_number,
          tax_number,
          website,
          action_radius,
          max_project_volume, 
          available_from, 
          employee_count, 
          company_references,
          verification_status,
          email_verified,
          email_verification_token,
          email_verification_expires,
          active,
          created_at,
          updated_at
        ) VALUES (
          $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 
          $11, $12, $13, $14, $15, $16, $17, $18, $19,
          'pending', false, $20, $21, true, NOW(), NOW()
        )
        RETURNING id, company_id, company_name, email`,
        [
          companyId, 
          email.toLowerCase(), 
          hashedPassword,
          companyName, 
          contactPerson, 
          phone,
          street, 
          houseNumber, 
          zipCode,
          city, 
          companyType || null,
          registrationNumber || null,
          taxNumber || null,
          website || null,
          actionRadius || 25,
          maxProjectVolume || 50000, 
          availableFrom || null, 
          employees || null,
          references || null,
          emailVerificationToken,
          emailVerificationExpires
        ]
      );
      
      const handwerkerId = result.rows[0].id;

      // HIER EINFÜGEN - direkt nach der handwerkerId Zuweisung:
await query(
  `UPDATE handwerker SET 
    street = $1, house_number = $2, zip_code = $3, city = $4, action_radius = $5
   WHERE id = $6`,
  [street, houseNumber, zipCode, city, actionRadius || 25, handwerkerId]
);
      
      // Insert trades
      if (trades && trades.length > 0) {
  for (const tradeCode of trades) {
    const tradeInfo = await query(
      'SELECT id, name FROM trades WHERE code = $1',
      [tradeCode]
    );
    
    if (tradeInfo.rows.length > 0) {
      const trade = tradeInfo.rows[0];
      await query(
        'INSERT INTO handwerker_trades (handwerker_id, trade_id, trade_code, trade_name) VALUES ($1, $2, $3, $4)',
        [handwerkerId, trade.id, tradeCode, trade.name]
      );
    }
  }
}
      
      // Insert insurances
      if (insurances && insurances.length > 0) {
        for (const insurance of insurances) {
          await query(
            'INSERT INTO handwerker_insurances (handwerker_id, insurance_type) VALUES ($1, $2)',
            [handwerkerId, insurance]
          );
        }
      }
      
      // Insert certifications
      if (certifications && certifications.length > 0) {
        for (const cert of certifications) {
          await query(
            'INSERT INTO handwerker_certifications (handwerker_id, certification_name) VALUES ($1, $2)',
            [handwerkerId, cert]
          );
        }
      }
      
      // Commit transaction
      await query('COMMIT');
      
      // E-MAIL MIT TOKEN VERSENDEN
      const emailService = require('./emailService');
      const emailResult = await emailService.sendHandwerkerRegistrationEmail({
        id: handwerkerId,
        companyId: companyId,
        companyName: companyName,
        email: email,
        contactPerson: contactPerson,
        verificationToken: emailVerificationToken
      });
      
      // JWT Token erstellen (aber E-Mail noch nicht verifiziert)
      const token = jwt.sign(
        {
          id: handwerkerId,
          companyId: companyId,
          email: email,
          companyName: companyName,
          emailVerified: false
        },
        process.env.JWT_SECRET || 'your-secret-key',
        { expiresIn: '24h' }
      );
      
      res.status(201).json({
        success: true,
        companyId,
        token,
        handwerker: {
          id: handwerkerId,
          companyId: companyId,
          companyName: companyName,
          email: result.rows[0].email,
          emailVerified: false
        },
        message: 'Registrierung erfolgreich! Bitte bestätigen Sie Ihre E-Mail-Adresse.',
        emailSent: emailResult.success,
        requiresVerification: true
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      console.error('Transaction error:', innerErr);
      throw innerErr;
    }
    
  } catch (error) {
    console.error('Handwerker registration error:', error);
    res.status(500).json({ 
      error: 'Registrierung fehlgeschlagen' 
    });
  }
});

app.get('/api/handwerker/:identifier/tenders/new', async (req, res) => {
  try {
    const { identifier } = req.params;
    
    // Handwerker ID bestimmen (wie vorher)
    let handwerkerId;
    if (/^\d+$/.test(identifier)) {
      handwerkerId = parseInt(identifier);
    } else if (identifier.startsWith('HW-')) {
      const handwerkerResult = await query(
        'SELECT id FROM handwerker WHERE company_id = $1',
        [identifier]
      );
      if (handwerkerResult.rows.length === 0) {
        return res.status(404).json({ error: 'Handwerker nicht gefunden' });
      }
      handwerkerId = handwerkerResult.rows[0].id;
    }
    
    // Handwerker-Daten laden
    const handwerker = await query(
      'SELECT id, company_name, zip_code, action_radius FROM handwerker WHERE id = $1',
      [handwerkerId]
    );
    
    if (handwerker.rows.length === 0) {
      return res.status(404).json({ error: 'Handwerker nicht gefunden' });
    }
    
    const hw = handwerker.rows[0];
    
    // Trades des Handwerkers
    const trades = await query(
      'SELECT trade_id FROM handwerker_trades WHERE handwerker_id = $1',
      [handwerkerId]
    );
    
    const tradeIds = trades.rows.map(t => t.trade_id);
    
    // ALLE passenden Tenders im Radius finden (nicht nur verknüpfte!)
    const result = await query(
      `SELECT DISTINCT
        t.id,
        t.project_id,
        t.trade_id,
        t.status,
        t.deadline,
        t.created_at,
        t.estimated_value,
        t.timeframe,
        tr.name as trade_name,
        tr.code as trade_code,
        p.description as project_description,
        p.category,
        p.sub_category,
        p.zip_code as project_zip,
        p.city as project_city,
        th.viewed_at,
        CASE 
          WHEN z1.latitude IS NOT NULL AND z2.latitude IS NOT NULL THEN
            ST_Distance(
              ST_MakePoint(z1.longitude, z1.latitude)::geography,
              ST_MakePoint(z2.longitude, z2.latitude)::geography
            ) / 1000
          WHEN p.zip_code = $2 THEN 0
          ELSE $3
        END AS distance_km,
        CASE WHEN th.id IS NULL THEN true ELSE false END as "isNew",
        o.id as offer_id
      FROM tenders t
      JOIN trades tr ON t.trade_id = tr.id
      JOIN projects p ON t.project_id = p.id
      LEFT JOIN zip_codes z1 ON z1.zip = p.zip_code
      LEFT JOIN zip_codes z2 ON z2.zip = $2
      LEFT JOIN tender_handwerker th ON th.tender_id = t.id AND th.handwerker_id = $1
      LEFT JOIN offers o ON o.tender_id = t.id AND o.handwerker_id = $1
      WHERE t.trade_id = ANY($4::int[])
        AND t.status = 'open'
        AND (
  o.id IS NULL 
  OR o.status = 'withdrawn'
)
        AND (
          p.zip_code = $2
          OR (
            z1.latitude IS NOT NULL AND z2.latitude IS NOT NULL
            AND ST_DWithin(
              ST_MakePoint(z1.longitude, z1.latitude)::geography,
              ST_MakePoint(z2.longitude, z2.latitude)::geography,
              $3 * 1000
            )
          )
        )
      ORDER BY t.created_at DESC`,
      [handwerkerId, hw.zip_code, hw.action_radius, tradeIds]
    );
    
    // Automatisch verknüpfen wenn noch nicht vorhanden
    for (const tender of result.rows) {
      if (tender.isNew) {
        await query(
          `INSERT INTO tender_handwerker (tender_id, handwerker_id, status, notified_at, distance_km)
           VALUES ($1, $2, 'pending', NOW(), $3)
           ON CONFLICT DO NOTHING`,
          [tender.id, handwerkerId, Math.round(tender.distance_km || 0)]
        );
      }
    }
    
    console.log(`Found ${result.rows.length} tenders for ${hw.company_name}`);
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error in tenders/new:', error);
    res.status(500).json({ error: error.message });
  }
});

// GET Trades für einen Handwerker
app.get('/api/handwerker/:id/trades', async (req, res) => {
  try {
    const result = await query(
      `SELECT array_agg(trade_code) as trades 
       FROM handwerker_trades 
       WHERE handwerker_id = $1`,
      [req.params.id]
    );
    
    res.json({ 
      trades: result.rows[0]?.trades || [] 
    });
  } catch (err) {
    console.error('Error fetching trades:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Gewerke' });
  }
});

// PUT Trades für einen Handwerker
app.put('/api/handwerker/:id/gewerke', async (req, res) => {
  try {
    const { trades } = req.body;
    const handwerkerId = req.params.id;
    
    await query('BEGIN');
    
    await query('DELETE FROM handwerker_trades WHERE handwerker_id = $1', [handwerkerId]);
    
    for (const tradeCode of trades) {
      const tradeResult = await query(
        'SELECT id, name FROM trades WHERE code = $1',
        [tradeCode]
      );
      
      if (tradeResult.rows.length > 0) {
        const trade = tradeResult.rows[0];
        await query(
          'INSERT INTO handwerker_trades (handwerker_id, trade_id, trade_code, trade_name) VALUES ($1, $2, $3, $4)',
          [handwerkerId, trade.id, tradeCode, trade.name]
        );
      }
    }
    
    await query('COMMIT');
    res.json({ success: true });
    
  } catch (err) {
    await query('ROLLBACK');
    console.error('Gewerke update error:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// ============================================================================
// PASSWORT RESET - AKTUALISIERT MIT E-MAIL
// ============================================================================
app.post('/api/handwerker/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ 
        error: 'E-Mail-Adresse erforderlich' 
      });
    }
    
    // Rate Limiting prüfen
    const rateLimitCheck = await query(
      'SELECT check_email_rate_limit($1, $2, 3, 60) as allowed',
      [email, 'password_reset']
    );
    
    if (!rateLimitCheck.rows[0].allowed) {
      return res.status(429).json({ 
        error: 'Zu viele Anfragen. Bitte versuchen Sie es später erneut.' 
      });
    }
    
    // Prüfe ob E-Mail existiert
    const result = await query(
      'SELECT id, company_name, contact_person FROM handwerker WHERE LOWER(email) = LOWER($1)',
      [email]
    );
    
    if (result.rows.length === 0) {
      // Aus Sicherheitsgründen keine Info ob E-Mail existiert
      return res.json({ 
        message: 'Falls ein Account mit dieser E-Mail existiert, wurde eine Nachricht versendet.' 
      });
    }
    
    const handwerker = result.rows[0];
    
    // Reset-Token generieren
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenExpiry = new Date(Date.now() + 3600000); // 1 Stunde
    
    // Token in DB speichern
    await query(
      `UPDATE handwerker 
       SET reset_token = $2, 
           reset_token_expiry = $3,
           updated_at = NOW()
       WHERE id = $1`,
      [handwerker.id, resetToken, resetTokenExpiry]
    );
    
    // E-MAIL VERSENDEN - NEU!
    const emailResult = await emailService.sendPasswordResetEmail(
      email,
      resetToken,
      {
        companyName: handwerker.company_name,
        contactPerson: handwerker.contact_person
      }
    );
    
    // E-Mail Log erstellen
    await query(
      `INSERT INTO email_logs (recipient_email, email_type, subject, status, handwerker_id, sent_at)
       VALUES ($1, 'password_reset', 'Passwort zurücksetzen', $2, $3, $4)`,
      [email, emailResult.success ? 'sent' : 'failed', handwerker.id, emailResult.success ? new Date() : null]
    );
    
    res.json({ 
      message: 'Falls ein Account mit dieser E-Mail existiert, wurde eine Nachricht versendet.' 
    });
    
  } catch (err) {
    console.error('Passwort-Reset Fehler:', err);
    res.status(500).json({ 
      error: 'Ein Fehler ist aufgetreten' 
    });
  }
});

// ============================================================================
// E-MAIL VERIFIZIERUNG - NEU!
// ============================================================================
app.get('/api/handwerker/verify-email', async (req, res) => {
  try {
    const { token } = req.query;
    
    if (!token) {
      return res.status(400).json({ error: 'Token erforderlich' });
    }
    
    // Handwerker mit Token finden
    const result = await query(
      `SELECT id, company_id, company_name, email FROM handwerker 
       WHERE email_verification_token = $1 
       AND email_verification_expires > NOW()`,
      [token]
    );
    
    if (result.rows.length === 0) {
      return res.status(400).json({ error: 'Ungültiger oder abgelaufener Token' });
    }
    
    const handwerker = result.rows[0];
    
    // E-Mail als verifiziert markieren
    await query(
      `UPDATE handwerker 
       SET email_verified = true,
           email_verification_token = NULL,
           email_verification_expires = NULL,
           verification_status = 'verified',
           updated_at = NOW()
       WHERE id = $1`,
      [handwerker.id]
    );
    
    // Log erstellen
    await query(
      `INSERT INTO email_logs (recipient_email, email_type, subject, status, handwerker_id, sent_at)
       VALUES ($1, 'verification_success', 'E-Mail verifiziert', 'sent', $2, NOW())`,
      [handwerker.email, handwerker.id]
    );
    
    // JWT Token generieren
    const jwtToken = jwt.sign(
      {
        id: handwerker.id,
        companyId: handwerker.company_id,
        email: handwerker.email,
        companyName: handwerker.company_name,
        emailVerified: true
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '24h' }
    );
    
    res.json({ 
      success: true, 
      message: 'E-Mail erfolgreich verifiziert. Sie können sich jetzt anmelden.',
      id: handwerker.id,
      companyId: handwerker.company_id,
      companyName: handwerker.company_name,
      email: handwerker.email,
      token: jwtToken  // JWT Token mitschicken
    });
    
  } catch (error) {
    console.error('E-Mail-Verifikationsfehler:', error);
    res.status(500).json({ error: 'Verifikation fehlgeschlagen' });
  }
});

// Dokument Upload
app.post('/api/handwerker/upload-document', upload.single('document'), async (req, res) => {
  try {
    const { handwerkerId, documentType } = req.body;
    const fileBuffer = req.file.buffer;
    
    await query(
      `INSERT INTO handwerker_documents 
       (handwerker_id, document_type, file_data, file_name, file_size, mime_type) 
       VALUES ($1, $2, $3, $4, $5, $6)`,
      [handwerkerId, documentType, fileBuffer, req.file.originalname, req.file.size, req.file.mimetype]
    );
    
    res.json({ success: true, message: 'Dokument erfolgreich hochgeladen' });
  } catch (err) {
    console.error('Upload error:', err);
    res.status(500).json({ error: 'Upload fehlgeschlagen' });
  }
});

// Dokument abrufen
app.get('/api/handwerker/document/:id', async (req, res) => {
  try {
    const result = await query(
      'SELECT file_data, file_name, mime_type FROM handwerker_documents WHERE id = $1',
      [req.params.id]
    );
    
    if (result.rows.length > 0) {
      const doc = result.rows[0];
      res.setHeader('Content-Type', doc.mime_type);
      res.setHeader('Content-Disposition', `inline; filename="${doc.file_name}"`);
      res.send(doc.file_data);
    } else {
      res.status(404).json({ error: 'Dokument nicht gefunden' });
    }
  } catch (err) {
    res.status(500).json({ error: 'Fehler beim Abrufen' });
  }
});

// Bauherr Login mit Passwort ODER nur E-Mail (Rückwärtskompatibilität)
app.post('/api/bauherr/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    if (!email) {
      return res.status(400).json({ 
        error: 'E-Mail erforderlich' 
      });
    }
    
    const result = await query(
      `SELECT id, name, email, password, phone, 
       street, house_number, zip, city,
       email_verified, last_login
       FROM bauherren WHERE LOWER(email) = LOWER($1)`,
      [email]
    );
    
    if (result.rows.length === 0) {
      return res.status(401).json({ 
        error: 'Account nicht gefunden' 
      });
    }
    
    const bauherr = result.rows[0];
    
    // Passwort-Logik für Rückwärtskompatibilität
    if (bauherr.password && password) {
      const isPasswordValid = await bcrypt.compare(password, bauherr.password);
      if (!isPasswordValid) {
        return res.status(401).json({ 
          error: 'Ungültiges Passwort' 
        });
      }
    } else if (bauherr.password && !password) {
      return res.status(401).json({ 
        error: 'Passwort erforderlich' 
      });
    }
    // Wenn kein Passwort gesetzt (alte Accounts), erlaube Login nur mit E-Mail
    
    // Update last_login
    await query(
      'UPDATE bauherren SET last_login = CURRENT_TIMESTAMP WHERE id = $1',
      [bauherr.id]
    );
    
    // JWT Token
    const token = jwt.sign(
      {
        id: bauherr.id,
        type: 'bauherr',
        email: bauherr.email,
        name: bauherr.name
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
    
    // Projekte holen
    const projectsResult = await query(
      'SELECT id, category, sub_category, created_at FROM projects WHERE bauherr_id = $1 ORDER BY created_at DESC',
      [bauherr.id]
    );
    
    res.json({
      success: true,
      token,
      user: {
        id: bauherr.id,
        name: bauherr.name,
        email: bauherr.email,
        phone: bauherr.phone,
        emailVerified: bauherr.email_verified,
        projects: projectsResult.rows
      }
    });
    
  } catch (err) {
    console.error('Bauherr Login-Fehler:', err);
    res.status(500).json({ 
      error: 'Login fehlgeschlagen' 
    });
  }
});

// Bauherr Passwort vergessen
app.post('/api/bauherr/forgot-password', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ 
        error: 'E-Mail-Adresse erforderlich' 
      });
    }
    
    // Rate Limiting
    const rateLimitCheck = await query(
      'SELECT check_email_rate_limit($1, $2, 3, 60) as allowed',
      [email, 'password_reset']
    );
    
    if (!rateLimitCheck.rows[0].allowed) {
      return res.status(429).json({ 
        error: 'Zu viele Anfragen. Bitte versuchen Sie es später erneut.' 
      });
    }
    
    // Prüfe ob E-Mail existiert
    const result = await query(
      'SELECT id, name FROM bauherren WHERE LOWER(email) = LOWER($1)',
      [email]
    );
    
    if (result.rows.length === 0) {
      return res.json({ 
        message: 'Falls ein Account existiert, wurde eine E-Mail versendet.' 
      });
    }
    
    const bauherr = result.rows[0];
    
    // Reset-Token generieren
    const crypto = require('crypto');
    const resetToken = crypto.randomBytes(32).toString('hex');
    const resetTokenExpiry = new Date(Date.now() + 3600000);
    
    // Token speichern
    await query(
      `UPDATE bauherren 
       SET reset_token = $2, 
           reset_token_expiry = $3
       WHERE id = $1`,
      [bauherr.id, resetToken, resetTokenExpiry]
    );
    
    // E-Mail senden
    const emailService = require('./emailService');
    await emailService.sendBauherrPasswordResetEmail(
      email,
      resetToken,
      {
        name: bauherr.name
      }
    );
    
    res.json({ 
      message: 'Falls ein Account existiert, wurde eine E-Mail versendet.' 
    });
    
  } catch (err) {
    console.error('Passwort-Reset Fehler:', err);
    res.status(500).json({ 
      error: 'Ein Fehler ist aufgetreten' 
    });
  }
});

// Bauherr Passwort zurücksetzen
app.post('/api/bauherr/reset-password', async (req, res) => {
  try {
    const { token, newPassword } = req.body;
    
    if (!token || !newPassword) {
      return res.status(400).json({ 
        error: 'Token und neues Passwort erforderlich' 
      });
    }
    
    if (newPassword.length < 8) {
      return res.status(400).json({ 
        error: 'Passwort muss mindestens 8 Zeichen lang sein' 
      });
    }
    
    // Finde Bauherr mit gültigem Token
    const result = await query(
      `SELECT id FROM bauherren 
       WHERE reset_token = $1 
       AND reset_token_expiry > NOW()`,
      [token]
    );
    
    if (result.rows.length === 0) {
      return res.status(400).json({ 
        error: 'Ungültiger oder abgelaufener Reset-Link' 
      });
    }
    
    const bauherrId = result.rows[0].id;
    
    // Hashe neues Passwort
    const hashedPassword = await bcrypt.hash(newPassword, 10);
    
    // Update Passwort
    await query(
      `UPDATE bauherren 
       SET password = $2,
           reset_token = NULL,
           reset_token_expiry = NULL,
           password_changed_at = NOW()
       WHERE id = $1`,
      [bauherrId, hashedPassword]
    );
    
    res.json({ 
      success: true,
      message: 'Passwort erfolgreich zurückgesetzt' 
    });
    
  } catch (err) {
    console.error('Reset-Passwort Fehler:', err);
    res.status(500).json({ 
      error: 'Passwort konnte nicht zurückgesetzt werden' 
    });
  }
});

// E-Mail verifizieren
app.get('/api/bauherr/verify-email', async (req, res) => {
  try {
    const { token } = req.query;
    
    if (!token) {
      return res.status(400).json({ error: 'Token erforderlich' });
    }
    
    const result = await query(
      `SELECT id, name, email FROM bauherren 
       WHERE email_verification_token = $1 
       AND email_verification_expires > NOW()`,
      [token]
    );
    
    if (result.rows.length === 0) {
      return res.status(400).json({ 
        error: 'Ungültiger oder abgelaufener Token' 
      });
    }
    
    const bauherr = result.rows[0];
    
    await query(
      `UPDATE bauherren 
       SET email_verified = true,
           email_verification_token = NULL,
           email_verification_expires = NULL
       WHERE id = $1`,
      [bauherr.id]
    );
    
    // JWT Token generieren (andere Variable verwenden!)
    const jwtToken = jwt.sign(  // <-- jwtToken statt token
      {
        id: bauherr.id,
        type: 'bauherr',
        email: bauherr.email,
        name: bauherr.name,
        emailVerified: true
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '7d' }
    );
    
    // NUR EINE Response:
    res.json({ 
      success: true, 
      message: 'E-Mail erfolgreich verifiziert',
      id: bauherr.id,
      name: bauherr.name,
      email: bauherr.email,
      token: jwtToken  // JWT Token mitschicken
    });
    
  } catch (error) {
    console.error('E-Mail-Verifikationsfehler:', error);
    res.status(500).json({ 
      error: 'Verifikation fehlgeschlagen' 
    });
  }
});

// Handwerker Verify
app.post('/api/handwerker/verify', async (req, res) => {
  try {
    const { email, companyId } = req.body;
    
    const result = await query(
      `SELECT h.*, array_agg(ht.trade_code) as trades
       FROM handwerker h
       LEFT JOIN handwerker_trades ht ON ht.handwerker_id = h.id
       WHERE h.email = $1 AND h.company_id = $2
       GROUP BY h.id`,
      [email, companyId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Betrieb nicht gefunden' });
    }
    
    const handwerker = result.rows[0];
    
    res.json({
      id: handwerker.id,
      companyId: handwerker.company_id,
      companyName: handwerker.company_name,
      email: handwerker.email,
      trades: handwerker.trades || [],
      region: `${handwerker.zip_code} ${handwerker.city}`, // zip_code statt zip
      actionRadius: handwerker.action_radius
    });
    
  } catch (error) {
    console.error('Handwerker verify error:', error);
    res.status(500).json({ error: 'Verifizierung fehlgeschlagen' });
  }
});

// Handwerker Login mit Passwort
app.post('/api/handwerker/login', async (req, res) => {
  try {
    const { email, password, rememberMe } = req.body;

    if (!email || !password) {
      return res.status(400).json({ 
        error: 'E-Mail und Passwort sind erforderlich' 
      });
    }

    // Handwerker finden
    const result = await query(
      `SELECT 
        id, company_id, company_name, email, password_hash,
        phone, contact_person, street, house_number, zip_code, city,
        action_radius, verification_status, two_factor_enabled,
        active, email_verified, login_notification_enabled
       FROM handwerker 
       WHERE LOWER(email) = LOWER($1) 
       AND deleted_at IS NULL`,
      [email]
    );

    if (result.rows.length === 0) {
      // Log fehlgeschlagenen Versuch mit unbekannter E-Mail
      await query(
        `INSERT INTO login_attempts (handwerker_id, ip_address, success, attempted_at) 
         VALUES (NULL, $1, false, CURRENT_TIMESTAMP)`,
        [req.ip]
      );
      
      return res.status(401).json({ 
        error: 'Ungültige E-Mail oder Passwort' 
      });
    }

    const handwerker = result.rows[0];

    // Account-Status prüfen
    if (!handwerker.active) {
      return res.status(403).json({ 
        error: 'Ihr Account wurde deaktiviert.' 
      });
    }

    // E-Mail-Verifikation prüfen (optional - je nach Anforderung)
    if (!handwerker.email_verified) {
      // Trotzdem Login erlauben, aber mit Warnung
      console.log('Login ohne E-Mail-Verifikation:', email);
    }

    // Passwort prüfen
    const isPasswordValid = await bcrypt.compare(password, handwerker.password_hash);
    
    if (!isPasswordValid) {
      // Log fehlgeschlagenen Versuch
      await query(
        `INSERT INTO login_attempts (handwerker_id, ip_address, success, attempted_at) 
         VALUES ($1, $2, false, CURRENT_TIMESTAMP)`,
        [handwerker.id, req.ip]
      );
      
      return res.status(401).json({ 
        error: 'Ungültige E-Mail oder Passwort' 
      });
    }

    // Erfolgreichen Login loggen
    await query(
      `INSERT INTO login_attempts (handwerker_id, ip_address, success, attempted_at, user_agent) 
       VALUES ($1, $2, true, CURRENT_TIMESTAMP, $3)`,
      [handwerker.id, req.ip, req.headers['user-agent']]
    );

    // Last Login aktualisieren
    await query(
      `UPDATE handwerker 
       SET last_login = CURRENT_TIMESTAMP 
       WHERE id = $1`,
      [handwerker.id]
    );

    // Prüfe auf verdächtigen Login (neue IP, neue Location, etc.)
    const previousLogins = await query(
      `SELECT DISTINCT ip_address 
       FROM login_attempts 
       WHERE handwerker_id = $1 
       AND success = true 
       AND attempted_at > NOW() - INTERVAL '30 days'
       LIMIT 5`,
      [handwerker.id]
    );
    
    const isNewLocation = !previousLogins.rows.some(row => row.ip_address === req.ip);
    
    // Bei neuem Standort und aktivierter Benachrichtigung: E-Mail senden
    if (isNewLocation && handwerker.login_notification_enabled) {
      await emailService.sendLoginNotification(
        {
          companyName: handwerker.company_name,
          email: handwerker.email
        },
        {
          ipAddress: req.ip,
          userAgent: req.headers['user-agent'],
          loginTime: new Date(),
          location: 'Deutschland' // Kann mit IP-Geolocation Service erweitert werden
        }
      );
    }

    // JWT Token generieren
    const tokenExpiry = rememberMe ? '30d' : '24h';
    const token = jwt.sign(
      {
        id: handwerker.id,
        companyId: handwerker.company_id,
        email: handwerker.email,
        companyName: handwerker.company_name,
        emailVerified: handwerker.email_verified
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: tokenExpiry }
    );

    // Response
    res.json({
      success: true,
      token,
      handwerker: {
        id: handwerker.id,
        companyId: handwerker.company_id,
        companyName: handwerker.company_name,
        email: handwerker.email,
        phone: handwerker.phone,
        contactPerson: handwerker.contact_person,
        address: {
          street: handwerker.street,
          houseNumber: handwerker.house_number,
          zipCode: handwerker.zip_code,
          city: handwerker.city
        },
        actionRadius: handwerker.action_radius,
        verificationStatus: handwerker.verification_status,
        emailVerified: handwerker.email_verified,
        twoFactorEnabled: handwerker.two_factor_enabled
      },
      warnings: !handwerker.email_verified ? ['E-Mail-Adresse noch nicht verifiziert'] : []
    });

  } catch (err) {
    console.error('Login-Fehler:', err);
    res.status(500).json({ 
      error: 'Login fehlgeschlagen' 
    });
  }
});

// ============================================================================
// E-MAIL ERNEUT SENDEN - NEU!
// ============================================================================
// Bauherr - E-Mail erneut senden
app.post('/api/bauherr/resend-verification', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'E-Mail erforderlich' });
    }
    
    // Rate Limiting
    const rateLimitCheck = await query(
  `SELECT COUNT(*) as count FROM email_logs 
   WHERE recipient_email = $1 
   AND email_type = 'verification_resend' 
   AND sent_at > NOW() - INTERVAL '1 hour'`,
  [email]
);
    
    if (rateLimitCheck.rows[0].count >= 3) {
      return res.status(429).json({ 
        error: 'Zu viele Anfragen. Bitte warten Sie eine Stunde.' 
      });
    }
    
    // Bauherr finden
    const result = await query(
      'SELECT id, name, email_verified FROM bauherren WHERE email = $1',
      [email]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Account nicht gefunden' });
    }
    
    const bauherr = result.rows[0];
    
    if (bauherr.email_verified) {
      return res.json({ 
        success: true,
        message: 'E-Mail bereits verifiziert' 
      });
    }
    
    // Neuen Token generieren
    const crypto = require('crypto');
    const verificationToken = crypto.randomBytes(32).toString('hex');
    const verificationExpires = new Date(Date.now() + 48 * 60 * 60 * 1000);
    
    // Token in DB aktualisieren
    await query(
      `UPDATE bauherren 
       SET email_verification_token = $1,
           email_verification_expires = $2
       WHERE id = $3`,
      [verificationToken, verificationExpires, bauherr.id]
    );
    
    // E-Mail senden
    const emailService = require('./emailService');
    const emailResult = await emailService.sendBauherrRegistrationEmail({
    id: bauherrId,  // Auch hier: bauherrId statt bauherr.id
    name: name,
    email: email,
    verificationToken: emailVerificationToken  // RICHTIGE Variable!
  });
    
    // Log erstellen
    await query(
      `INSERT INTO email_logs (recipient_email, email_type, sent_at)
       VALUES ($1, 'verification_resend', NOW())`,
      [email]
    );
    
    res.json({ 
      success: true,
      message: 'Verifizierungs-E-Mail wurde erneut gesendet',
      emailSent: emailResult.success
    });
    
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({ error: 'Fehler beim E-Mail-Versand' });
  }
});

app.post('/api/handwerker/resend-verification', async (req, res) => {
  try {
    const { email } = req.body;
    
    if (!email) {
      return res.status(400).json({ error: 'E-Mail erforderlich' });
    }
    
    // Rate Limiting
    const rateLimitCheck = await query(
      'SELECT check_email_rate_limit($1, $2, 3, 60) as allowed',
      [email, 'verification']
    );
    
    if (!rateLimitCheck.rows[0].allowed) {
      return res.status(429).json({ 
        error: 'Zu viele Anfragen. Bitte warten Sie eine Stunde.' 
      });
    }
    
    // Handwerker finden
    const result = await query(
      'SELECT id, company_id, company_name, contact_person, email_verified FROM handwerker WHERE email = $1',
      [email]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Account nicht gefunden' });
    }
    
    const handwerker = result.rows[0];
    
    if (handwerker.email_verified) {
      return res.json({ message: 'E-Mail bereits verifiziert' });
    }
    
    // Neuen Verification Token generieren
    const verificationToken = crypto.randomBytes(32).toString('hex');
    
    await query(
      `UPDATE handwerker 
       SET email_verification_token = $1,
           email_verification_expires = $2
       WHERE id = $3`,
      [
        verificationToken,
        new Date(Date.now() + 48 * 60 * 60 * 1000), // 48 Stunden
        handwerker.id
      ]
    );
    
    // E-Mail senden
    await emailService.sendHandwerkerRegistrationEmail({
    id: handwerkerId,  // Verwende handwerkerId (aus result.rows[0].id)
    companyId: companyId,  // Die Variable die du oben definiert hast
    companyName: companyName,  // Aus req.body
    email: email,
    contactPerson: contactPerson,  // Aus req.body
    verificationToken: emailVerificationToken  // RICHTIGE Variable!
  });
    
    res.json({ 
      success: true,
      message: 'Verifizierungs-E-Mail wurde erneut gesendet' 
    });
    
  } catch (error) {
    console.error('Resend verification error:', error);
    res.status(500).json({ error: 'Fehler beim E-Mail-Versand' });
  }
});

// Route zum nachträglichen Verknüpfen von Projekten
app.post('/api/projects/claim', async (req, res) => {
  try {
    const { projectId, bauherrId } = req.body;
    
    // Prüfe ob Projekt existiert und noch keinem Bauherrn zugeordnet ist
    const projectCheck = await query(
      'SELECT bauherr_id FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectCheck.rows.length === 0) {
      return res.status(404).json({ error: 'Projekt nicht gefunden' });
    }
    
    if (projectCheck.rows[0].bauherr_id) {
      return res.status(400).json({ error: 'Projekt bereits zugeordnet' });
    }
    
    // Verknüpfe Projekt mit Bauherr
    await query(
      'UPDATE projects SET bauherr_id = $1 WHERE id = $2',
      [bauherrId, projectId]
    );
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error claiming project:', error);
    res.status(500).json({ error: 'Fehler beim Zuordnen des Projekts' });
  }
});

// 2. PROJECT MANAGEMENT ROUTES
// ----------------------------------------------------------------------------

// Get user projects (for Bauherr Dashboard)
app.get('/api/projects/user/:email', async (req, res) => {
  try {
    const { email } = req.params;
    
    const result = await query(
      `SELECT p.* 
       FROM projects p
       JOIN bauherren b ON p.bauherr_id = b.id
       WHERE b.email = $1
       ORDER BY p.created_at DESC`,
      [email]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching user projects:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Projekte' });
  }
});

// Get project trades
app.get('/api/projects/:projectId/trades', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT t.*, pt.is_manual, pt.is_ai_recommended
       FROM trades t
       JOIN project_trades pt ON t.id = pt.trade_id
       WHERE pt.project_id = $1
       ORDER BY t.name`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching project trades:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Gewerke' });
  }
});

// Get project with full details for dashboard
app.get('/api/projects/:projectId/dashboard-details', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    // Get project
    const projectResult = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Projekt nicht gefunden' });
    }
    
    const project = projectResult.rows[0];
    
    // Get trades
    const tradesResult = await query(
      `SELECT t.*, pt.is_manual, pt.is_ai_recommended
       FROM trades t
       JOIN project_trades pt ON t.id = pt.trade_id
       WHERE pt.project_id = $1`,
      [projectId]
    );
    
    // Get LVs
    const lvsResult = await query(
      `SELECT * FROM lvs WHERE project_id = $1`,
      [projectId]
    );
    
    // Get tender status
    const tendersResult = await query(
      `SELECT COUNT(*) as count FROM tenders WHERE project_id = $1`,
      [projectId]
    );
    
    // Get offers
    const offersResult = await query(
      `SELECT o.* FROM offers o
       JOIN tenders t ON o.tender_id = t.id
       WHERE t.project_id = $1`,
      [projectId]
    );
    
    res.json({
      project: project,
      trades: tradesResult.rows,
      lvs: lvsResult.rows,
      hasTenders: tendersResult.rows[0].count > 0,
      offers: offersResult.rows,
      completedLvs: lvsResult.rows.filter(lv => {
        const content = typeof lv.content === 'string' ? 
          JSON.parse(lv.content) : lv.content;
        return content?.positions?.length > 0;
      }).length
    });
    
  } catch (error) {
    console.error('Dashboard details error:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Details' });
  }
});

// ============================================
// 3. OFFER MANAGEMENT (ANGEBOTE)
// ============================================

// Angebote für Projekt laden (Bauherr)
app.get('/api/projects/:projectId/offers/detailed', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    console.log('🔍 Loading detailed offers for project:', projectId);
    
    const offers = await query(
      `SELECT 
        o.*,
        o.bundle_discount,  
        tn.bundle_id,       
        h.company_name,
        h.email as handwerker_email,
        h.phone as handwerker_phone,
        t.name as trade_name,
        tn.estimated_value,
        CASE 
          WHEN o.viewed_at IS NULL THEN false 
          ELSE true 
        END as viewed
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE tn.project_id = $1
        AND o.status != 'withdrawn'
       ORDER BY o.status DESC, t.name, o.amount ASC`,
      [projectId]
    );
    
    console.log('📊 Found offers:', offers.rows.length);
    console.log('📦 First offer:', offers.rows[0]);
    
    // Kontaktdaten maskieren
    const processedOffers = offers.rows.map(offer => {
      if (offer.status !== 'preliminary' && offer.status !== 'accepted') {
        return {
          ...offer,
          email: 'Nach Beauftragung sichtbar',
          phone: 'Nach Beauftragung sichtbar'
        };
      }
      return {
        ...offer,
        email: offer.handwerker_email,
        phone: offer.handwerker_phone
      };
    });
    
    console.log('✅ Sending processed offers:', processedOffers.length);
    res.json(processedOffers);
    
  } catch (error) {
    console.error('❌ Error fetching detailed offers:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Angebote' });
  }
});

// Handwerker: LV für Angebot abrufen
app.get('/api/tenders/:tenderId/lv', async (req, res) => {
  try {
    const { tenderId } = req.params;
    
    const result = await query(
      `SELECT 
        t.lv_data,
        t.project_id,
        t.trade_id,
        tr.name as trade_name,
        p.description as project_description
      FROM tenders t
      JOIN trades tr ON t.trade_id = tr.id
      JOIN projects p ON t.project_id = p.id
      WHERE t.id = $1`,
      [tenderId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Ausschreibung nicht gefunden' });
    }
    
    const tender = result.rows[0];
    const lv = typeof tender.lv_data === 'string' 
      ? JSON.parse(tender.lv_data) 
      : tender.lv_data;
    
    // Preise entfernen für Handwerker-Ansicht
    const lvWithoutPrices = {
      ...lv,
      positions: lv.positions.map(pos => ({
        ...pos,
        unitPrice: 0,
        totalPrice: 0
      }))
    };
    
    res.json({
      tenderId,
      projectId: tender.project_id,
      tradeId: tender.trade_id,
      tradeName: tender.trade_name,
      projectDescription: tender.project_description,
      lv: lvWithoutPrices
    });
    
  } catch (error) {
    console.error('Error fetching tender LV:', error);
    res.status(500).json({ error: 'Fehler beim Abrufen des LV' });
  }
});

// Angebot als gelesen markieren
app.post('/api/offers/:offerId/mark-read', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    await query(
      'UPDATE offers SET viewed_at = COALESCE(viewed_at, NOW()) WHERE id = $1',
      [offerId]
    );
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// Erweiterte Route für Angebote mit mehr Details
app.get('/api/projects/:projectId/offers/detailed', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        o.bundle_discount,  
        tn.bundle_id,       
        h.company_name,
        h.email,
        h.phone,
        h.street,
        h.house_number,
        h.zip_code,
        h.city,
        h.rating,
        t.name as trade_name,
        tn.estimated_value,
        tn.timeframe,
        o.lv_data,
        o.notes,
        CASE 
          WHEN o.viewed_at IS NULL THEN false 
          ELSE true 
        END as viewed
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE tn.project_id = $1
       ORDER BY t.name, o.amount ASC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching detailed offers:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Angebote' });
  }
});

// 3. TENDER & OFFER ROUTES
// ----------------------------------------------------------------------------

// EINZIGE Tenders-Route (detailliert) – ersetzt die alte kurze Liste
app.get('/api/projects/:projectId/tenders', async (req, res) => {
  try {
    const { projectId } = req.params;
    const result = await query(
      `
      SELECT
        t.*,
        tr.name AS trade_name,
        COALESCE(stats.total_handwerker, 0)       AS total_handwerker,
        COALESCE(stats.viewed_count, 0)           AS viewed_count,
        COALESCE(stats.offer_count, 0)            AS offer_count,
        COALESCE(stats.handwerkers, '[]'::json)   AS handwerkers,
        EXISTS(
          SELECT 1 FROM offers o 
          WHERE o.tender_id = t.id 
          AND o.status = 'accepted'
        ) as has_accepted_offer
      FROM tenders t
      JOIN trades tr ON tr.id = t.trade_id
      LEFT JOIN LATERAL (
        SELECT
          COUNT(*) AS total_handwerker,
          COUNT(*) FILTER (WHERE ths.status = 'viewed') AS viewed_count,
          COUNT(o.id) AS offer_count,
          json_agg(
            json_build_object(
              'company_name',   h.company_name,
              'handwerker_id',  h.id,
              'status',         ths.status,
              'viewed_at',      ths.viewed_at,
              'in_progress_at', ths.in_progress_at,
              'submitted_at',   ths.submitted_at,
              'offer_id',       o.id
            )
            ORDER BY h.company_name
          ) AS handwerkers
        FROM tender_handwerker th
        JOIN handwerker h ON h.id = th.handwerker_id
        LEFT JOIN tender_handwerker_status ths 
          ON ths.tender_id = th.tender_id AND ths.handwerker_id = th.handwerker_id
        LEFT JOIN offers o 
          ON o.tender_id = th.tender_id AND o.handwerker_id = th.handwerker_id
        WHERE th.tender_id = t.id
      ) stats ON TRUE
      WHERE t.project_id = $1
      ORDER BY t.created_at DESC
      `,
      [projectId]
    );
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching detailed tenders:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Ausschreibungen' });
  }
});

// Get project offers
app.get('/api/projects/:projectId/offers', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT o.*, h.company_name, h.email, h.phone, t.name as trade_name
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE tn.project_id = $1
         AND o.status != 'withdrawn'
       ORDER BY o.created_at DESC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching offers:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Angebote' });
  }
});

// Ungelesene Angebote zählen
app.get('/api/projects/:projectId/offers/unread-count', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT COUNT(*) as count
       FROM offers o
       JOIN tenders t ON o.tender_id = t.id
       WHERE t.project_id = $1 
        AND o.viewed_at IS NULL
        AND o.status != 'withdrawn'`,
      [projectId]
    );
    
    res.json({ count: parseInt(result.rows[0].count) });
  } catch (error) {
    res.status(500).json({ error: 'Fehler beim Zählen' });
  }
});

// Korrigierte bestehende Route
app.get('/api/projects/:projectId/offers/:offerId', async (req, res) => {
  try {
    const { projectId, offerId } = req.params;
    
    const result = await query(
      `SELECT o.*, 
              o.bundle_discount,  
              tn.bundle_id,      
              h.company_name, 
              h.email, 
              h.phone, 
              h.street, 
              h.house_number, 
              h.zip_code, 
              h.city,
              t.name as trade_name,
              t.code as trade_code
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id  -- HIER IST DIE KORREKTUR
       WHERE tn.project_id = $1 AND o.id = $2`,
      [projectId, offerId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Angebot nicht gefunden' });
    }
    
   // Kontaktdaten-Schutz basierend auf Status
const offer = result.rows[0];
if (!['preliminary', 'confirmed', 'accepted'].includes(offer.status)) {
  // Kontaktdaten nur bei vorläufiger/finaler Beauftragung sichtbar
  offer.email = 'Wird nach Beauftragung freigegeben';
  offer.phone = 'Wird nach Beauftragung freigegeben';
  offer.street = null;
  offer.house_number = null;
}
    
    res.json(offer);
    
  } catch (error) {
    console.error('Error fetching offer details:', error);
    res.status(500).json({ error: 'Fehler beim Laden des Angebots' });
  }
});

// ============= ZWEISTUFIGE VERGABE SYSTEM =============

// Stufe 1: Vorläufige Beauftragung mit Kontaktfreigabe
app.post('/api/offers/:offerId/preliminary-accept', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { projectId } = req.body;
    
    await query('BEGIN');

    // Check ob bereits eine andere Firma in Vertragsanbahnung ist
const existingPreliminary = await query(
  `SELECT o.*, h.company_name 
   FROM offers o
   JOIN handwerker h ON o.handwerker_id = h.id
   JOIN tenders tn2 ON o.tender_id = tn2.id
   WHERE tn2.project_id = $1 
   AND tn2.trade_id = (
     SELECT trade_id FROM tenders WHERE id = (
       SELECT tender_id FROM offers WHERE id = $2
     )
   )
   AND o.status = 'preliminary'
   AND o.id != $2`,
  [projectId, offerId]
);

if (existingPreliminary.rows.length > 0) {
  await query('ROLLBACK');
  return res.status(400).json({ 
    error: 'conflict',
    existingCompany: existingPreliminary.rows[0].company_name,
    message: `Sie befinden sich in diesem Gewerk bereits in der Vertragsanbahnung mit ${existingPreliminary.rows[0].company_name}. In diesem Status hat ${existingPreliminary.rows[0].company_name} Exklusivität zu Ihrem Auftrag. Dies ermöglicht beiden Seiten eine vertrauensvolle Kennenlernphase mit ausreichend Zeit für Ortstermine und Kalkulationsanpassungen. Falls Sie mit ${existingPreliminary.rows[0].company_name} nicht fortfahren möchten, beenden Sie bitte zuerst die bestehende Vertragsanbahnung.`
  });
}

// Hole Angebotsdaten - MIT FIX!
const offerResult = await query(
  `SELECT o.*, h.*, t.name as trade_name,
          p.bauherr_id, p.description as project_description, tn.project_id,
          b.name as bauherr_name  
   FROM offers o
   JOIN handwerker h ON o.handwerker_id = h.id
   JOIN tenders tn ON o.tender_id = tn.id
   JOIN trades t ON tn.trade_id = t.id
   JOIN projects p ON tn.project_id = p.id
   LEFT JOIN bauherren b ON p.bauherr_id = b.id
   WHERE o.id = $1`,
  [offerId]
);
    
    if (offerResult.rows.length === 0) {
      throw new Error('Angebot nicht gefunden');
    }
    
    const offer = offerResult.rows[0];
    
    // Update Offer Status zu Stufe 1
    await query(
      `UPDATE offers 
       SET status = 'preliminary',
           stage = 1,
           preliminary_accepted_at = NOW(),
           nachwirkfrist_expires_at = NOW() + INTERVAL '24 months'
       WHERE id = $1`,
      [offerId]
    );

    // NEUE AKTION: Setze alle anderen Angebote desselben Gewerks auf "locked"
    await query(
      `UPDATE offers 
       SET locked_reason = 'Anderes Angebot in Vertragsanbahnung'
       WHERE tender_id IN (
         SELECT tn2.id FROM tenders tn2 
         WHERE tn2.project_id = $1 
         AND tn2.trade_id = (
           SELECT trade_id FROM tenders WHERE id = (
             SELECT tender_id FROM offers WHERE id = $2
           )
         )
       )
       AND id != $2
       AND status NOT IN ('preliminary', 'accepted', 'rejected', 'withdrawn')`,
      [projectId, offerId]
    );
    
    // Schritt 2: Tender-Handwerker-Status (HINZUFÜGEN)
    await query(
      `UPDATE tender_handwerker 
       SET status = 'preliminary_accepted'
       WHERE tender_id = (SELECT tender_id FROM offers WHERE id = $1) 
       AND handwerker_id = (SELECT handwerker_id FROM offers WHERE id = $1)`,
      [offerId]
    );
    
    // Protokolliere Kontaktfreigabe
    await query(
      `INSERT INTO contract_negotiations 
       (offer_id, action_type, action_by, action_data)
       VALUES ($1, 'contact_shared', 'system', $2)`,
      [offerId, JSON.stringify({
        bauherr_contact: true,
        handwerker_contact: true,
        timestamp: new Date().toISOString()
      })]
    );

    // Prüfe ob Konversation bereits existiert
    const existingConv = await query(
      `SELECT c.id 
       FROM conversations c
       JOIN conversation_participants cp1 ON c.id = cp1.conversation_id
       JOIN conversation_participants cp2 ON c.id = cp2.conversation_id
       WHERE c.type = 'direct'
         AND cp1.user_type = 'bauherr' AND cp1.user_id = $1
         AND cp2.user_type = 'handwerker' AND cp2.user_id = $2`,
      [offer.bauherr_id, offer.handwerker_id]
    );

    if (existingConv.rows.length === 0) {
      // Neue Direct-Conversation erstellen
      const convResult = await query(
        `INSERT INTO conversations (type, offer_id, created_at, updated_at)
         VALUES ('direct', $1, NOW(), NOW())
         RETURNING id`,
        [offerId]
      );
      
      const conversationId = convResult.rows[0].id;
      
      // Beide Teilnehmer hinzufügen
      await query(
        `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
         VALUES 
           ($1, 'bauherr', $2, 'participant'),
           ($1, 'handwerker', $3, 'participant')`,
        [conversationId, offer.bauherr_id, offer.handwerker_id]
      );
    }
    
    // ✅ NEU: Notification für Handwerker erstellen
    await query(
      `INSERT INTO notifications 
       (user_type, user_id, type, reference_id, message, metadata, created_at)
       VALUES ('handwerker', $1, 'preliminary_accepted', $2, $3, $4, NOW())`,
      [
        offer.handwerker_id,
        offerId,
        'Vorläufige Beauftragung erhalten',
        JSON.stringify({
          bauherr_name: offer.bauherr_name || 'Bauherr',
          trade_name: offer.trade_name,
          project_name: offer.project_description || 'Projekt',
          amount: offer.amount
        })
      ]
    );
    
    // Sende E-Mail-Benachrichtigungen
    if (transporter) {
      try {
        await transporter.sendMail({
          from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
          to: offer.email,
          subject: 'Vorläufige Beauftragung erhalten - Kontaktdaten freigegeben',
          html: `
            <h2>Glückwunsch! Sie haben eine vorläufige Beauftragung erhalten</h2>
            <p>Der Bauherr hat Ihr Angebot vorläufig angenommen und möchte Sie kennenlernen. Die Kontaktdaten wurden freigegeben.</p>
            
            <div style="background: #f0f9ff; border-left: 4px solid #0ea5e9; padding: 15px; margin: 20px 0;">
              <strong>Status: Vertragsanbahnung</strong><br>
              Sie befinden sich nun in der geschützten Kennenlernphase. Die 24-monatige Nachwirkfrist ist aktiv.
              Beide Seiten können das Angebot noch anpassen oder zurückziehen.
            </div>
            
            <h3>Nächste Schritte:</h3>
            <ul>
              <li>Kontaktieren Sie den Bauherren für einen Ortstermin</li>
              <li>Bestätigen oder passen Sie Ihr Angebot nach der Besichtigung an</li>
              <li>Nach Ihrer Bestätigung kann der Bauherr verbindlich beauftragen</li>
            </ul>
            
            <p><strong>Projektdetails:</strong> ${offer.trade_name}</p>
            <a href="https://byndl.de/handwerker/dashboard">Zum Dashboard</a>
          `
        });
      } catch (emailError) {
        console.error('Email-Versand fehlgeschlagen:', emailError.message);
      }
    }
    
    await query('COMMIT');
    
    res.json({
      success: true,
      message: 'Vorläufige Beauftragung erfolgreich',
      contactDetails: {
        handwerker: {
          company: offer.company_name,
          contact: offer.contact_person,
          phone: offer.phone,
          email: offer.email
        }
      }
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error in preliminary acceptance:', error);
    res.status(500).json({ error: error.message });
  }
});

// Prüft ob bereits eine Vertragsanbahnung für dieses Gewerk existiert
app.get('/api/projects/:projectId/trades/:tradeId/preliminary-check', async (req, res) => {
  try {
    const { projectId, tradeIdOrCode } = req.params;
    
    // Prüfe ob es eine ID (Zahl) oder ein Code (String) ist
    const isNumeric = /^\d+$/.test(tradeIdOrCode);
    
    let existingPreliminary;
    
    if (isNumeric) {
      // Trade-ID wurde übergeben
      existingPreliminary = await query(
        `SELECT o.*, h.company_name 
         FROM offers o
         JOIN handwerker h ON o.handwerker_id = h.id
         JOIN tenders t ON o.tender_id = t.id
         WHERE t.project_id = $1 
         AND t.trade_id = $2 
         AND o.status = 'preliminary'`,
        [projectId, tradeIdOrCode]
      );
    } else {
      // Trade-Code wurde übergeben - konvertiere zu ID
      existingPreliminary = await query(
        `SELECT o.*, h.company_name 
         FROM offers o
         JOIN handwerker h ON o.handwerker_id = h.id
         JOIN tenders t ON o.tender_id = t.id
         JOIN trades tr ON t.trade_id = tr.id
         WHERE t.project_id = $1 
         AND tr.code = $2 
         AND o.status = 'preliminary'`,
        [projectId, tradeIdOrCode]
      );
    }
    
    if (existingPreliminary.rows.length > 0) {
      return res.json({
        hasExisting: true,
        companyName: existingPreliminary.rows[0].company_name,
        offerId: existingPreliminary.rows[0].id
      });
    }
    
    res.json({ hasExisting: false });
    
  } catch (error) {
    console.error('Error checking preliminary:', error);
    res.status(500).json({ error: 'Fehler bei der Prüfung' });
  }
});

// Handwerker bestätigt Angebot nach Ortstermin
app.post('/api/offers/:offerId/confirm-after-inspection', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { adjustedAmount, notes } = req.body;
    
    await query(
      `UPDATE offers 
       SET offer_confirmed_at = NOW(),
           amount = COALESCE($2, amount),
           notes = COALESCE($3, notes),
           status = 'confirmed'  -- FEHLT IN ORIGINAL!
       WHERE id = $1`,
      [offerId, adjustedAmount, notes]
    );
    
    // Protokolliere
    await query(
      `INSERT INTO contract_negotiations 
       (offer_id, action_type, action_by, action_data)
       VALUES ($1, 'offer_confirmed', 'handwerker', $2)`,
      [offerId, JSON.stringify({ adjustedAmount, notes })]
    );
    
    res.json({ success: true, message: 'Verbindliches Angebot bestätigt' });
    
  } catch (error) {
    console.error('Error confirming offer:', error);
    res.status(500).json({ error: error.message });
  }
});

// Terminvorschlag vom Handwerker
app.post('/api/offers/:offerId/propose-appointment', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { proposedDates, message } = req.body;
    
    // Hole Kontaktdaten für Email
    const contactData = await query(
      `SELECT b.email, b.name, h.company_name, t.name as trade_name
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE o.id = $1 AND o.status = 'preliminary'`,
      [offerId]
    );
    
    if (contactData.rows.length === 0) {
      return res.status(404).json({ error: 'Angebot nicht in Vertragsanbahnung' });
    }
    
    // Speichere Terminvorschlag
    await query(
      `INSERT INTO appointment_proposals 
       (offer_id, proposed_by, proposed_dates, message, status, created_at)
       VALUES ($1, 'handwerker', $2, $3, 'pending', NOW())`,
      [offerId, JSON.stringify(proposedDates), message]
    );
    
    // Email an Bauherr
    if (transporter) {
      await transporter.sendMail({
        from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
        to: contactData.rows[0].email,
        subject: `Terminvorschlag für Ortstermin - ${contactData.rows[0].trade_name}`,
        html: `
          <h2>Neuer Terminvorschlag</h2>
          <p>${contactData.rows[0].company_name} hat Termine für einen Ortstermin vorgeschlagen:</p>
          <ul>
            ${proposedDates.map(date => `<li>${new Date(date).toLocaleString('de-DE')}</li>`).join('')}
          </ul>
          ${message ? `<p>Nachricht: ${message}</p>` : ''}
          <a href="https://byndl.de/dashboard">Zum Dashboard</a>
        `
      });
    }
    
    res.json({ success: true, message: 'Terminvorschläge gesendet' });
    
  } catch (error) {
    console.error('Error proposing appointment:', error);
    res.status(500).json({ error: error.message });
  }
});

// Vertragsanbahnung beenden - Angebot geht zurück zu submitted
app.post('/api/offers/:offerId/end-negotiation', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    await query('BEGIN');
    
    // Setze Status zurück auf submitted
    await query(
      `UPDATE offers 
       SET status = 'submitted',
           preliminary_accepted_at = NULL,
           appointment_confirmed = false,
           appointment_date = NULL,
           updated_at = NOW()
       WHERE id = $1 AND status = 'preliminary'`,
      [offerId]
    );
    
    // Update auch tender_handwerker Status
    const tenderResult = await query(
      'SELECT tender_id, handwerker_id FROM offers WHERE id = $1',
      [offerId]
    );
    
    if (tenderResult.rows.length > 0) {
      await query(
        `UPDATE tender_handwerker 
         SET status = 'submitted'
         WHERE tender_id = $1 AND handwerker_id = $2`,
        [tenderResult.rows[0].tender_id, tenderResult.rows[0].handwerker_id]
      );
    }
    
    await query('COMMIT');
    
    res.json({ success: true, message: 'Vertragsanbahnung beendet' });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error ending negotiation:', error);
    res.status(500).json({ error: 'Fehler beim Beenden der Vertragsanbahnung' });
  }
});

// Angebot ablehnen mit Begründung
app.post('/api/offers/:offerId/reject', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { reason, notes, projectId } = req.body;
    
    await query('BEGIN');
    
    // Hole Offer-Daten für Benachrichtigung
    const offerData = await query(
      `SELECT 
        o.*,
        h.email as handwerker_email,
        h.company_name,
        h.id as handwerker_id,
        t.name as trade_name,
        b.name as bauherr_name,
        p.id as project_id,
        p.category as project_category,
        p.description as project_description,
        tn.bundle_id  
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       JOIN projects p ON tn.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (offerData.rows.length === 0) {
      throw new Error('Angebot nicht gefunden');
    }
    
    const offer = offerData.rows[0];
    
    // Übersetzung der Gründe
    const reasonTexts = {
      'too_expensive': 'Das Angebot lag über dem Budget',
      'timeline': 'Der Ausführungszeitraum passte nicht',
      'quality_concerns': 'Es gab Bedenken bezüglich der Qualität',
      'better_offer': 'Ein anderes Angebot wurde bevorzugt',
      'project_cancelled': 'Das Projekt wurde verschoben oder abgesagt',
      'other': 'Sonstiger Grund'
    };
    
    // ═══════════════════════════════════════════════════════════════
    // WICHTIG: Speichere Ablehnungsgrund in Notifications
    // ═══════════════════════════════════════════════════════════════
   await query(
  `INSERT INTO notifications 
   (user_type, user_id, type, reference_id, message, metadata, created_at, read)
   VALUES ('handwerker', $1, 'offer_rejected', $2, $3, $4, NOW(), false)`,
  [
    offer.handwerker_id,
    offerId,
    `Angebot für ${offer.trade_name} wurde abgelehnt`,
    JSON.stringify({
      reason: reasonTexts[reason] || 'Nicht angegeben',
      notes: notes,
      trade_name: offer.trade_name, 
      project_id: offer.project_id,
      project_name: offer.project_description || `Projekt in ${offer.project_category}`, // HINZUFÜGEN: project_description ist nicht in der Query
      bauherr_name: offer.bauherr_name, // KORREKTUR: offer.bauherr_name statt offer.bauherrName
      project_category: offer.project_category,
      amount: offer.amount,
      bundle_id: offer.bundle_id
    })
  ]
);
    
    // ═══════════════════════════════════════════════════════════════
    // ANGEBOT LÖSCHEN (statt Status ändern)
    // ═══════════════════════════════════════════════════════════════
    await query('DELETE FROM offers WHERE id = $1', [offerId]);
    
    // Tender-Handwerker Status zurücksetzen
    await query(
      `UPDATE tender_handwerker 
       SET status = 'rejected'
       WHERE tender_id = $1 AND handwerker_id = $2`,
      [offer.tender_id, offer.handwerker_id]
    );
    
    // Log für Audit
    await query(
      `INSERT INTO project_logs (project_id, action, details, created_at)
       VALUES ($1, 'offer_rejected', $2, NOW())`,
      [
        projectId,
        JSON.stringify({
          offerId: offerId,
          handwerkerId: offer.handwerker_id,
          companyName: offer.company_name,
          tradeName: offer.trade_name,
          amount: offer.amount,
          reason: reason,
          notes: notes
        })
      ]
    );
    
    // E-Mail an Handwerker
    if (offer.handwerker_email && transporter) {
      try {
        await transporter.sendMail({
          from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
          to: offer.handwerker_email,
          subject: `Angebot abgelehnt - ${offer.trade_name}`,
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0;">
                <h1>Angebot wurde abgelehnt</h1>
              </div>
              
              <div style="padding: 30px; background: #f7f7f7;">
                <p>Sehr geehrtes Team von ${offer.company_name},</p>
                
                <p>Leider müssen wir Ihnen mitteilen, dass Ihr Angebot für <strong>${offer.trade_name}</strong> nicht berücksichtigt wurde.</p>
                
                <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h3 style="color: #ef4444;">Details:</h3>
                  <table style="width: 100%;">
                    <tr>
                      <td style="padding: 8px 0;"><strong>Projekt:</strong></td>
                      <td>${offer.project_category}</td>
                    </tr>
                    <tr>
                      <td style="padding: 8px 0;"><strong>Gewerk:</strong></td>
                      <td>${offer.trade_name}</td>
                    </tr>
                    <tr>
                      <td style="padding: 8px 0; vertical-align: top;"><strong>Grund:</strong></td>
                      <td>${reasonTexts[reason] || 'Nicht angegeben'}</td>
                    </tr>
                    ${notes ? `
                    <tr>
                      <td style="padding: 8px 0; vertical-align: top;"><strong>Anmerkung:</strong></td>
                      <td>${notes}</td>
                    </tr>
                    ` : ''}
                  </table>
                </div>
                
                <p>Vielen Dank für Ihre Mühe und die investierte Zeit.</p>
              </div>
              
              <div style="text-align: center; padding: 20px; color: #666; font-size: 12px; background: #e9ecef;">
                <p>© 2025 byndl - Die digitale Handwerkerplattform</p>
              </div>
            </div>
          `
        });
      } catch (emailError) {
        console.error('E-Mail-Versand fehlgeschlagen:', emailError);
      }
    }
    
    await query('COMMIT');
    
    res.json({ 
      success: true, 
      message: 'Angebot wurde abgelehnt und gelöscht' 
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error rejecting offer:', error);
    res.status(500).json({ error: error.message || 'Fehler beim Ablehnen' });
  }
});

// Verbindliches Angebot ablehnen - Angebot wird rejected und verschwindet
app.post('/api/offers/:offerId/reject-confirmed', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { projectId, reason } = req.body;
    
    await query('BEGIN');
    
    // Hole Offer-Daten für Logging und Benachrichtigung
    const offerData = await query(
      `SELECT o.*, h.email as handwerker_email, h.company_name, t.name as trade_name
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE o.id = $1 AND o.status = 'confirmed'`,
      [offerId]
    );
    
    if (offerData.rows.length === 0) {
      throw new Error('Angebot nicht gefunden oder nicht im Status confirmed');
    }
    
    const offer = offerData.rows[0];
    
    // Status auf 'rejected' setzen
    await query(
      `UPDATE offers 
       SET status = 'rejected',
           rejection_reason = $2,
           rejected_at = NOW(),
           updated_at = NOW()
       WHERE id = $1`,
      [offerId, reason]
    );
    
    // Log für Audit
    await query(
      `INSERT INTO project_logs (project_id, action, details, created_at)
       VALUES ($1, 'confirmed_offer_rejected', $2, NOW())`,
      [
        projectId,
        JSON.stringify({
          offerId: offerId,
          handwerkerId: offer.handwerker_id,
          companyName: offer.company_name,
          tradeName: offer.trade_name,
          amount: offer.amount,
          reason: reason
        })
      ]
    );
    
    // Benachrichtige Handwerker per E-Mail
    if (offer.handwerker_email && transporter) {
      try {
        await transporter.sendMail({
          from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
          to: offer.handwerker_email,
          subject: `Verbindliches Angebot abgelehnt - ${offer.trade_name}`,
          html: `
            <h2>Ihr verbindliches Angebot wurde abgelehnt</h2>
            <p>Sehr geehrte Damen und Herren,</p>
            <p>Der Bauherr hat Ihr verbindliches Angebot für <strong>${offer.trade_name}</strong> leider abgelehnt.</p>
            <p>Vielen Dank für Ihre Mühe und die Zeit, die Sie in dieses Projekt investiert haben.</p>
            <p>Mit freundlichen Grüßen<br>Ihr byndl-Team</p>
          `
        });
      } catch (emailError) {
        console.error('Email-Versand fehlgeschlagen:', emailError);
      }
    }
    
    await query('COMMIT');
    
    res.json({ 
      success: true, 
      message: 'Verbindliches Angebot wurde abgelehnt' 
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error rejecting confirmed offer:', error);
    res.status(500).json({ error: 'Fehler beim Ablehnen des Angebots' });
  }
});

// Stufe 2: Verbindliche Beauftragung
app.post('/api/offers/:offerId/final-accept', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    await query('BEGIN');
    
    // ✅ NEU: Hole Offer-Daten für trade_id und project_id
    const offerInfo = await query(
      `SELECT o.handwerker_id, tn.project_id, tn.trade_id, p.bauherr_id
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (offerInfo.rows.length === 0) {
      await query('ROLLBACK');
      return res.status(404).json({ error: 'Angebot nicht gefunden' });
    }
    
    const { project_id, trade_id, bauherr_id } = offerInfo.rows[0];
    
    // ✅ NEU: Akzeptiere alle change_requested Termine automatisch
    await query(
      `UPDATE schedule_entries
       SET status = 'confirmed',
           confirmed = true,
           confirmed_by = $2,
           confirmed_at = NOW()
       WHERE schedule_id IN (
         SELECT id FROM project_schedules WHERE project_id = $1
       )
       AND trade_id = $3
       AND status = 'change_requested'`,
      [project_id, bauherr_id, trade_id]
    );
    
    // Update zu Stufe 2
    await query(
      `UPDATE offers 
       SET status = 'accepted',
           stage = 2,
           final_accepted_at = NOW()
       WHERE id = $1`,
      [offerId]
    );
    
    // Erstelle Werkvertrag
    const contractResult = await query(
      `INSERT INTO orders 
       (offer_id, project_id, handwerker_id, trade_id, amount, status, created_at)
       SELECT o.id, tn.project_id, o.handwerker_id, tn.trade_id, o.amount, 'active', NOW()
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       WHERE o.id = $1
       RETURNING id`,
      [offerId]
    );
    
    await query(
      `UPDATE tender_handwerker 
       SET status = 'awarded'
       WHERE tender_id = (SELECT tender_id FROM offers WHERE id = $1) 
       AND handwerker_id = (SELECT handwerker_id FROM offers WHERE id = $1)`,
      [offerId]
    );
    
    // Aktiviere Premium-Features
    await query(
      `UPDATE projects 
       SET premium_features_active = true 
       WHERE id = (
         SELECT tn.project_id 
         FROM offers o 
         JOIN tenders tn ON o.tender_id = tn.id 
         WHERE o.id = $1
       )`,
      [offerId]
    );
    
    // Erstelle Rechnung für BYNDL-Provision
    const provisionAmount = await calculateProvision(offerId);
    await query(
      `INSERT INTO invoices 
       (type, reference_id, amount, status, due_date)
       VALUES ('provision', $1, $2, 'pending', NOW() + INTERVAL '14 days')`,
      [offerId, provisionAmount]
    );
    
    await query('COMMIT');
    
    res.json({
      success: true,
      message: 'Verbindliche Beauftragung erfolgreich',
      contractId: contractResult.rows[0].id,
      premiumFeaturesActivated: true
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error in final acceptance:', error);
    res.status(500).json({ error: error.message });
  }
});

// Helper-Funktion für Provisionsberechnung
async function calculateProvision(offerId) {
  const result = await query(
    'SELECT amount FROM offers WHERE id = $1',
    [offerId]
  );
  
  const amount = result.rows[0].amount;
  const provisionRate = 0.05; // 5% Provision
  return amount * provisionRate;
}

app.get('/api/projects/:projectId/orders', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        t.name as trade_name,
        t.code as trade_code,
        h.company_name,
        h.contact_person,
        h.phone as handwerker_phone,
        h.email as handwerker_email,
        h.address as handwerker_address,
        b.name as bauherr_name,
        b.email as bauherr_email,
        b.phone as bauherr_phone,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        p.description as project_description,
        of.lv_data
       FROM orders o
       JOIN trades t ON o.trade_id = t.id
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN bauherren b ON o.bauherr_id = b.id
       JOIN projects p ON o.project_id = p.id
       LEFT JOIN offers of ON o.offer_id = of.id
       WHERE o.project_id = $1
       ORDER BY o.created_at DESC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Aufträge' });
  }
});

// Benachrichtigungen für Handwerker laden
app.get('/api/handwerker/:handwerkerId/notifications', async (req, res) => {
  try {
    const { handwerkerId } = req.params;
    
    const result = await query(
      `SELECT * FROM notifications 
       WHERE user_type = 'handwerker' 
       AND user_id = $1 
       ORDER BY created_at DESC 
       LIMIT 50`,
      [handwerkerId]
    );
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error loading notifications:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Benachrichtigungen' });
  }
});

// Benachrichtigung als gelesen markieren
app.post('/api/notifications/:notificationId/mark-read', async (req, res) => {
  try {
    await query(
      'UPDATE notifications SET read = true WHERE id = $1',
      [req.params.notificationId]
    );
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// Get project supplements
app.get('/api/projects/:projectId/supplements', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT s.*, h.company_name
       FROM supplements s
       JOIN orders o ON s.order_id = o.id
       JOIN handwerker h ON o.handwerker_id = h.id
       WHERE o.project_id = $1
       ORDER BY s.created_at DESC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching supplements:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Nachträge' });
  }
});

// ============= BENACHRICHTIGUNGSSYSTEM =============

// Benachrichtigungen für Bauherr laden
app.get('/api/bauherr/:bauherrId/notifications', async (req, res) => {
  try {
    const { bauherrId } = req.params;
    
    const result = await query(
      `SELECT 
        n.*,
        CASE 
  WHEN n.type = 'new_offer' THEN (
    SELECT json_build_object(
      'company_name', h.company_name,
      'trade_name', t.name,
      'amount', o.amount,
      'project_name', p.description,
      'project_id', p.id
    )
    FROM offers o
    JOIN handwerker h ON o.handwerker_id = h.id
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    WHERE o.id = n.reference_id
  )
  WHEN n.type = 'offer_confirmed' THEN (
    SELECT json_build_object(
      'company_name', h.company_name,
      'trade_name', t.name,
      'project_name', p.description,
      'project_id', p.id
    )
    FROM offers o
    JOIN handwerker h ON o.handwerker_id = h.id
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    WHERE o.id = n.reference_id
  )
  WHEN n.type = 'appointment_request' THEN (
    SELECT json_build_object(
      'company_name', h.company_name,
      'proposed_date', ap.proposed_date,
      'trade_name', t.name,
      'project_name', p.description
    )
    FROM appointment_proposals ap
    JOIN offers o ON ap.offer_id = o.id
    JOIN handwerker h ON o.handwerker_id = h.id
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    WHERE ap.id = n.reference_id
  )
  WHEN n.type = 'offer_withdrawn' THEN (
    SELECT json_build_object(
      'company_name', h.company_name,
      'trade_name', t.name,
      'project_name', p.description
    )
    FROM offers o
    JOIN handwerker h ON o.handwerker_id = h.id
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    WHERE o.id = n.reference_id
  )
  WHEN n.type = 'message' OR n.type = 'message_from_handwerker' THEN (
    SELECT json_build_object(
      'sender_name', h.company_name,
      'project_name', p.description,
      'message_preview', LEFT(n.message, 50)
    )
    FROM messages m
    JOIN handwerker h ON m.sender_id = h.id AND m.sender_type = 'handwerker'
    JOIN conversations c ON m.conversation_id = c.id
    LEFT JOIN projects p ON c.project_id = p.id
    WHERE m.id = n.reference_id
  )
END as details
       FROM notifications n
       WHERE n.user_type = 'bauherr' 
       AND n.user_id = $1 
       ORDER BY n.created_at DESC 
       LIMIT 20`,
      [bauherrId]
    );
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error loading notifications:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Benachrichtigungen' });
  }
});

// Benachrichtigungen für Handwerker laden
app.get('/api/handwerker/:handwerkerId/notifications', async (req, res) => {
  try {
    const { handwerkerId } = req.params;
    
    const result = await query(
      `SELECT 
        n.*,
        CASE 
  WHEN n.type = 'new_tender' THEN (
    SELECT json_build_object(
      'trade_name', t.name,
      'project_zip', p.zip_code,
      'deadline', tn.deadline,
      'project_name', p.description,
      'project_id', p.id
    )
    FROM tenders tn
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    WHERE tn.id = n.reference_id
  )
  WHEN n.type = 'preliminary_accepted' THEN (
    SELECT json_build_object(
      'trade_name', t.name,
      'bauherr_name', b.name,
      'project_name', p.description,
      'project_id', p.id
    )
    FROM offers o
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    JOIN bauherren b ON p.bauherr_id = b.id
    WHERE o.id = n.reference_id
  )
  WHEN n.type = 'offer_rejected' THEN (
    SELECT json_build_object(
      'trade_name', t.name,
      'bauherr_name', b.name,
      'project_name', p.description,
      'reason', n.metadata->>'reason'
    )
    FROM offers o
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    JOIN bauherren b ON p.bauherr_id = b.id
    WHERE o.id = n.reference_id
  )
  WHEN n.type = 'awarded' THEN (
    SELECT json_build_object(
      'trade_name', t.name,
      'amount', ord.amount,
      'project_name', p.description,
      'bauherr_name', b.name
    )
    FROM orders ord
    JOIN trades t ON ord.trade_id = t.id
    JOIN projects p ON ord.project_id = p.id
    JOIN bauherren b ON ord.bauherr_id = b.id
    WHERE ord.id = n.reference_id
  )
  WHEN n.type = 'not_selected' THEN (
    SELECT json_build_object(
      'trade_name', t.name,
      'project_name', p.description,
      'bauherr_name', b.name
    )
    FROM offers o
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    JOIN bauherren b ON p.bauherr_id = b.id
    WHERE o.id = n.reference_id
  )
  WHEN n.type = 'message' OR n.type = 'message_from_bauherr' THEN (
    SELECT json_build_object(
      'sender_name', b.name,
      'bauherr_name', b.name,
      'project_name', p.description,
      'message_preview', LEFT(n.message, 50)
    )
    FROM messages m
    JOIN bauherren b ON m.sender_id = b.id AND m.sender_type = 'bauherr'
    JOIN conversations c ON m.conversation_id = c.id
    LEFT JOIN projects p ON c.project_id = p.id
    WHERE m.id = n.reference_id
  )
  WHEN n.type = 'appointment_confirmed' THEN (
    SELECT json_build_object(
      'bauherr_name', b.name,
      'trade_name', t.name,
      'project_name', p.description,
      'confirmed_date', ap.confirmed_date
    )
    FROM appointment_proposals ap
    JOIN offers o ON ap.offer_id = o.id
    JOIN tenders tn ON o.tender_id = tn.id
    JOIN trades t ON tn.trade_id = t.id
    JOIN projects p ON tn.project_id = p.id
    JOIN bauherren b ON p.bauherr_id = b.id
    WHERE ap.id = n.reference_id
  )
END as details
       FROM notifications n
       WHERE n.user_type = 'handwerker' 
       AND n.user_id = $1 
       ORDER BY n.created_at DESC 
       LIMIT 20`,
      [handwerkerId]
    );
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error loading notifications:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Benachrichtigungen' });
  }
});

// Benachrichtigung als gelesen markieren
app.post('/api/notifications/:notificationId/mark-read', async (req, res) => {
  try {
    await query(
      `UPDATE notifications 
       SET read = true, read_at = NOW() 
       WHERE id = $1`,
      [req.params.notificationId]
    );
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// Alle Benachrichtigungen als gelesen markieren
app.post('/api/notifications/mark-all-read', async (req, res) => {
  try {
    const { userType, userId } = req.body;
    
    await query(
      `UPDATE notifications 
       SET read = true, read_at = NOW() 
       WHERE user_type = $1 AND user_id = $2 AND read = false`,
      [userType, userId]
    );
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// Benachrichtigung löschen
app.delete('/api/notifications/:notificationId', async (req, res) => {
  try {
    await query('DELETE FROM notifications WHERE id = $1', [req.params.notificationId]);
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// ============= NACHRICHTENSYSTEM =============

// Konversationen für User laden
app.get('/api/user-conversations/:userType/:userId', async (req, res) => {
  try {
    const { userType, userId } = req.params;
    
    const result = await query(
  `SELECT
    c.id,
    c.type,
    c.project_id,
    c.offer_id,
    c.created_at,
    c.updated_at,
    CASE 
      WHEN c.type = 'direct' THEN (
            CASE 
              WHEN $1 = 'bauherr' THEN (
                SELECT json_build_object(
                  'id', h.id,
                  'name', h.company_name,
                  'type', 'handwerker'
                )
                FROM conversation_participants cp
                JOIN handwerker h ON cp.user_id = h.id
                WHERE cp.conversation_id = c.id 
                  AND cp.user_type = 'handwerker'
                LIMIT 1
              )
              ELSE (
                SELECT json_build_object(
                  'id', b.id,
                  'name', b.name,
                  'type', 'bauherr'
                )
                FROM conversation_participants cp
                JOIN bauherren b ON cp.user_id = b.id
                WHERE cp.conversation_id = c.id 
                  AND cp.user_type = 'bauherr'
                LIMIT 1
              )
            END
          )
          WHEN c.type = 'project_group' THEN (
  SELECT json_build_object(
    'project_id', c.project_id,
    'title', COALESCE(p.category || ' - ' || p.description, p.description),
    'member_count', (
      SELECT COUNT(*) 
      FROM conversation_participants 
      WHERE conversation_id = c.id
    )
  )
  FROM projects p
  WHERE p.id = c.project_id
)
          WHEN c.type = 'handwerker_coordination' THEN (
  SELECT json_build_object(
    'project_id', c.project_id,
    'project_title', COALESCE(p.category || ' - ' || p.description, p.description),
    'member_count', (
      SELECT COUNT(*) 
      FROM conversation_participants 
      WHERE conversation_id = c.id
    ),
    'handwerker_count', (
      SELECT COUNT(*) 
      FROM conversation_participants 
      WHERE conversation_id = c.id AND user_type = 'handwerker'
    )
  )
  FROM projects p
  WHERE p.id = c.project_id
)
        END as conversation_info,
        (
          SELECT json_build_object(
            'text', m.message,
            'sender_name', 
              CASE 
                WHEN m.sender_type = 'bauherr' THEN b.name
                WHEN m.sender_type = 'handwerker' THEN h.company_name
              END,
            'sent_at', m.created_at
          )
          FROM messages m
          LEFT JOIN bauherren b ON m.sender_type = 'bauherr' AND m.sender_id = b.id
          LEFT JOIN handwerker h ON m.sender_type = 'handwerker' AND m.sender_id = h.id
          WHERE m.conversation_id = c.id
          ORDER BY m.created_at DESC
          LIMIT 1
        ) as last_message,
        (
          SELECT COUNT(*)
          FROM messages m
          WHERE m.conversation_id = c.id
            AND m.read = false
            AND NOT (m.sender_type = $1 AND m.sender_id = $2)
        ) as unread_count
       FROM conversations c
       JOIN conversation_participants cp ON c.id = cp.conversation_id
       WHERE cp.user_type = $1 AND cp.user_id = $2
       ORDER BY c.updated_at DESC`,
      [userType, userId]
    );
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error loading conversations:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Konversationen' });
  }
});

// Nachrichten einer Konversation laden
app.get('/api/messages/:conversationId', async (req, res) => {
  try {
    const { conversationId } = req.params;
    const { limit = 50, before } = req.query;
    
    let query_text = `
      SELECT 
        m.*,
        CASE 
          WHEN m.sender_type = 'bauherr' THEN b.name
          WHEN m.sender_type = 'handwerker' THEN h.company_name
        END as sender_name
      FROM messages m
      LEFT JOIN bauherren b ON m.sender_type = 'bauherr' AND m.sender_id = b.id
      LEFT JOIN handwerker h ON m.sender_type = 'handwerker' AND m.sender_id = h.id
      WHERE m.conversation_id = $1`;
    
    const params = [conversationId];
    
    if (before) {
      query_text += ` AND m.created_at < $2`;
      params.push(before);
    }
    
    query_text += ` ORDER BY m.created_at DESC LIMIT $${params.length + 1}`;
    params.push(limit);
    
    const result = await query(query_text, params);
    
    res.json(result.rows.reverse());
  } catch (error) {
    console.error('Error loading messages:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Nachrichten' });
  }
});

// Nachricht senden
app.post('/api/conversations/:conversationId/messages', async (req, res) => {
  try {
    const { conversationId } = req.params;
    const { senderType, senderId, message, attachments } = req.body;
    
    await query('BEGIN');
    
    // Nachricht einfügen
    const result = await query(
      `INSERT INTO messages 
       (conversation_id, sender_type, sender_id, message, attachments, created_at)
       VALUES ($1, $2, $3, $4, $5, NOW())
       RETURNING *`,
      [conversationId, senderType, senderId, message, JSON.stringify(attachments || [])]
    );
    
    // Conversation aktualisieren
    await query(
      `UPDATE conversations 
       SET updated_at = NOW() 
       WHERE id = $1`,
      [conversationId]
    );
    
    // Benachrichtigungen für andere Teilnehmer erstellen
    const participants = await query(
      `SELECT user_type, user_id 
       FROM conversation_participants 
       WHERE conversation_id = $1 
         AND NOT (user_type = $2 AND user_id = $3)`,
      [conversationId, senderType, senderId]
    );
    
    for (const participant of participants.rows) {
  // Hole Sender-Informationen und Projekt-Details
  const senderInfo = await query(
    `SELECT 
      CASE 
        WHEN $1 = 'bauherr' THEN b.name
        WHEN $1 = 'handwerker' THEN h.company_name
      END as sender_name,
      p.description as project_name
     FROM conversations c
     LEFT JOIN projects p ON c.project_id = p.id
     LEFT JOIN bauherren b ON b.id = $2 AND $1 = 'bauherr'
     LEFT JOIN handwerker h ON h.id = $2 AND $1 = 'handwerker'
     WHERE c.id = $3`,
    [senderType, senderId, conversationId]
  );
  
  const notificationType = senderType === 'bauherr' ? 'message_from_bauherr' : 'message_from_handwerker';
  
  await query(
    `INSERT INTO notifications 
     (user_type, user_id, type, reference_id, message, metadata, created_at)
     VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
    [
      participant.user_type,
      participant.user_id,
      notificationType,
      result.rows[0].id,
      `Neue Nachricht erhalten`,
      JSON.stringify({
        sender_name: senderInfo.rows[0]?.sender_name || 'Unbekannt',
        project_name: senderInfo.rows[0]?.project_name || 'Projekt',
        message_preview: message.substring(0, 50)
      })
    ]
  );
}
    
    await query('COMMIT');
    
    res.json(result.rows[0]);
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error sending message:', error);
    res.status(500).json({ error: 'Fehler beim Senden der Nachricht' });
  }
});

// Nachrichten als gelesen markieren
app.post('/api/conversations/:conversationId/mark-read', async (req, res) => {
  try {
    const { conversationId } = req.params;
    const { userType, userId } = req.body;
    
    await query(
      `UPDATE messages 
       SET read = true, read_at = NOW()
       WHERE conversation_id = $1 
         AND NOT (sender_type = $2 AND sender_id = $3)
         AND read = false`,
      [conversationId, userType, userId]
    );
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error marking as read:', error);
    res.status(500).json({ error: 'Fehler' });
  }
});

// Konversation erstellen/finden (Direct Message)
app.post('/api/conversations/direct', async (req, res) => {
  try {
    const { user1Type, user1Id, user2Type, user2Id, offerId } = req.body;
    
    await query('BEGIN');
    
    // Prüfe ob Konversation bereits existiert
    const existing = await query(
      `SELECT c.id 
       FROM conversations c
       JOIN conversation_participants cp1 ON c.id = cp1.conversation_id
       JOIN conversation_participants cp2 ON c.id = cp2.conversation_id
       WHERE c.type = 'direct'
         AND cp1.user_type = $1 AND cp1.user_id = $2
         AND cp2.user_type = $3 AND cp2.user_id = $4`,
      [user1Type, user1Id, user2Type, user2Id]
    );
    
    if (existing.rows.length > 0) {
      await query('COMMIT');
      return res.json({ conversationId: existing.rows[0].id });
    }
    
    // Neue Konversation erstellen
    const convResult = await query(
      `INSERT INTO conversations (type, offer_id, created_at, updated_at)
       VALUES ('direct', $1, NOW(), NOW())
       RETURNING id`,
      [offerId]
    );
    
    const conversationId = convResult.rows[0].id;
    
    // Teilnehmer hinzufügen
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id)
       VALUES ($1, $2, $3), ($1, $4, $5)`,
      [conversationId, user1Type, user1Id, user2Type, user2Id]
    );
    
    await query('COMMIT');
    
    res.json({ conversationId });
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error creating conversation:', error);
    res.status(500).json({ error: 'Fehler beim Erstellen der Konversation' });
  }
});

// Projekt-Gruppenkonversation erstellen (automatisch bei Beauftragung)
app.post('/api/conversations/project-group', async (req, res) => {
  try {
    const { projectId, bauherrId } = req.body;
    
    await query('BEGIN');
    
    // Prüfe ob bereits existiert
    const existing = await query(
      `SELECT id FROM conversations 
       WHERE type = 'project_group' AND project_id = $1`,
      [projectId]
    );
    
    if (existing.rows.length > 0) {
      await query('COMMIT');
      return res.json({ conversationId: existing.rows[0].id });
    }
    
    // Neue Projekt-Gruppe erstellen
    const convResult = await query(
      `INSERT INTO conversations (type, project_id, created_at, updated_at)
       VALUES ('project_group', $1, NOW(), NOW())
       RETURNING id`,
      [projectId]
    );
    
    const conversationId = convResult.rows[0].id;
    
    // Bauherr hinzufügen
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id)
       VALUES ($1, 'bauherr', $2)`,
      [conversationId, bauherrId]
    );
    
    // Alle beauftragten Handwerker hinzufügen
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id)
       SELECT $1, 'handwerker', DISTINCT o.handwerker_id
       FROM orders o
       WHERE o.project_id = $2`,
      [conversationId, projectId]
    );
    
    await query('COMMIT');
    
    res.json({ conversationId });
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error creating project group:', error);
    res.status(500).json({ error: 'Fehler' });
  }
});

// Handwerker-Koordinations-Chat erstellen (MIT Bauherr als stiller Beobachter)
app.post('/api/conversations/handwerker-coordination', async (req, res) => {
  try {
    const { projectId, bauherrId } = req.body;
    
    await query('BEGIN');
    
    // Prüfe ob bereits existiert
    const existing = await query(
      `SELECT id FROM conversations 
       WHERE type = 'handwerker_coordination' AND project_id = $1`,
      [projectId]
    );
    
    if (existing.rows.length > 0) {
      await query('COMMIT');
      return res.json({ conversationId: existing.rows[0].id });
    }
    
    // Neue Koordinations-Gruppe erstellen
    const convResult = await query(
      `INSERT INTO conversations (type, project_id, created_at, updated_at)
       VALUES ('handwerker_coordination', $1, NOW(), NOW())
       RETURNING id`,
      [projectId]
    );
    
    const conversationId = convResult.rows[0].id;
    
    // ═══════════════════════════════════════════════════════════════
    // NEU: Bauherr auch hinzufügen (als Beobachter/Moderator)
    // ═══════════════════════════════════════════════════════════════
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
       VALUES ($1, 'bauherr', $2, 'observer')`,
      [conversationId, bauherrId]
    );
    
    // Alle beauftragten Handwerker hinzufügen
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
       SELECT $1, 'handwerker', DISTINCT o.handwerker_id, 'participant'
       FROM orders o
       WHERE o.project_id = $2`,
      [conversationId, projectId]
    );
    
    await query('COMMIT');
    
    res.json({ conversationId });
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error creating coordination chat:', error);
    res.status(500).json({ error: 'Fehler' });
  }
});

// Handwerker zu Gruppenkonversationen hinzufügen (bei neuer Beauftragung)
app.post('/api/conversations/add-handwerker', async (req, res) => {
  try {
    const { projectId, handwerkerId } = req.body;
    
    await query('BEGIN');
    
    // Zu Projekt-Gruppe hinzufügen
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
       SELECT c.id, 'handwerker', $2, 'participant'
       FROM conversations c
       WHERE c.type = 'project_group' AND c.project_id = $1
       ON CONFLICT (conversation_id, user_type, user_id) DO NOTHING`,
      [projectId, handwerkerId]
    );
    
    // Zu Handwerker-Koordination hinzufügen
    await query(
      `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
       SELECT c.id, 'handwerker', $2, 'participant'
       FROM conversations c
       WHERE c.type = 'handwerker_coordination' AND c.project_id = $1
       ON CONFLICT (conversation_id, user_type, user_id) DO NOTHING`,
      [projectId, handwerkerId]
    );
    
    await query('COMMIT');
    
    res.json({ success: true });
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error adding handwerker:', error);
    res.status(500).json({ error: 'Fehler' });
  }
});

// Bauherr Settings Endpoints

// Get Bauherr Settings
app.get('/api/bauherr/:id/settings', async (req, res) => {
  try {
    const result = await query(
      `SELECT * FROM bauherren WHERE id = $1`,
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Bauherr nicht gefunden' });
    }
    
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Error fetching settings:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Einstellungen' });
  }
});

// Update Personal Data
app.put('/api/bauherr/:id/personal', async (req, res) => {
  try {
    const { name, email, phone, street, houseNumber, zipCode, city } = req.body;
    
    await query(
      `UPDATE bauherren SET
        name = $2,
        email = $3,
        phone = $4,
        street = $5,
        house_number = $6,
        zip = $7,
        city = $8,
        updated_at = NOW()
       WHERE id = $1`,
      [req.params.id, name, email, phone, street, houseNumber, zipCode, city]
    );
    
    res.json({ success: true });
  } catch (err) {
    console.error('Error updating personal data:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Update Notifications
app.put('/api/bauherr/:id/notifications', async (req, res) => {
  try {
    await query(
      `UPDATE bauherren SET
        notification_settings = $2,
        updated_at = NOW()
       WHERE id = $1`,
      [req.params.id, JSON.stringify(req.body)]
    );
    
    res.json({ success: true });
  } catch (err) {
    console.error('Error updating notifications:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Change Password
app.put('/api/bauherr/:id/password', async (req, res) => {
  try {
    const { currentPassword, newPassword } = req.body;
    
    // Get current password hash
    const result = await query(
      'SELECT password_hash FROM bauherren WHERE id = $1',
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Bauherr nicht gefunden' });
    }
    
    // Verify current password
    const isValid = await bcryptjs.compare(currentPassword, result.rows[0].password_hash);
    if (!isValid) {
      return res.status(401).json({ error: 'Falsches Passwort' });
    }
    
    // Hash new password
    const hashedPassword = await bcryptjs.hash(newPassword, 10);
    
    // Update password
    await query(
      `UPDATE bauherren SET
        password_hash = $2,
        updated_at = NOW()
       WHERE id = $1`,
      [req.params.id, hashedPassword]
    );
    
    res.json({ success: true });
  } catch (err) {
    console.error('Error changing password:', err);
    res.status(500).json({ error: 'Passwortänderung fehlgeschlagen' });
  }
});

// Toggle Two-Factor
app.put('/api/bauherr/:id/two-factor', async (req, res) => {
  try {
    const { enabled } = req.body;
    
    await query(
      `UPDATE bauherren SET
        two_factor_enabled = $2,
        updated_at = NOW()
       WHERE id = $1`,
      [req.params.id, enabled]
    );
    
    res.json({ success: true });
  } catch (err) {
    console.error('Error toggling 2FA:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Export Data
app.get('/api/bauherr/:id/export', async (req, res) => {
  try {
    // Get all user data
    const bauherrResult = await query('SELECT * FROM bauherren WHERE id = $1', [req.params.id]);
    const projectsResult = await query('SELECT * FROM projects WHERE bauherr_id = $1', [req.params.id]);
    
    const exportData = {
      personal: bauherrResult.rows[0],
      projects: projectsResult.rows,
      exportDate: new Date().toISOString()
    };
    
    res.setHeader('Content-Type', 'application/json');
    res.setHeader('Content-Disposition', 'attachment; filename="byndl-export.json"');
    res.json(exportData);
  } catch (err) {
    console.error('Error exporting data:', err);
    res.status(500).json({ error: 'Export fehlgeschlagen' });
  }
});

// Delete Account
app.delete('/api/bauherr/:id/account', async (req, res) => {
  try {
    const { password } = req.body;
    
    // Verify password
    const result = await query(
      'SELECT password_hash FROM bauherren WHERE id = $1',
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Account nicht gefunden' });
    }
    
    const isValid = await bcryptjs.compare(password, result.rows[0].password_hash);
    if (!isValid) {
      return res.status(401).json({ error: 'Falsches Passwort' });
    }
    
    // Delete all related data
    await query('BEGIN');
    
    // Delete projects and all related data
    const projects = await query('SELECT id FROM projects WHERE bauherr_id = $1', [req.params.id]);
    for (const project of projects.rows) {
      await query('DELETE FROM questions WHERE project_id = $1', [project.id]);
      await query('DELETE FROM project_trades WHERE project_id = $1', [project.id]);
      await query('DELETE FROM lvs WHERE project_id = $1', [project.id]);
      await query('DELETE FROM tenders WHERE project_id = $1', [project.id]);
    }
    
    await query('DELETE FROM projects WHERE bauherr_id = $1', [req.params.id]);
    await query('DELETE FROM bauherren WHERE id = $1', [req.params.id]);
    
    await query('COMMIT');
    
    res.json({ success: true });
  } catch (err) {
    await query('ROLLBACK');
    console.error('Error deleting account:', err);
    res.status(500).json({ error: 'Account-Löschung fehlgeschlagen' });
  }
});

// Delete Project
app.delete('/api/projects/:id', async (req, res) => {
  try {
    await query('BEGIN');
    
    // Delete all related data
    await query('DELETE FROM file_uploads WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM questions WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM answers WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM project_trades WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM lvs WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM tenders WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM trade_progress WHERE project_id = $1', [req.params.id]);
    await query('DELETE FROM projects WHERE id = $1', [req.params.id]);
    
    await query('COMMIT');
    
    res.json({ success: true });
  } catch (err) {
    await query('ROLLBACK');
    console.error('Error deleting project:', err);
    res.status(500).json({ error: 'Projekt-Löschung fehlgeschlagen' });
  }
});

// 5. HANDWERKER DASHBOARD ROUTES
// ----------------------------------------------------------------------------

// KORRIGIERTE ROUTE für abgegebene Angebote
app.get('/api/handwerker/:identifier/offers', async (req, res) => {
  try {
    const { identifier } = req.params;
    let handwerkerId;
    
    // Flexible ID-Erkennung
    if (/^\d+$/.test(identifier)) {
      handwerkerId = parseInt(identifier);
    } else {
      const result = await query(
        'SELECT id FROM handwerker WHERE company_id = $1',
        [identifier]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Handwerker nicht gefunden' });
      }
      handwerkerId = result.rows[0].id;
    }
    
    const result = await query(
      `SELECT 
        o.*, 
        t.name as trade, 
        p.description as projectType, 
        p.zip_code || ' ' || p.city as location,
        o.created_at as submittedDate,
        o.status,
        o.amount,
        o.viewed_at,
        CASE 
          WHEN o.status = 'submitted' THEN 'Vorläufiges Angebot'
          WHEN o.status = 'confirmed' THEN 'Verbindliches Angebot'
          WHEN o.status = 'preliminary' THEN 'Vorläufig beauftragt'
          ELSE o.status
        END as status_text
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       JOIN projects p ON tn.project_id = p.id
       WHERE o.handwerker_id = $1
         AND o.status IN ('submitted', 'confirmed')
         AND o.status NOT IN ('preliminary', 'accepted', 'withdrawn')
       ORDER BY o.created_at DESC`,
      [handwerkerId]  // WICHTIG: handwerkerId statt companyId
    );
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching handwerker offers:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Angebote' });
  }
});

// Vertragsanbahnungen für Handwerker
app.get('/api/handwerker/:identifier/contracts', async (req, res) => {
  try {
    const { identifier } = req.params;
    let handwerkerId;
    
    // Flexible ID-Erkennung
    if (/^\d+$/.test(identifier)) {
      handwerkerId = parseInt(identifier);
    } else {
      const result = await query(
        'SELECT id FROM handwerker WHERE company_id = $1',
        [identifier]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Handwerker nicht gefunden' });
      }
      handwerkerId = result.rows[0].id;
    }
    
    console.log('🔴 Loading contracts für Handwerker:', handwerkerId);
    
    const result = await query(
  `SELECT 
    t.id as tender_id,
    t.deadline,
    t.timeframe,
    tr.name as trade_name,
    tr.code as trade_code,
    p.id as project_id,
    p.category as project_category,
    p.sub_category as project_sub_category,
    p.description as project_description,
    p.street,
    p.house_number,
    p.zip_code,
    p.city,
    p.street || ' ' || p.house_number || ', ' || p.zip_code || ' ' || p.city as project_address,
    b.name as bauherr_name,
    b.email as bauherr_email,
    b.phone as bauherr_phone,
    b.address as bauherr_address,
    o.id as offer_id,
    o.amount as offer_amount,
    o.bundle_discount, 
    o.status as offer_status,
    o.preliminary_accepted_at,
    o.offer_confirmed_at,
    o.notes as offer_notes,
    o.execution_start,
    o.execution_end,
    o.lv_data
   FROM offers o
   JOIN tenders t ON o.tender_id = t.id
   JOIN trades tr ON t.trade_id = tr.id
   JOIN projects p ON t.project_id = p.id
   JOIN bauherren b ON p.bauherr_id = b.id
   WHERE o.handwerker_id = $1
   AND (o.status = 'preliminary' OR o.status = 'confirmed')
   AND NOT EXISTS (
   SELECT 1 FROM orders WHERE offer_id = o.id
  )  
  ORDER BY o.preliminary_accepted_at DESC`,
  [handwerkerId]
);
    
    console.log('🔴 Contracts gefunden:', result.rows.length);
    console.log('🔴 Daten:', result.rows);
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching contracts:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Vertragsanbahnungen' });
  }
});

// Withdraw offer
app.post('/api/offers/:offerId/withdraw', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    await query(
      `UPDATE offers SET status = 'withdrawn', withdrawn_at = NOW() WHERE id = $1`,
      [offerId]
    );
    
    res.json({ success: true, message: 'Angebot zurückgezogen' });
    
  } catch (error) {
    console.error('Error withdrawing offer:', error);
    res.status(500).json({ error: 'Fehler beim Zurückziehen' });
  }
});

// Detailliertes Angebot für Handwerker abrufen (View-Only)
app.get('/api/offers/:offerId/details', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        t.name as trade_name,
        tn.id as tender_id,
        tn.deadline,
        tn.timeframe,
        p.description as project_description,
        p.category as project_category,
        p.sub_category as project_sub_category,
        p.zip_code || ' ' || p.city as project_location,
        p.street || ' ' || p.house_number as project_address
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       JOIN projects p ON tn.project_id = p.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Angebot nicht gefunden' });
    }
    
    const offer = result.rows[0];
    
    // Parse LV-Daten
    if (typeof offer.lv_data === 'string') {
      offer.lv_data = JSON.parse(offer.lv_data);
    }
    
    res.json(offer);
    
  } catch (error) {
    console.error('Error fetching offer details:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Angebotsdetails' });
  }
});

// Angebot zurückziehen und zur Bearbeitung freigeben
app.post('/api/offers/:offerId/withdraw-for-edit', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { handwerkerId } = req.body;
    
    await query('BEGIN');
    
    // Status auf 'withdrawn' setzen
    await query(
      `UPDATE offers 
       SET status = 'withdrawn', 
           withdrawn_at = NOW(),
           updated_at = NOW()
       WHERE id = $1`,
      [offerId]
    );
    
    // Tender-Handwerker Status zurücksetzen (damit es wieder unter Ausschreibungen erscheint)
    const tenderResult = await query(
      'SELECT tender_id FROM offers WHERE id = $1',
      [offerId]
    );
    
    if (tenderResult.rows.length > 0) {
      const tenderId = tenderResult.rows[0].tender_id;
      
      await query(
        `UPDATE tender_handwerker 
         SET status = 'pending'
         WHERE tender_id = $1 AND handwerker_id = $2`,
        [tenderId, handwerkerId]
      );
    }
    
    await query('COMMIT');
    
    res.json({ 
      success: true, 
      message: 'Angebot zurückgezogen. Sie können es nun erneut bearbeiten.' 
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error withdrawing offer for edit:', error);
    res.status(500).json({ error: 'Fehler beim Zurückziehen' });
  }
});

// Zurückgezogene Angebote für Bauherr-Benachrichtigung
app.get('/api/projects/:projectId/withdrawn-offers', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        h.company_name,
        t.name as trade_name,
        o.withdrawn_at
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE tn.project_id = $1 
         AND o.status = 'withdrawn'
         AND o.withdrawn_at > NOW() - INTERVAL '7 days'
       ORDER BY o.withdrawn_at DESC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching withdrawn offers:', error);
    res.status(500).json({ error: 'Fehler beim Laden' });
  }
});

// Angebot verbindlich bestätigen (nach Ortstermin)
app.post('/api/offers/:offerId/confirm-final', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { 
      amount, 
      bundle_discount, 
      execution_start, 
      execution_end, 
      notes, 
      lv_data,
      schedule_phases,
      schedule_change_reason,
      has_schedule_changes
    } = req.body;

    console.log('EMPFANGEN - Offer ID:', offerId);
    console.log('EMPFANGEN - Amount:', amount);
    console.log('EMPFANGEN - LV_DATA vorhanden?:', !!lv_data);

    // ✅ NEU: Schedule-Daten loggen
console.log('🔍 SCHEDULE DEBUG:', {
  has_schedule_changes,
  schedule_phases_count: schedule_phases?.length,
  schedule_change_reason
});
    
    await query('BEGIN');
    
    // Update Offer MIT lv_data
    await query(
  `UPDATE offers 
   SET status = 'confirmed',
       amount = $2,
       bundle_discount = $3,
       execution_start = $4,
       execution_end = $5,
       notes = $6,
       lv_data = $7,
       offer_confirmed_at = NOW(),
       updated_at = NOW()
   WHERE id = $1`,
  [offerId, amount, bundle_discount, execution_start, execution_end, notes, JSON.stringify(lv_data)]
);

// NEU: Terminplan-Änderungen verarbeiten
if (schedule_phases && schedule_phases.length > 0) {
  const offerInfo = await query(
    'SELECT handwerker_id, tender_id FROM offers WHERE id = $1',
    [offerId]
  );
  
  if (offerInfo.rows.length > 0) {
    const handwerkerId = offerInfo.rows[0].handwerker_id;
    const tenderId = offerInfo.rows[0].tender_id;
    
    for (const phase of schedule_phases) {
  // ✅ Validiere dass Phase existiert
  const phaseCheck = await query(
        'SELECT id FROM schedule_entries WHERE id = $1',
        [phase.id]
      );
      
      if (phaseCheck.rows.length === 0) {
        throw new Error(`Invalid phase ID: ${phase.id}`);
      }
  
  // ✅ Detailliertes Logging
  console.log('📅 Processing phase:', {
    id: phase.id,
    old_start: phase.original_start || 'from_db',
    new_start: phase.planned_start,
    has_changes: has_schedule_changes
  });
  
  if (has_schedule_changes) {
    // ✅ Hole alte Werte aus DB VOR dem Update
    const oldPhaseData = await query(
      'SELECT planned_start, planned_end FROM schedule_entries WHERE id = $1',
      [phase.id]
    );
    
    const oldStart = phase.original_start || oldPhaseData.rows[0]?.planned_start;
    const oldEnd = phase.original_end || oldPhaseData.rows[0]?.planned_end;
    
    // ✅ Termine SOFORT in DB ändern
    await query(
      `UPDATE schedule_entries 
       SET planned_start = $2,
           planned_end = $3,
           status = 'change_requested',
           updated_at = NOW()
       WHERE id = $1`,
      [phase.id, phase.planned_start, phase.planned_end]
    );
    
    // ✅ History speichern mit Fallback
    await query(
      `INSERT INTO schedule_history 
       (schedule_entry_id, changed_by_type, changed_by_id, change_type,
        old_start, old_end, new_start, new_end, reason, created_at)
       VALUES ($1, 'handwerker', $2, 'date_change', $3, $4, $5, $6, $7, NOW())`,
      [
        phase.id, 
        handwerkerId, 
        oldStart,
        oldEnd,
        phase.planned_start,
        phase.planned_end,
        schedule_change_reason
      ]
    );
  } else {
    // ✅ Bestätigt ohne Änderung
    await query(
      `UPDATE schedule_entries
       SET confirmed = true,
           confirmed_by = $2,
           confirmed_at = NOW(),
           status = 'confirmed',
           updated_at = NOW()
       WHERE id = $1`,
      [phase.id, handwerkerId]
    );
  }
}

    // ✅ NEU: Update offers mit den neuesten Schedule-Terminen
    if (schedule_phases && schedule_phases.length > 0) {
      const newExecutionStart = schedule_phases[0].planned_start;
      const newExecutionEnd = schedule_phases[schedule_phases.length - 1].planned_end;
      
      await query(
        `UPDATE offers 
         SET execution_start = $2,
             execution_end = $3
         WHERE id = $1`,
        [offerId, newExecutionStart, newExecutionEnd]
      );
    }
    
    // Notification an Bauherr (NUR bei Änderungen!)
    if (has_schedule_changes) {
      const projectInfo = await query(
        `SELECT p.bauherr_id, t.name as trade_name
         FROM offers o
         JOIN tenders tn ON o.tender_id = tn.id
         JOIN projects p ON tn.project_id = p.id
         JOIN trades t ON tn.trade_id = t.id
         WHERE o.id = $1`,
        [offerId]
      );
      
      if (projectInfo.rows.length > 0) {
        const tradeName = projectInfo.rows[0].trade_name;
        
        // ✅ Notification mit Begründung
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
           VALUES ('bauherr', $1, 'schedule_change_request', $2, 'offer', $3, $4, NOW())`,
          [
            projectInfo.rows[0].bauherr_id,
            `Handwerker hat Terminänderung für ${tradeName} vorgeschlagen`,
            offerId,
            JSON.stringify({
              reason: schedule_change_reason,
              offer_id: offerId,
              trade_name: tradeName
            })
          ]
        );
      }
    }
  }
}

    // Benachrichtige Bauherr
    const offerData = await query(
      `SELECT o.*, b.email, b.name, t.name as trade_name, h.company_name
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON tn.trade_id = t.id
       JOIN handwerker h ON o.handwerker_id = h.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (offerData.rows.length > 0 && transporter) {
      const offer = offerData.rows[0];
      await transporter.sendMail({
        from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
        to: offer.email,
        subject: `Angebot bestätigt - ${offer.trade_name}`,
        html: `
          <h2>Angebot wurde bestätigt</h2>
          <p>Gute Nachrichten! <strong>${offer.company_name}</strong> hat das Angebot für <strong>${offer.trade_name}</strong> nach dem Ortstermin verbindlich bestätigt.</p>
          <p><strong>Angebotssumme:</strong> ${amount.toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}</p>
          <p><strong>Ausführung:</strong> ${new Date(execution_start).toLocaleDateString('de-DE')} bis ${new Date(execution_end).toLocaleDateString('de-DE')}</p>
          ${notes ? `<p><strong>Anmerkungen:</strong> ${notes}</p>` : ''}
          <p>Sie können das Angebot nun verbindlich beauftragen.</p>
          <a href="https://byndl.de/bauherr/dashboard">Zum Dashboard</a>
        `
      });
    }
    
    await query('COMMIT');
    
    res.json({ success: true });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================================
// TERMINÄNDERUNG AKZEPTIEREN (Bauherr)
// ============================================================================
app.post('/api/schedule-changes/:entryId/accept', async (req, res) => {
  try {
    const { entryId } = req.params;
    const { bauherrId } = req.body;
    
    console.log('✅ Bauherr akzeptiert Terminänderung für Entry:', entryId);
    
    await query('BEGIN');
    
    // 1. Update Schedule Entry Status
    await query(
      `UPDATE schedule_entries 
       SET status = 'confirmed',
           confirmed = true,
           confirmed_by = $2,
           confirmed_at = NOW(),
           updated_at = NOW()
       WHERE id = $1`,
      [entryId, bauherrId]
    );
    
    // 2. Hole Handwerker-Info für Notification
    const entryInfo = await query(
      `SELECT 
         se.trade_id,
         t.name as trade_name,
         se.planned_start,
         se.planned_end,
         o.handwerker_id,
         h.company_name
       FROM schedule_entries se
       JOIN trades t ON se.trade_id = t.id
       LEFT JOIN tenders tn ON tn.trade_id = se.trade_id
       LEFT JOIN offers o ON o.tender_id = tn.id AND o.status IN ('confirmed', 'accepted')
       LEFT JOIN handwerker h ON o.handwerker_id = h.id
       WHERE se.id = $1`,
      [entryId]
    );
    
    if (entryInfo.rows.length > 0) {
      const info = entryInfo.rows[0];
      
      // 3. Notification an Handwerker
      if (info.handwerker_id) {
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
           VALUES ('handwerker', $1, 'schedule_change_accepted', $2, 'schedule_entry', $3, $4, NOW())`,
          [
            info.handwerker_id,
            `Bauherr hat Ihre Terminänderung für ${info.trade_name} akzeptiert`,
            entryId,
            JSON.stringify({
              trade_name: info.trade_name,
              new_start: info.planned_start,
              new_end: info.planned_end
            })
          ]
        );
      }
    }
    
    await query('COMMIT');
    
    console.log('✅ Terminänderung akzeptiert');
    
    res.json({ 
      success: true,
      message: 'Terminänderung wurde akzeptiert'
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('❌ Error accepting schedule change:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================================
// TERMINÄNDERUNG ABLEHNEN (Bauherr)
// ============================================================================
app.post('/api/schedule-changes/:entryId/reject', async (req, res) => {
  try {
    const { entryId } = req.params;
    const { bauherrId, reason } = req.body;
    
    console.log('❌ Bauherr lehnt Terminänderung ab für Entry:', entryId);
    
    await query('BEGIN');
    
    // 1. Hole Original-Termine aus History
    const historyResult = await query(
      `SELECT old_start, old_end 
       FROM schedule_history 
       WHERE schedule_entry_id = $1 
       AND change_type = 'date_change'
       ORDER BY created_at DESC 
       LIMIT 1`,
      [entryId]
    );
    
    if (historyResult.rows.length === 0) {
      await query('ROLLBACK');
      return res.status(400).json({ error: 'Keine History gefunden für diese Terminänderung' });
    }
    
    const { old_start, old_end } = historyResult.rows[0];
    
    console.log('🔄 Restore Termine:', old_start, '→', old_end);
    
    // 2. Restore Original-Termine
    await query(
      `UPDATE schedule_entries
       SET planned_start = $2,
           planned_end = $3,
           status = 'pending',
           confirmed = false,
           confirmed_by = NULL,
           confirmed_at = NULL,
           updated_at = NOW()
       WHERE id = $1`,
      [entryId, old_start, old_end]
    );
    
    // 3. History-Eintrag für Ablehnung
    await query(
      `INSERT INTO schedule_history 
       (schedule_entry_id, changed_by_type, changed_by_id, change_type,
        old_start, old_end, new_start, new_end, reason, created_at)
       VALUES ($1, 'bauherr', $2, 'rejection', $3, $4, $5, $6, $7, NOW())`,
      [
        entryId,
        bauherrId,
        old_start,  // Die "alten" waren die geänderten
        old_end,
        old_start,  // Die "neuen" sind wieder die Original-Termine
        old_end,
        reason || 'Terminänderung abgelehnt'
      ]
    );
    
    // 4. Hole Handwerker-Info für Notification
    const entryInfo = await query(
      `SELECT 
         se.trade_id,
         t.name as trade_name,
         o.handwerker_id,
         h.company_name
       FROM schedule_entries se
       JOIN trades t ON se.trade_id = t.id
       LEFT JOIN tenders tn ON tn.trade_id = se.trade_id
       LEFT JOIN offers o ON o.tender_id = tn.id AND o.status IN ('confirmed', 'accepted')
       LEFT JOIN handwerker h ON o.handwerker_id = h.id
       WHERE se.id = $1`,
      [entryId]
    );
    
    if (entryInfo.rows.length > 0) {
      const info = entryInfo.rows[0];
      
      // 5. Notification an Handwerker
      if (info.handwerker_id) {
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
           VALUES ('handwerker', $1, 'schedule_change_rejected', $2, 'schedule_entry', $3, $4, NOW())`,
          [
            info.handwerker_id,
            `Bauherr hat Ihre Terminänderung für ${info.trade_name} abgelehnt`,
            entryId,
            JSON.stringify({
              trade_name: info.trade_name,
              reason: reason || 'Keine Begründung angegeben',
              restored_start: old_start,
              restored_end: old_end
            })
          ]
        );
      }
    }
    
    await query('COMMIT');
    
    console.log('✅ Terminänderung abgelehnt und restored');
    
    res.json({ 
      success: true,
      message: 'Terminänderung wurde abgelehnt und Original-Termine wiederhergestellt'
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('❌ Error rejecting schedule change:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================================================
// TERMINÄNDERUNGEN FÜR PROJEKT ABRUFEN (Bauherr)
// ============================================================================
app.get('/api/projects/:projectId/schedule-changes', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    // Hole alle schedule_entries mit status='change_requested' für dieses Projekt
    const result = await query(
      `SELECT 
         se.id as entry_id,
         se.trade_id,
         se.phase_name,
         se.planned_start as new_start,
         se.planned_end as new_end,
         se.status,
         t.name as trade_name,
         t.code as trade_code,
         sh.old_start,
         sh.old_end,
         sh.reason,
         sh.created_at as change_requested_at,
         h.company_name,
         o.id as offer_id
       FROM schedule_entries se
       JOIN project_schedules ps ON se.schedule_id = ps.id
       JOIN trades t ON se.trade_id = t.id
       LEFT JOIN schedule_history sh ON se.id = sh.schedule_entry_id 
         AND sh.change_type = 'date_change'
       LEFT JOIN tenders tn ON tn.trade_id = se.trade_id AND tn.project_id = $1
       LEFT JOIN offers o ON o.tender_id = tn.id AND o.status = 'confirmed'
       LEFT JOIN handwerker h ON o.handwerker_id = h.id
       WHERE ps.project_id = $1
         AND se.status = 'change_requested'
       ORDER BY sh.created_at DESC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching schedule changes:', error);
    res.status(500).json({ error: error.message });
  }
});

// LV-Details für einen Auftrag abrufen
app.get('/api/orders/:orderId/lv-details', async (req, res) => {
  try {
    const { orderId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        of.lv_data,
        t.name as trade_name,
        p.description as project_description,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        b.name as bauherr_name
       FROM orders o
       JOIN offers of ON o.offer_id = of.id
       JOIN trades t ON o.trade_id = t.id
       JOIN projects p ON o.project_id = p.id
       JOIN bauherren b ON o.bauherr_id = b.id
       WHERE o.id = $1`,
      [orderId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Auftrag nicht gefunden' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching LV details:', error);
    res.status(500).json({ error: 'Fehler beim Laden der LV-Details' });
  }
});

// Werkvertrag generieren und Auftrag erstellen
app.post('/api/offers/:offerId/create-contract', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    // ===== START TRANSACTION =====
    await query('BEGIN');

    // 1. Prüfe ob Order bereits existiert
    const existingOrder = await query(
      `SELECT id FROM orders WHERE offer_id = $1`,
      [offerId]
    );
    
    if (existingOrder.rows.length > 0) {
      // Stelle sicher dass Offer-Status korrekt ist
      await query(
        `UPDATE offers 
         SET status = 'accepted', 
             stage = 2,
             accepted_at = COALESCE(accepted_at, NOW())
         WHERE id = $1`,
        [offerId]
      );
      
      await query('COMMIT');
      return res.json({
        success: true,
        orderId: existingOrder.rows[0].id,
        message: 'Auftrag wurde bereits erstellt'
      });
    }

    // 2. Hole alle relevanten Daten
    const offerData = await query(
      `SELECT 
        o.*,
        o.bundle_discount,
        h.company_name,
        h.address as handwerker_address,
        h.contact_person,
        h.phone as handwerker_phone,
        h.email as handwerker_email,
        h.id as handwerker_id,  
        b.name as bauherr_name,
        b.address as bauherr_address,
        b.phone as bauherr_phone,
        b.email as bauherr_email,
        b.id as bauherr_id,     
        p.id as project_id,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        p.description as project_description,
        tn.trade_id,            
        t.name as trade_name,
        t.code as trade_code
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (offerData.rows.length === 0) {
      await query('ROLLBACK');
      return res.status(400).json({ error: 'Angebot nicht gefunden' });
    }
    
    const offer = offerData.rows[0];

    // ✅ NEU: Akzeptiere alle change_requested Termine automatisch
    await query(
      `UPDATE schedule_entries
       SET status = 'confirmed',
           confirmed = true,
           confirmed_by = $2,
           confirmed_at = NOW()
       WHERE schedule_id IN (
         SELECT id FROM project_schedules WHERE project_id = $1
       )
       AND trade_id = $3
       AND status = 'change_requested'`,
      [offer.project_id, offer.bauherr_id, offer.trade_id]
    );
    
   // 3a. ✅ NEU: Hole finale Termine aus schedule_entries
    const scheduleTermine = await query(
      `SELECT 
         MIN(se.planned_start) as execution_start,
         MAX(se.planned_end) as execution_end
       FROM schedule_entries se
       JOIN project_schedules ps ON se.schedule_id = ps.id
       WHERE ps.project_id = $1
         AND se.trade_id = $2
         AND se.status = 'confirmed'
         AND se.confirmed = true`,
      [offer.project_id, offer.trade_id]
    );
    
    // Nutze Schedule-Termine (falls vorhanden), sonst Fallback auf Offer
    const executionStart = scheduleTermine.rows[0]?.execution_start || 
                          offer.execution_start || 
                          new Date();
    const executionEnd = scheduleTermine.rows[0]?.execution_end || 
                        offer.execution_end || 
                        new Date(Date.now() + 30*24*60*60*1000);
    
    console.log('📅 Verwendete Ausführungstermine:', {
      fromSchedule: scheduleTermine.rows[0],
      fromOffer: { start: offer.execution_start, end: offer.execution_end },
      final: { executionStart, executionEnd }
    });
    
    // 3b. Werkvertrag-Text generieren MIT finalen Terminen
    const contractText = generateVOBContract({
      ...offer,
      execution_start: executionStart,  // ✅ Finale Termine!
      execution_end: executionEnd        // ✅ Finale Termine!
    });
    
    // 4. Erstelle Order/Werkvertrag MIT finalen Terminen
    const orderResult = await query(
      `INSERT INTO orders  
       (project_id, offer_id, handwerker_id, bauherr_id, trade_id, 
        amount, bundle_discount, execution_start, execution_end, 
        contract_text, status, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, 'active', NOW())
       RETURNING id`,
      [
        offer.project_id,
        offerId,
        offer.handwerker_id,
        offer.bauherr_id,
        offer.trade_id,
        offer.amount,
        offer.bundle_discount || 0,
        executionStart,   // ✅ Aus schedule_entries!
        executionEnd,     // ✅ Aus schedule_entries!
        contractText
      ]
    );
    
    const orderId = orderResult.rows[0].id;

    // NEUE ERGÄNZUNG: Hole alle anderen Angebote für Benachrichtigungen
    const otherOffers = await query(
      `SELECT o.*, h.email, h.company_name, h.contact_person
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       WHERE tn.project_id = $1 
       AND tn.trade_id = $2 
       AND o.id != $3
       AND o.status NOT IN ('withdrawn', 'rejected', 'accepted', 'not_selected')`,
      [offer.project_id, offer.trade_id, offerId]
    );
    
    // 5. Update Offer Status
    await query(
      `UPDATE offers 
       SET status = 'accepted', 
           stage = 2,
           final_accepted_at = NOW(),
           accepted_at = NOW()
       WHERE id = $1`,
      [offerId]
    );

    // NEU: Bundle-Logik - Projekt aus Bundle entfernen oder Bundle schließen
const tenderBundleCheck = await query(
  `SELECT tn.bundle_id, b.current_projects
   FROM tenders tn
   JOIN bundles b ON tn.bundle_id = b.id
   WHERE tn.id = (SELECT tender_id FROM offers WHERE id = $1)
   AND tn.bundle_id IS NOT NULL`,
  [offerId]
);

if (tenderBundleCheck.rows.length > 0) {
  const bundleId = tenderBundleCheck.rows[0].bundle_id;
  const currentProjects = tenderBundleCheck.rows[0].current_projects;
  
  console.log(`📦 Bundle ${bundleId} - Projekt wurde beauftragt`);
  
  if (currentProjects <= 2) {
    // Bundle hat nur noch 2 oder weniger Projekte → Bundle schließen
    await query(
      `UPDATE bundles 
       SET status = 'closed', 
           current_projects = current_projects - 1
       WHERE id = $1`,
      [bundleId]
    );
    console.log(`📦 Bundle ${bundleId} geschlossen (nur noch ${currentProjects} Projekte)`);
  } else {
    // Bundle hat mehr als 2 Projekte → Nur dieses Projekt entfernen
    await query(
      `UPDATE tenders 
       SET bundle_id = NULL 
       WHERE id = (SELECT tender_id FROM offers WHERE id = $1)`,
      [offerId]
    );
    
    await query(
      `UPDATE bundles 
       SET current_projects = current_projects - 1,
           total_volume = (
             SELECT SUM(estimated_value) 
             FROM tenders 
             WHERE bundle_id = $1
           )
       WHERE id = $1`,
      [bundleId]
    );
    console.log(`📦 Bundle ${bundleId} - Projekt entfernt (${currentProjects - 1} Projekte verbleiben)`);
  }
}

    // NEUE ERGÄNZUNG: Update Status der anderen Angebote
    if (otherOffers.rows.length > 0) {
      await query(
        `UPDATE offers 
         SET status = 'not_selected',
             updated_at = NOW()
         WHERE tender_id IN (
           SELECT id FROM tenders 
           WHERE project_id = $1 AND trade_id = $2
         )
         AND id != $3
         AND status NOT IN ('withdrawn', 'rejected', 'accepted')`,
        [offer.project_id, offer.trade_id, offerId]
      );
      
      await query(
        `UPDATE tenders 
         SET status = 'awarded'
         WHERE project_id = $1 AND trade_id = $2`,
        [offer.project_id, offer.trade_id]
      );
    }
    
    // ===== COMMIT - ORDER UND OFFER SIND JETZT SICHER! =====
    await query('COMMIT');
    
    // ===== AB HIER: NICHT-KRITISCHE OPERATIONS =====
    
    // 6. Conversations hinzufügen (Fehler hier sind nicht kritisch)
    try {
      // Zu Projekt-Gruppe hinzufügen
      await query(
        `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
         SELECT c.id, 'handwerker', $2, 'participant'
         FROM conversations c
         WHERE c.type = 'project_group' AND c.project_id = $1
         ON CONFLICT (conversation_id, user_type, user_id) DO NOTHING`,
        [offer.project_id, offer.handwerker_id]
      );

      // Zu Handwerker-Koordination hinzufügen
      await query(
        `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
         SELECT c.id, 'handwerker', $2, 'participant'
         FROM conversations c
         WHERE c.type = 'handwerker_coordination' AND c.project_id = $1
         ON CONFLICT (conversation_id, user_type, user_id) DO NOTHING`,
        [offer.project_id, offer.handwerker_id]
      );

      // Projekt-Gruppe erstellen falls noch nicht vorhanden
      const projectGroupExists = await query(
        `SELECT id FROM conversations 
         WHERE type = 'project_group' AND project_id = $1`,
        [offer.project_id]
      );

      if (projectGroupExists.rows.length === 0) {
        const convResult = await query(
          `INSERT INTO conversations (type, project_id, created_at, updated_at)
           VALUES ('project_group', $1, NOW(), NOW())
           RETURNING id`,
          [offer.project_id]
        );
        
        const conversationId = convResult.rows[0].id;
        
        await query(
          `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
           VALUES ($1, 'bauherr', $2, 'participant')`,
          [conversationId, offer.bauherr_id]
        );
        
        await query(
          `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
           SELECT $1::integer, 'handwerker', o.handwerker_id, 'participant'
           FROM orders o
           WHERE o.project_id = $2
           ON CONFLICT (conversation_id, user_type, user_id) DO NOTHING`,
          [conversationId, offer.project_id]
        );
      }

      // Handwerker-Koordination erstellen falls 2+ Handwerker
      const handwerkerCount = await query(
        `SELECT COUNT(DISTINCT handwerker_id) as count 
         FROM orders 
         WHERE project_id = $1`,
        [offer.project_id]
      );

      if (handwerkerCount.rows[0].count >= 2) {
        const coordExists = await query(
          `SELECT id FROM conversations 
           WHERE type = 'handwerker_coordination' AND project_id = $1`,
          [offer.project_id]
        );
        
        if (coordExists.rows.length === 0) {
          const convResult = await query(
            `INSERT INTO conversations (type, project_id, created_at, updated_at)
             VALUES ('handwerker_coordination', $1, NOW(), NOW())
             RETURNING id`,
            [offer.project_id]
          );
          
          const conversationId = convResult.rows[0].id;
          
          await query(
            `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
             VALUES ($1, 'bauherr', $2, 'observer')`,
            [conversationId, offer.bauherr_id]
          );
          
          await query(
            `INSERT INTO conversation_participants (conversation_id, user_type, user_id, role)
             SELECT $1::integer, 'handwerker', o.handwerker_id, 'participant'
             FROM orders o
             WHERE o.project_id = $2
             ON CONFLICT (conversation_id, user_type, user_id) DO NOTHING`,
            [conversationId, offer.project_id]
          );
        }
      }
    } catch (convError) {
      console.error('⚠️ Non-critical: Conversation setup failed:', convError.message);
    }
    
    // 7. Email senden (Fehler hier sind nicht kritisch)
    try {
      if (transporter) {
        await transporter.sendMail({
          from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
          to: offer.handwerker_email,
          subject: `Auftrag erteilt - ${offer.trade_name}`,
          html: `
            <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
              <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0;">
                <h1>🎉 Auftrag erteilt!</h1>
              </div>
              
              <div style="padding: 30px; background: #f7f7f7;">
                <p>Sehr geehrte Damen und Herren,</p>
                
                <p><strong>${offer.bauherr_name}</strong> hat Ihnen den Auftrag für <strong>${offer.trade_name}</strong> verbindlich erteilt.</p>
                
                <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                  <h3 style="color: #10b981;">Auftragsdetails:</h3>
                  <table style="width: 100%;">
                    <tr>
                      <td style="padding: 8px 0;"><strong>Auftragssumme:</strong></td>
                      <td style="text-align: right;">${offer.amount.toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}</td>
                    </tr>
                    <tr>
                      <td style="padding: 8px 0;"><strong>Ausführung:</strong></td>
                      <td style="text-align: right;">${new Date(offer.execution_start).toLocaleDateString('de-DE')} - ${new Date(offer.execution_end).toLocaleDateString('de-DE')}</td>
                    </tr>
                    <tr>
                      <td style="padding: 8px 0;"><strong>Projekt:</strong></td>
                      <td style="text-align: right;">${offer.street} ${offer.house_number}, ${offer.zip_code} ${offer.city}</td>
                    </tr>
                    <tr>
                      <td style="padding: 8px 0;"><strong>Auftrags-Nr:</strong></td>
                      <td style="text-align: right;">#${orderId}</td>
                    </tr>
                  </table>
                </div>
                
                <div style="text-align: center; margin-top: 30px;">
                  <a href="https://byndl.de/handwerker/dashboard" 
                     style="display: inline-block; padding: 12px 30px; background: #10b981; color: white; text-decoration: none; border-radius: 5px;">
                    Zum Dashboard →
                  </a>
                </div>
              </div>
            </div>
          `
        });
      }
    } catch (emailError) {
      console.error('⚠️ Non-critical: Email sending failed:', emailError.message);
    }

    // NEUE ERGÄNZUNG: E-Mails an abgelehnte Bieter
if (transporter && otherOffers.rows.length > 0) {
  for (const otherOffer of otherOffers.rows) {
    try {
      await transporter.sendMail({
        from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
        to: otherOffer.email,
        subject: `Information zu Ihrer Angebotsabgabe - ${offer.trade_name}`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: #f8f9fa; padding: 30px; border-radius: 10px;">
              <h2 style="color: #333;">Information zu Ihrem Angebot</h2>
              
              <p>Sehr geehrte/r ${otherOffer.contact_person || 'Damen und Herren'},</p>
              
              <p>im Namen von <strong>${offer.bauherr_name}</strong> möchten wir uns herzlich für Ihr 
              detailliertes Angebot für das Gewerk <strong>${offer.trade_name}</strong> bedanken.</p>
              
              <p>${offer.bauherr_name} hat nach eingehender Prüfung aller eingegangenen Angebote 
              eine Entscheidung getroffen. Leider müssen wir Ihnen mitteilen, dass die Wahl in 
              diesem Fall auf einen anderen Anbieter gefallen ist.</p>
              
              <p>Diese Entscheidung basiert auf den spezifischen Projektanforderungen und stellt 
              keine Bewertung Ihrer fachlichen Kompetenz dar. ${offer.bauherr_name} schätzt die 
              Zeit und Mühe, die Sie in die Angebotserstellung investiert haben.</p>
              
              <p>${offer.bauherr_name} würde sich freuen, Sie bei zukünftigen Projekten wieder 
              in Betracht ziehen zu können.</p>
              
              <p>Mit freundlichen Grüßen<br>
              <strong>${offer.bauherr_name}</strong><br>
              <em style="font-size: 12px; color: #666;">Diese Nachricht wurde über die byndl-Plattform versendet</em></p>
            </div>
          </div>
        `
      });
      console.log(`Absage-Email gesendet an: ${otherOffer.company_name}`);
    } catch (emailError) {
      console.error(`E-Mail-Fehler ${otherOffer.company_name}:`, emailError);
    }
  }
}
    
    res.json({ 
      success: true, 
      orderId: orderId,
      message: 'Werkvertrag erstellt und Auftrag erteilt' 
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('❌ CRITICAL ERROR creating contract:', error);
    res.status(500).json({ error: 'Fehler beim Erstellen des Auftrags: ' + error.message });
  }
});

// Hilfsfunktion: VOB-konformen Werkvertrag generieren
function generateVOBContract(offer) {
  const today = new Date().toLocaleDateString('de-DE');
  
  return `
WERKVERTRAG
nach VOB/B (Vergabe- und Vertragsordnung für Bauleistungen Teil B)

Vertragsnummer: WV-${offer.id}-${new Date().getFullYear()}
Datum: ${today}

================================================================

§ 1 VERTRAGSPARTEIEN

AUFTRAGGEBER (AG):
${offer.bauherr_name}
${offer.bauherr_address || ''}
Tel: ${offer.bauherr_phone}
E-Mail: ${offer.bauherr_email}

AUFTRAGNEHMER (AN):
${offer.company_name}
${offer.handwerker_address || ''}
Tel: ${offer.handwerker_phone}
E-Mail: ${offer.handwerker_email}
${offer.contact_person ? `Ansprechpartner: ${offer.contact_person}` : ''}

================================================================

§ 2 VERTRAGSGEGENSTAND

Gewerk: ${offer.trade_name} (Code: ${offer.trade_code})

Ausführungsort:
${offer.street} ${offer.house_number}
${offer.zip_code} ${offer.city}

Projektbeschreibung:
${offer.project_description || 'Wie im Leistungsverzeichnis beschrieben'}

================================================================

§ 3 LEISTUNGSUMFANG

Die zu erbringenden Leistungen ergeben sich aus dem diesem Vertrag 
als Anlage beigefügten Leistungsverzeichnis (LV).

Das Leistungsverzeichnis ist Bestandteil dieses Vertrags und 
beschreibt Art und Umfang der zu erbringenden Leistungen im Detail.

Der AN verpflichtet sich, alle im LV aufgeführten Positionen 
fachgerecht und nach den anerkannten Regeln der Technik sowie 
den einschlägigen DIN-Normen auszuführen.

================================================================

§ 4 VERGÜTUNG

Vertragssumme (Netto): ${offer.amount.toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}
${offer.bundle_discount > 0 ? `Bündelrabatt (${offer.bundle_discount}%): -${(offer.amount * offer.bundle_discount / 100).toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}
Netto nach Rabatt: ${(offer.amount * (1 - offer.bundle_discount / 100)).toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}` : ''}
zzgl. gesetzlicher MwSt. (${19}%): ${(offer.amount * (1 - (offer.bundle_discount || 0) / 100) * 0.19).toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}
----------------------------------------------------------------
Gesamtsumme (Brutto): ${(offer.amount * (1 - (offer.bundle_discount || 0) / 100) * 1.19).toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}

Die Vergütung erfolgt nach tatsächlich erbrachter und abgenommener Leistung 
gemäß den Mengen und Einheitspreisen des Leistungsverzeichnisses.

Zahlungsbedingungen:
- Abschlagszahlungen nach Baufortschritt möglich
- Schlusszahlung innerhalb von 30 Tagen nach Abnahme
- Einbehalt von 5% als Sicherheit bis zum Ablauf der Gewährleistungsfrist

================================================================

§ 5 AUSFÜHRUNGSFRISTEN

Beginn der Ausführung: ${new Date(offer.execution_start).toLocaleDateString('de-DE')}
Fertigstellung bis: ${new Date(offer.execution_end).toLocaleDateString('de-DE')}

Bei Verzug ist der AN verpflichtet, eine Vertragsstrafe in Höhe von 
0,2% der Auftragssumme pro Werktag zu zahlen, maximal jedoch 5% 
der Gesamtauftragssumme.

Verlängerungen der Ausführungsfrist sind nur bei Behinderungen 
gemäß § 6 VOB/B zulässig und bedürfen der schriftlichen Vereinbarung.

================================================================

§ 6 ABNAHME

Die Abnahme erfolgt nach Fertigstellung der Leistungen durch 
den AG oder dessen Bevollmächtigten.

Der AN hat den AG rechtzeitig zur Abnahme aufzufordern.

Die Abnahme darf nur verweigert werden, wenn wesentliche Mängel 
vorliegen, die die Gebrauchsfähigkeit beeinträchtigen.

Mit der Abnahme geht die Gefahr auf den AG über und die 
Gewährleistungsfrist beginnt.

================================================================

§ 7 GEWÄHRLEISTUNG

Gewährleistungsfrist:
- 5 Jahre für Arbeiten an Bauwerken (§ 634a Abs. 1 Nr. 2 BGB)
- 2 Jahre für andere Arbeiten

Die Gewährleistungsfrist beginnt mit der Abnahme der Leistung.

Der AN haftet für Mängel, die bei Abnahme vorhanden waren oder 
während der Gewährleistungsfrist auftreten.

Bei berechtigten Mängelrügen hat der AN nach seiner Wahl das 
Recht zur Nacherfüllung durch Nachbesserung oder Neuherstellung.

================================================================

§ 8 VERSICHERUNG

Der AN verpflichtet sich, für die Dauer der Ausführung eine 
ausreichende Betriebshaftpflichtversicherung zu unterhalten.

Der Nachweis ist auf Verlangen vorzulegen.

================================================================

§ 9 SICHERHEITSVORSCHRIFTEN

Der AN verpflichtet sich zur Einhaltung aller einschlägigen 
Arbeitsschutz-, Unfallverhütungs- und Sicherheitsvorschriften.

================================================================

§ 10 KÜNDIGUNG

Beide Parteien können den Vertrag aus wichtigem Grund kündigen.

Der AG kann den Vertrag jederzeit bis zur Vollendung der Leistung 
kündigen (§ 8 VOB/B).

================================================================

§ 11 SCHLUSSBESTIMMUNGEN

Es gilt das Recht der Bundesrepublik Deutschland.

Erfüllungsort und Gerichtsstand ist ${offer.city}.

Änderungen und Ergänzungen dieses Vertrages bedürfen der 
Schriftform.

Sollten einzelne Bestimmungen unwirksam sein, bleibt die 
Wirksamkeit der übrigen Bestimmungen unberührt.

Dieser Vertrag wurde auf elektronischem Wege über die 
Plattform byndl.de geschlossen und ist rechtsgültig.

================================================================

ANLAGEN:
- Leistungsverzeichnis (LV) mit detaillierter Positionsbeschreibung
- Planunterlagen (falls vorhanden)

================================================================

Elektronisch bestätigt am: ${today}

Auftraggeber: ${offer.bauherr_name}
Auftragnehmer: ${offer.company_name}

Über byndl.de digital abgeschlossen
  `.trim();
}

// Route zum Abrufen des Vertragstexts (ohne PDF)
app.get('/api/orders/:orderId/contract-text', async (req, res) => {
  try {
    const { orderId } = req.params;
    
    const result = await query(
      `SELECT 
        o.contract_text,
        o.created_at,
        t.name as trade_name,
        h.company_name,
        b.name as bauherr_name
       FROM orders o
       JOIN trades t ON o.trade_id = t.id
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN bauherren b ON o.bauherr_id = b.id
       WHERE o.id = $1`,
      [orderId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Vertrag nicht gefunden' });
    }
    
    res.json(result.rows[0]);
  } catch (error) {
    console.error('Error fetching contract text:', error);
    res.status(500).json({ error: 'Fehler beim Laden des Vertrags' });
  }
});

// LV als PDF generieren (nur LV ohne Vertrag)
app.get('/api/orders/:orderId/lv-pdf', async (req, res) => {
  try {
    const { orderId } = req.params;
    
    const orderResult = await query(
      `SELECT 
        o.*,
        h.company_name,
        b.name as bauherr_name,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        p.description as project_description,
        t.name as trade_name,
        of.lv_data
       FROM orders o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN projects p ON o.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON o.trade_id = t.id
       JOIN offers of ON o.offer_id = of.id
       WHERE o.id = $1`,
      [orderId]
    );
    
    if (orderResult.rows.length === 0) {
      return res.status(404).json({ error: 'Auftrag nicht gefunden' });
    }
    
    const order = orderResult.rows[0];
    
    // Parse LV-Daten - KORRIGIERT für Array-Format
let lvData = null;
if (order.lv_data) {
  let parsed = typeof order.lv_data === 'string' ? JSON.parse(order.lv_data) : order.lv_data;
  
  // Wenn es direkt ein Array ist (wie in der DB), wrappe es
  if (Array.isArray(parsed)) {
    lvData = { positions: parsed };
  } else if (parsed.positions) {
    lvData = parsed;
  } else {
    lvData = { positions: [] };
  }
}
    
    if (!lvData || !lvData.positions || lvData.positions.length === 0) {
      return res.status(404).json({ error: 'Keine LV-Daten gefunden' });
    }
    
    // PDF erstellen
    const doc = new PDFDocument({
      size: 'A4',
      margins: { top: 50, bottom: 50, left: 50, right: 50 }
    });
    
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="LV-${orderId}.pdf"`);
    doc.pipe(res);
    
    // Header
    doc.fontSize(20).font('Helvetica-Bold').text('Leistungsverzeichnis', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(12).font('Helvetica').text(`Auftrag #${orderId}`, { align: 'center' });
    doc.moveDown(2);
    
    // Projektinfo
    doc.fontSize(14).font('Helvetica-Bold').text('Projektinformationen');
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica');
    doc.text(`Gewerk: ${order.trade_name}`);
    doc.text(`Projekt: ${order.project_description}`);
    doc.text(`Ort: ${order.street} ${order.house_number}, ${order.zip_code} ${order.city}`);
    doc.text(`Bauherr: ${order.bauherr_name}`);
    doc.text(`Handwerker: ${order.company_name}`);
    doc.text(`Datum: ${new Date(order.created_at).toLocaleDateString('de-DE')}`);
    doc.moveDown(2);
    
    // LV-Tabelle
    doc.fontSize(14).font('Helvetica-Bold').text('Positionen');
    doc.moveDown(1);
    
    const tableTop = doc.y;
    const colWidths = {
      pos: 40,
      title: 200,
      quantity: 50,
      unit: 40,
      unitPrice: 70,
      total: 80
    };
    
    // Tabellenkopf
    doc.fontSize(9).font('Helvetica-Bold');
    let xPos = 50;
    doc.text('Pos.', xPos, tableTop, { width: colWidths.pos, align: 'left' });
    xPos += colWidths.pos;
    doc.text('Bezeichnung', xPos, tableTop, { width: colWidths.title, align: 'left' });
    xPos += colWidths.title;
    doc.text('Menge', xPos, tableTop, { width: colWidths.quantity, align: 'right' });
    xPos += colWidths.quantity;
    doc.text('Einh.', xPos, tableTop, { width: colWidths.unit, align: 'center' });
    xPos += colWidths.unit;
    doc.text('EP (€)', xPos, tableTop, { width: colWidths.unitPrice, align: 'right' });
    xPos += colWidths.unitPrice;
    doc.text('GP (€)', xPos, tableTop, { width: colWidths.total, align: 'right' });
    
    doc.moveTo(50, doc.y + 5).lineTo(545, doc.y + 5).stroke();
    doc.moveDown(0.5);
    
    // Positionen
    doc.fontSize(8).font('Helvetica');
    let totalSum = 0;
    
    lvData.positions.forEach((pos, index) => {
  if (doc.y > 700) {
    doc.addPage();
    doc.fontSize(8).font('Helvetica');
  }
  
  const startY = doc.y;
  const posTotal = (parseFloat(pos.quantity) || 0) * (parseFloat(pos.unitPrice) || 0);
  totalSum += posTotal; 
      
  // Position
  xPos = 50;
  doc.text(pos.pos || index + 1, xPos, startY, { width: colWidths.pos, align: 'left' });
  
  // Bezeichnung (mit Umbruch)
  xPos += colWidths.pos;
  const titleHeight = doc.heightOfString(pos.title, { width: colWidths.title - 5 });
  doc.text(pos.title, xPos, startY, { width: colWidths.title - 5, align: 'left' });
  
  // Menge - MIT parseFloat!
  xPos += colWidths.title;
  doc.text((parseFloat(pos.quantity) || 0).toFixed(2), xPos, startY, { width: colWidths.quantity, align: 'right' });
  
  // Einheit
  xPos += colWidths.quantity;
  doc.text(pos.unit || 'Stk', xPos, startY, { width: colWidths.unit, align: 'center' });
  
  // EP - MIT parseFloat!
  xPos += colWidths.unit;
  doc.text((parseFloat(pos.unitPrice) || 0).toFixed(2), xPos, startY, { width: colWidths.unitPrice, align: 'right' });
  
  // GP - MIT parseFloat!
  xPos += colWidths.unitPrice;
  doc.text(posTotal.toFixed(2), xPos, startY, { width: colWidths.total, align: 'right' });
      
      doc.moveDown(Math.max(1, titleHeight / 12));
      
      if (pos.description) {
        doc.fontSize(7).font('Helvetica-Oblique');
        doc.text(pos.description, 90, doc.y, { width: 450 });
        doc.moveDown(0.5);
        doc.fontSize(8).font('Helvetica');
      }
      
      if (index < lvData.positions.length - 1) {
        doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke();
        doc.moveDown(0.3);
      }
    });
    
    // Summen
    doc.moveDown(1);
    doc.fontSize(10).font('Helvetica-Bold');
    doc.moveTo(50, doc.y).lineTo(545, doc.y).lineWidth(2).stroke();
    doc.moveDown(0.5);

    const bundleDiscount = order.bundle_discount || 0;
    const discountAmount = bundleDiscount > 0 ? (totalSum * bundleDiscount / 100) : 0;
    const nettoAfterDiscount = totalSum - discountAmount;
    const mwst = nettoAfterDiscount * 0.19;
    const brutto = nettoAfterDiscount + mwst;
    
    xPos = 370;
    doc.text('Netto-Summe:', xPos, doc.y, { width: 100, align: 'left' });
    doc.text(formatCurrency(totalSum), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });

    if (bundleDiscount > 0) {
      doc.moveDown(0.5);
      doc.fontSize(9).font('Helvetica');
      doc.text(`Bündelrabatt (${bundleDiscount}%):`, xPos, doc.y, { width: 100, align: 'left' });
      doc.text(`-${formatCurrency(discountAmount)}`, xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
  
      doc.moveDown(0.5);
      doc.text('Netto nach Rabatt:', xPos, doc.y, { width: 100, align: 'left' });
      doc.text(formatCurrency(nettoAfterDiscount), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
    }

    doc.moveDown(0.5);
    doc.fontSize(9).font('Helvetica');
    doc.text('zzgl. 19% MwSt:', xPos, doc.y, { width: 100, align: 'left' });
    doc.text(formatCurrency(mwst), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
    
    doc.moveDown(0.5);
    doc.fontSize(11).font('Helvetica-Bold');
    doc.moveTo(xPos, doc.y).lineTo(xPos + 180, doc.y).stroke();
    doc.moveDown(0.3);
    doc.text('Gesamt (Brutto):', xPos, doc.y, { width: 100, align: 'left' });
    doc.text(formatCurrency(brutto), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
    
    doc.end();
    
  } catch (error) {
    console.error('Error generating LV PDF:', error);
    res.status(500).json({ error: 'Fehler beim Erstellen des PDFs' });
  }
});

// Werkvertrag als PDF generieren
app.get('/api/orders/:orderId/contract-pdf', async (req, res) => {
  try {
    const { orderId } = req.params;
    
    // Lade alle Auftragsdaten inkl. LV
    const orderResult = await query(
      `SELECT 
        o.*,
        h.company_name,
        h.address as handwerker_address,
        h.contact_person,
        h.phone as handwerker_phone,
        h.email as handwerker_email,
        b.name as bauherr_name,
        b.address as bauherr_address,
        b.phone as bauherr_phone,
        b.email as bauherr_email,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        p.description as project_description,
        t.name as trade_name,
        t.code as trade_code,
        of.lv_data
       FROM orders o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN projects p ON o.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON o.trade_id = t.id
       JOIN offers of ON o.offer_id = of.id
       WHERE o.id = $1`,
      [orderId]
    );
    
    if (orderResult.rows.length === 0) {
      return res.status(404).json({ error: 'Auftrag nicht gefunden' });
    }
    
    const order = orderResult.rows[0];
    
    // Parse LV-Daten - KORRIGIERT für Array-Format
let lvData = null;
if (order.lv_data) {
  let parsed = typeof order.lv_data === 'string' ? JSON.parse(order.lv_data) : order.lv_data;
  
  // Wenn es direkt ein Array ist (wie in der DB), wrappe es
  if (Array.isArray(parsed)) {
    lvData = { positions: parsed };
  } else if (parsed.positions) {
    lvData = parsed;
  } else {
    lvData = { positions: [] };
  }
}
    
    // PDF erstellen
    const doc = new PDFDocument({
      size: 'A4',
      margins: { top: 50, bottom: 50, left: 50, right: 50 },
      info: {
        Title: `Werkvertrag ${orderId}`,
        Author: 'byndl GmbH',
        Subject: 'Werkvertrag nach VOB/B',
        Creator: 'byndl Platform'
      }
    });
    
    // Response-Header setzen
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="Werkvertrag-${orderId}.pdf"`);
    
    // PDF-Stream an Response pipen
    doc.pipe(res);
    
    // === TITELSEITE ===
    doc.fontSize(24).font('Helvetica-Bold').text('WERKVERTRAG', { align: 'center' });
    doc.moveDown(0.5);
    doc.fontSize(12).font('Helvetica').text('nach VOB/B', { align: 'center' });
    doc.fontSize(10).text('(Vergabe- und Vertragsordnung für Bauleistungen Teil B)', { align: 'center' });
    
    doc.moveDown(2);
    
    // Vertragsnummer und Datum
    doc.fontSize(10);
    doc.text(`Vertragsnummer: WV-${order.id}-${new Date().getFullYear()}`, { align: 'center' });
    doc.text(`Datum: ${new Date().toLocaleDateString('de-DE')}`, { align: 'center' });
    
    doc.moveDown(3);
    
    // === § 1 VERTRAGSPARTEIEN ===
    addSection(doc, '§ 1 VERTRAGSPARTEIEN');
    
    doc.fontSize(10).font('Helvetica-Bold').text('AUFTRAGGEBER (AG):');
    doc.font('Helvetica');
    doc.text(order.bauherr_name);
    if (order.bauherr_address) doc.text(order.bauherr_address);
    doc.text(`Tel: ${order.bauherr_phone}`);
    doc.text(`E-Mail: ${order.bauherr_email}`);
    
    doc.moveDown(1);
    
    doc.font('Helvetica-Bold').text('AUFTRAGNEHMER (AN):');
    doc.font('Helvetica');
    doc.text(order.company_name);
    if (order.handwerker_address) doc.text(order.handwerker_address);
    doc.text(`Tel: ${order.handwerker_phone}`);
    doc.text(`E-Mail: ${order.handwerker_email}`);
    if (order.contact_person) doc.text(`Ansprechpartner: ${order.contact_person}`);
    
    // === § 2 VERTRAGSGEGENSTAND ===
    addSection(doc, '§ 2 VERTRAGSGEGENSTAND');
    
    doc.font('Helvetica-Bold').text(`Gewerk: `);
    doc.font('Helvetica').text(`${order.trade_name} (Code: ${order.trade_code})`, { continued: false });
    
    doc.moveDown(0.5);
    doc.font('Helvetica-Bold').text('Ausführungsort:');
    doc.font('Helvetica').text(`${order.street} ${order.house_number}`);
    doc.text(`${order.zip_code} ${order.city}`);
    
    if (order.project_description) {
      doc.moveDown(0.5);
      doc.font('Helvetica-Bold').text('Projektbeschreibung:');
      doc.font('Helvetica').text(order.project_description, { width: 500 });
    }
    
    // === § 3 LEISTUNGSUMFANG ===
    addSection(doc, '§ 3 LEISTUNGSUMFANG');
    
    doc.font('Helvetica').text(
      'Die zu erbringenden Leistungen ergeben sich aus dem diesem Vertrag als Anlage beigefügten Leistungsverzeichnis (LV).',
      { width: 500 }
    );
    doc.moveDown(0.5);
    doc.text(
      'Das Leistungsverzeichnis ist Bestandteil dieses Vertrags und beschreibt Art und Umfang der zu erbringenden Leistungen im Detail.',
      { width: 500 }
    );
    doc.moveDown(0.5);
    doc.text(
      'Der AN verpflichtet sich, alle im LV aufgeführten Positionen fachgerecht und nach den anerkannten Regeln der Technik sowie den einschlägigen DIN-Normen auszuführen.',
      { width: 500 }
    );
    
    // === § 4 VERGÜTUNG ===
    addSection(doc, '§ 4 VERGÜTUNG');
    
    const netto = parseFloat(order.amount);
    const bundleDiscount = order.bundle_discount || 0;
    const discountAmount = bundleDiscount > 0 ? (netto * bundleDiscount / 100) : 0;
    const nettoAfterDiscount = netto - discountAmount;
    const mwst = nettoAfterDiscount * 0.19;
    const brutto = nettoAfterDiscount + mwst;
    
    doc.fontSize(11).font('Helvetica-Bold');
    doc.text(`Vertragssumme (Netto): ${formatCurrency(netto)}`);

    if (bundleDiscount > 0) {
      doc.text(`Bündelrabatt (${bundleDiscount}%): -${formatCurrency(discountAmount)}`);
      doc.text(`Netto nach Rabatt: ${formatCurrency(nettoAfterDiscount)}`);
    }

    doc.text(`zzgl. gesetzlicher MwSt. (19%): ${formatCurrency(mwst)}`);
    doc.text('-'.repeat(60));
    doc.text(`Gesamtsumme (Brutto): ${formatCurrency(brutto)}`);
    
    doc.moveDown(1);
    doc.fontSize(10).font('Helvetica');
    doc.text(
      'Die Vergütung erfolgt nach tatsächlich erbrachter und abgenommener Leistung gemäß den Mengen und Einheitspreisen des Leistungsverzeichnisses.',
      { width: 500 }
    );
    
    doc.moveDown(0.5);
    doc.font('Helvetica-Bold').text('Zahlungsbedingungen:');
    doc.font('Helvetica');
    doc.list([
      'Abschlagszahlungen nach Baufortschritt möglich',
      'Schlusszahlung innerhalb von 30 Tagen nach Abnahme',
      'Einbehalt von 5% als Sicherheit bis zum Ablauf der Gewährleistungsfrist'
    ]);
    
    // === § 5 AUSFÜHRUNGSFRISTEN ===
    addSection(doc, '§ 5 AUSFÜHRUNGSFRISTEN');
    
    doc.font('Helvetica-Bold').text('Beginn der Ausführung: ');
    doc.font('Helvetica').text(new Date(order.execution_start).toLocaleDateString('de-DE'), { continued: false });
    
    doc.font('Helvetica-Bold').text('Fertigstellung bis: ');
    doc.font('Helvetica').text(new Date(order.execution_end).toLocaleDateString('de-DE'), { continued: false });
    
    doc.moveDown(0.5);
    doc.text(
      'Bei Verzug ist der AN verpflichtet, eine Vertragsstrafe in Höhe von 0,2% der Auftragssumme pro Werktag zu zahlen, maximal jedoch 5% der Gesamtauftragssumme.',
      { width: 500 }
    );
    
    // === § 6 ABNAHME ===
    addSection(doc, '§ 6 ABNAHME');
    
    doc.text(
      'Die Abnahme erfolgt nach Fertigstellung der Leistungen durch den AG oder dessen Bevollmächtigten.',
      { width: 500 }
    );
    doc.moveDown(0.5);
    doc.text('Der AN hat den AG rechtzeitig zur Abnahme aufzufordern.', { width: 500 });
    doc.moveDown(0.5);
    doc.text(
      'Die Abnahme darf nur verweigert werden, wenn wesentliche Mängel vorliegen, die die Gebrauchsfähigkeit beeinträchtigen.',
      { width: 500 }
    );
    
    // === § 7 GEWÄHRLEISTUNG ===
    addSection(doc, '§ 7 GEWÄHRLEISTUNG');
    
    doc.font('Helvetica-Bold').text('Gewährleistungsfrist:');
    doc.font('Helvetica');
    doc.list([
      '4 Jahre für Arbeiten an Bauwerken (§ 634a Abs. 1 Nr. 2 BGB)',
      '2 Jahre für andere Arbeiten'
    ]);
    
    doc.moveDown(0.5);
    doc.text('Die Gewährleistungsfrist beginnt mit der Abnahme der Leistung.', { width: 500 });
    doc.moveDown(0.5);
    doc.text(
      'Bei berechtigten Mängelrügen hat der AN nach seiner Wahl das Recht zur Nacherfüllung durch Nachbesserung oder Neuherstellung.',
      { width: 500 }
    );
    
    // === § 8-11 (Kurz) ===
    addSection(doc, '§ 8 VERSICHERUNG');
    doc.text(
      'Der AN verpflichtet sich, für die Dauer der Ausführung eine ausreichende Betriebshaftpflichtversicherung zu unterhalten.',
      { width: 500 }
    );
    
    addSection(doc, '§ 9 SICHERHEITSVORSCHRIFTEN');
    doc.text(
      'Der AN verpflichtet sich zur Einhaltung aller einschlägigen Arbeitsschutz-, Unfallverhütungs- und Sicherheitsvorschriften.',
      { width: 500 }
    );
    
    addSection(doc, '§ 10 KÜNDIGUNG');
    doc.text('Beide Parteien können den Vertrag aus wichtigem Grund kündigen.', { width: 500 });
    doc.moveDown(0.5);
    doc.text('Der AG kann den Vertrag jederzeit bis zur Vollendung der Leistung kündigen (§ 8 VOB/B).', { width: 500 });
    
    addSection(doc, '§ 11 SCHLUSSBESTIMMUNGEN');
    doc.text('Es gilt das Recht der Bundesrepublik Deutschland.', { width: 500 });
    doc.moveDown(0.5);
    doc.text(`Erfüllungsort und Gerichtsstand ist ${order.city}.`, { width: 500 });
    doc.moveDown(0.5);
    doc.text('Änderungen und Ergänzungen dieses Vertrages bedürfen der Schriftform.', { width: 500 });
    
    doc.moveDown(2);
    doc.fontSize(10).font('Helvetica-Bold');
    doc.text('='.repeat(80));
    doc.moveDown(0.5);
    doc.text(`Elektronisch bestätigt am: ${new Date(order.created_at).toLocaleDateString('de-DE')}`);
    doc.moveDown(0.5);
    doc.text(`Auftraggeber: ${order.bauherr_name}`);
    doc.text(`Auftragnehmer: ${order.company_name}`);
    doc.moveDown(0.5);
    doc.fontSize(8).font('Helvetica-Oblique').text('Über byndl.de digital abgeschlossen', { align: 'center' });
    
    // === NEUE SEITE: LEISTUNGSVERZEICHNIS ===
    if (lvData && lvData.positions && lvData.positions.length > 0) {
      doc.addPage();
      
      doc.fontSize(18).font('Helvetica-Bold').text('ANLAGE 1: LEISTUNGSVERZEICHNIS', { align: 'center' });
      doc.moveDown(1);
      
      doc.fontSize(12).font('Helvetica');
      doc.text(`Gewerk: ${order.trade_name}`, { align: 'center' });
      doc.moveDown(2);
      
      // Tabellenkopf
      const tableTop = doc.y;
      const colWidths = {
        pos: 40,
        title: 180,
        quantity: 60,
        unit: 40,
        unitPrice: 70,
        total: 80
      };
      
      doc.fontSize(9).font('Helvetica-Bold');
      
      let xPos = 50;
      doc.text('Pos.', xPos, tableTop, { width: colWidths.pos, align: 'left' });
      xPos += colWidths.pos;
      doc.text('Bezeichnung', xPos, tableTop, { width: colWidths.title, align: 'left' });
      xPos += colWidths.title;
      doc.text('Menge', xPos, tableTop, { width: colWidths.quantity, align: 'right' });
      xPos += colWidths.quantity;
      doc.text('Einh.', xPos, tableTop, { width: colWidths.unit, align: 'center' });
      xPos += colWidths.unit;
      doc.text('EP (€)', xPos, tableTop, { width: colWidths.unitPrice, align: 'right' });
      xPos += colWidths.unitPrice;
      doc.text('GP (€)', xPos, tableTop, { width: colWidths.total, align: 'right' });
      
      // Trennlinie
      doc.moveTo(50, doc.y + 5).lineTo(545, doc.y + 5).stroke();
      doc.moveDown(0.5);
      
      // Positionen
      doc.fontSize(8).font('Helvetica');
      
      lvData.positions.forEach((pos, index) => {
  if (doc.y > 700) {
    doc.addPage();
    doc.fontSize(8).font('Helvetica');
  }
  
  const startY = doc.y;
  const posTotal = (parseFloat(pos.quantity) || 0) * (parseFloat(pos.unitPrice) || 0);
  
  // Position
  xPos = 50;
  doc.text(pos.pos || index + 1, xPos, startY, { width: colWidths.pos, align: 'left' });
  
  // Bezeichnung (mit Umbruch)
  xPos += colWidths.pos;
  const titleHeight = doc.heightOfString(pos.title, { width: colWidths.title - 5 });
  doc.text(pos.title, xPos, startY, { width: colWidths.title - 5, align: 'left' });
  
  // Menge - MIT parseFloat!
  xPos += colWidths.title;
  doc.text((parseFloat(pos.quantity) || 0).toFixed(2), xPos, startY, { width: colWidths.quantity, align: 'right' });
  
  // Einheit
  xPos += colWidths.quantity;
  doc.text(pos.unit || 'Stk', xPos, startY, { width: colWidths.unit, align: 'center' });
  
  // EP - MIT parseFloat!
  xPos += colWidths.unit;
  doc.text((parseFloat(pos.unitPrice) || 0).toFixed(2), xPos, startY, { width: colWidths.unitPrice, align: 'right' });
  
  // GP - MIT parseFloat!
  xPos += colWidths.unitPrice;
  doc.text(posTotal.toFixed(2), xPos, startY, { width: colWidths.total, align: 'right' });
        
        doc.moveDown(Math.max(1, titleHeight / 12));
        
        // Beschreibung (falls vorhanden)
        if (pos.description) {
          doc.fontSize(7).font('Helvetica-Oblique');
          doc.text(pos.description, 90, doc.y, { width: 450 });
          doc.moveDown(0.5);
          doc.fontSize(8).font('Helvetica');
        }
        
        // Trennlinie
        if (index < lvData.positions.length - 1) {
          doc.moveTo(50, doc.y).lineTo(545, doc.y).stroke();
          doc.moveDown(0.3);
        }
      });
      
      // Summen
doc.moveDown(1);
doc.fontSize(10).font('Helvetica-Bold');
doc.moveTo(50, doc.y).lineTo(545, doc.y).lineWidth(2).stroke();
doc.moveDown(0.5);

const bundleDiscountLV = order.bundle_discount || 0;
const discountAmountLV = bundleDiscountLV > 0 ? (netto * bundleDiscountLV / 100) : 0;
const nettoAfterDiscountLV = netto - discountAmountLV;

xPos = 370;
doc.text('Netto-Summe:', xPos, doc.y, { width: 100, align: 'left' });
doc.text(formatCurrency(netto), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });

if (bundleDiscountLV > 0) {
  doc.moveDown(0.5);
  doc.fontSize(9).font('Helvetica');
  doc.text(`Bündelrabatt (${bundleDiscountLV}%):`, xPos, doc.y, { width: 100, align: 'left' });
  doc.text(`-${formatCurrency(discountAmountLV)}`, xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
  
  doc.moveDown(0.5);
  doc.text('Netto nach Rabatt:', xPos, doc.y, { width: 100, align: 'left' });
  doc.text(formatCurrency(nettoAfterDiscountLV), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
}

doc.moveDown(0.5);
doc.fontSize(9).font('Helvetica');
doc.text('zzgl. 19% MwSt:', xPos, doc.y, { width: 100, align: 'left' });
doc.text(formatCurrency(mwst), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });

doc.moveDown(0.5);
doc.fontSize(11).font('Helvetica-Bold');
doc.moveTo(xPos, doc.y).lineTo(xPos + 180, doc.y).stroke();
doc.moveDown(0.3);
doc.text('Gesamt (Brutto):', xPos, doc.y, { width: 100, align: 'left' });
doc.text(formatCurrency(brutto), xPos + 100, doc.y, { width: 80, align: 'right', continued: false });
    }
    
    // Footer auf allen Seiten - KORRIGIERT (verhindert leere Seiten)
const range = doc.bufferedPageRange();
for (let i = 0; i < range.count; i++) {
  doc.switchToPage(range.start + i);
  
  // Footer am unteren Rand
  const bottomY = doc.page.height - 50;
  
  doc.fontSize(8).font('Helvetica');
  doc.text(
    `Seite ${i + 1} von ${range.count}`,
    50,
    bottomY,
    { align: 'center', width: doc.page.width - 100 }
  );
  
  doc.fontSize(7).font('Helvetica-Oblique');
  doc.text(
    'byndl GmbH - Die digitale Handwerkerplattform',
    50,
    bottomY + 15,
    { align: 'center', width: doc.page.width - 100 }
  );
}
    
    // PDF abschließen
    doc.end();
    
  } catch (error) {
    console.error('Error generating PDF:', error);
    res.status(500).json({ error: 'Fehler beim Erstellen des PDFs' });
  }
});

// Hilfsfunktion für Abschnitte
function addSection(doc, title) {
  if (doc.y > 650) {
    doc.addPage();
  }
  
  doc.moveDown(1);
  doc.fontSize(11).font('Helvetica-Bold');
  doc.text('-'.repeat(80));
  doc.moveDown(0.3);
  doc.text(title);
  doc.moveDown(0.3);
  doc.fontSize(10).font('Helvetica');
}

// Leistung abnehmen
app.post('/api/orders/:orderId/accept-completion', async (req, res) => {
  try {
    const { orderId } = req.params;
    
    await query('BEGIN');
    
    // Update Order Status
    await query(
      `UPDATE orders 
       SET status = 'completed', 
           accepted_at = NOW(),
           updated_at = NOW()
       WHERE id = $1`,
      [orderId]
    );
    
    // Lade Handwerker-Daten für E-Mail
    const orderData = await query(
      `SELECT 
        o.*,
        h.email as handwerker_email,
        h.company_name,
        t.name as trade_name,
        b.name as bauherr_name
       FROM orders o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN trades t ON o.trade_id = t.id
       JOIN bauherren b ON o.bauherr_id = b.id
       WHERE o.id = $1`,
      [orderId]
    );

    // Notification für Handwerker erstellen
await query(
  `INSERT INTO notifications 
   (user_type, user_id, type, reference_id, message, metadata, created_at)
   VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
  [
    'handwerker',
    orderData.rows[0].handwerker_id,  // Nutze die bereits geladenen Daten
    'work_completed',
    orderId,
    'Leistung wurde abgenommen - Auftrag abgeschlossen',
    JSON.stringify({
      senderName: orderData.rows[0].bauherr_name,
      orderId: orderId,
      tradeName: orderData.rows[0].trade_name,
      amount: orderData.rows[0].amount,
      completedAt: new Date().toISOString()
    })
  ]
);
    
    if (orderData.rows.length > 0 && transporter) {
      const order = orderData.rows[0];
      
      await transporter.sendMail({
        from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
        to: order.handwerker_email,
        subject: `✅ Leistung abgenommen - Auftrag #${orderId}`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: linear-gradient(135deg, #10b981 0%, #059669 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0;">
              <h1>✅ Leistung abgenommen!</h1>
            </div>
            
            <div style="padding: 30px; background: #f7f7f7;">
              <p>Sehr geehrtes Team von ${order.company_name},</p>
              
              <p><strong>${order.bauherr_name}</strong> hat Ihre Leistung für <strong>${order.trade_name}</strong> erfolgreich abgenommen.</p>
              
              <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #10b981;">Details:</h3>
                <table style="width: 100%;">
                  <tr>
                    <td style="padding: 8px 0;"><strong>Auftrag:</strong></td>
                    <td style="text-align: right;">#${orderId}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0;"><strong>Gewerk:</strong></td>
                    <td style="text-align: right;">${order.trade_name}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0;"><strong>Abnahmedatum:</strong></td>
                    <td style="text-align: right;">${new Date().toLocaleDateString('de-DE')}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0;"><strong>Auftragssumme:</strong></td>
                    <td style="text-align: right;">${formatCurrency(order.amount)}</td>
                  </tr>
                </table>
              </div>
              
              <div style="background: #dbeafe; padding: 15px; border-left: 4px solid #3b82f6; border-radius: 4px; margin: 20px 0;">
                <strong>📋 Nächste Schritte:</strong><br>
                • Gewährleistungsfrist beginnt ab heute<br>
                • Schlusszahlung erfolgt gemäß Vertrag<br>
                • Dokumentation für Ihre Unterlagen
              </div>
              
              <p>Vielen Dank für die erfolgreiche Zusammenarbeit!</p>
            </div>
            
            <div style="text-align: center; padding: 20px; color: #666; font-size: 12px; background: #e9ecef;">
              <p>© 2025 byndl - Die digitale Handwerkerplattform</p>
            </div>
          </div>
        `
      });
    }
    
    await query('COMMIT');
    
    res.json({ 
      success: true,
      message: 'Leistung erfolgreich abgenommen. Handwerker wurde benachrichtigt.'
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error accepting completion:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============= AUSSCHREIBUNGS-SYSTEM =============

// kleiner Helfer
function safeParseJSON(v) {
  if (!v) return null;
  if (typeof v !== 'string') return v;
  try { return JSON.parse(v); } catch { return null; }
}

// Gemeinsamer Handler NUR für die alte URL
async function createProjectTenders(req, res) {
  const { projectId } = req.params;
  const { tradeIds, timeframe, bundleSettings } = req.body || {};

  try {
    await query('BEGIN');

    // 1) Projekt + Bauherr laden
    const projectResult = await query(
      `SELECT p.*, b.zip AS bauherr_zip, b.id AS bauherr_id, b.email AS bauherr_email, b.name AS bauherr_name
         FROM projects p
         JOIN bauherren b ON p.bauherr_id = b.id
        WHERE p.id = $1`,
      [projectId]
    );
    if (projectResult.rows.length === 0) {
      throw new Error('Projekt nicht gefunden');
    }
    const project = projectResult.rows[0];

    // 2) ZIP prüfen (Projekt oder Bauherr)
    const targetZip = project.zip_code || project.bauherr_zip;
    if (!targetZip) {
      throw new Error('Projekt hat keine gültige PLZ für Handwerker-Matching');
    }

    // 3) Gewerke bestimmen
    let tradesToProcess;
    if (tradeIds === 'all') {
      tradesToProcess = await query(
        `SELECT DISTINCT t.*
           FROM trades t
           JOIN project_trades pt ON t.id = pt.trade_id
          WHERE pt.project_id = $1
            AND t.code != 'INT'
          ORDER BY t.name`,
        [projectId]
      );
    } else {
      const ids = Array.isArray(tradeIds) ? tradeIds : (tradeIds ? [tradeIds] : []);
      if (ids.length === 0) {
        await query('ROLLBACK');
        return res.status(400).json({ error: 'Keine Gewerke übergeben (tradeIds) und "all" nicht gesetzt' });
      }
      tradesToProcess = await query(
        `SELECT * FROM trades WHERE id = ANY($1::int[]) ORDER BY name`,
        [ids]
      );
    }
    if (tradesToProcess.rows.length === 0) {
      await query('ROLLBACK');
      return res.status(400).json({ error: 'Keine passenden Gewerke gefunden' });
    }

    const createdTenders = [];
    const skipped = []; // z.B. { tradeId, tradeName, reason: 'no_lv'|'exists' }

    // 4) pro Gewerk Tender erzeugen
    for (const trade of tradesToProcess.rows) {
      // 4a) Schon vorhanden?
      const existingTender = await query(
        `SELECT id
           FROM tenders
          WHERE project_id = $1
            AND trade_id   = $2
            AND status    != 'open'`,
        [projectId, trade.id]
      );
      if (existingTender.rows.length > 0) {
        skipped.push({ tradeId: trade.id, tradeName: trade.name, reason: 'exists' });
        continue;
      }

      // 4b) LV laden (ohne LV kein Tender)
      const lvResult = await query(
        `SELECT * FROM lvs WHERE project_id = $1 AND trade_id = $2`,
        [projectId, trade.id]
      );
      if (lvResult.rows.length === 0) {
        skipped.push({ tradeId: trade.id, tradeName: trade.name, reason: 'no_lv' });
        continue;
      }

      const lv = lvResult.rows[0];
      const lvContent = safeParseJSON(lv.content) || lv.content || {};
      const estimatedValue = Number(lvContent?.totalSum || 0);

      // 4c) Tender anlegen
      const tenderInsert = await query(
        `INSERT INTO tenders (
           project_id, trade_id, status,
           deadline, estimated_value, timeframe,
           lv_data, created_at
         ) VALUES (
           $1, $2, 'open',
           NOW() + INTERVAL '14 days', $3, $4,
           $5, NOW()
         )
         RETURNING id, deadline`,
        [
          projectId,
          trade.id,
          estimatedValue,
          timeframe || project.timeframe || 'Nach Absprache',
          JSON.stringify(lvContent || {})
        ]
      );
      const tenderId = tenderInsert.rows[0].id;

      console.log(`✅ [TENDER] Created tender ${tenderId}`);
      
try {
  console.log(`🔍 [TENDER] Starting bundle check for ${tenderId}`);
  await checkAndAddToExistingBundle(tenderId);
  console.log(`✅ [TENDER] Bundle check completed`);
} catch (bundleErr) {
  console.error(`❌ [TENDER] Bundle check failed:`, bundleErr);
  // Fehler loggen aber nicht werfen - weiter machen
}

console.log(`🔍 [TENDER] Starting handwerker matching...`);
      
      // 4d) Matching (PostGIS)
      await query(`SELECT zip, latitude, longitude FROM zip_codes WHERE zip = $1`, [targetZip]); // nur Check

      const matchingHandwerker = await query(
        `SELECT DISTINCT h.*,
                CASE
                  WHEN z1.latitude IS NOT NULL AND z2.latitude IS NOT NULL THEN
                    ST_Distance(
                      ST_MakePoint(z1.longitude, z1.latitude)::geography,
                      ST_MakePoint(z2.longitude, z2.latitude)::geography
                    ) / 1000
                  WHEN h.zip_code = $1 THEN 0
                  ELSE h.action_radius
                END AS distance_km
           FROM handwerker h
           JOIN handwerker_trades ht ON h.id = ht.handwerker_id
      LEFT JOIN zip_codes z1 ON z1.zip::text = h.zip_code::text
      LEFT JOIN zip_codes z2 ON z2.zip::text = $1::text
          WHERE ht.trade_id = $2
            AND h.active = true
            AND (
              h.zip_code = $1
              OR (
                z1.latitude IS NOT NULL AND z1.longitude IS NOT NULL
                AND z2.latitude IS NOT NULL AND z2.longitude IS NOT NULL
                AND ST_DWithin(
                  ST_MakePoint(z1.longitude, z1.latitude)::geography,
                  ST_MakePoint(z2.longitude, z2.latitude)::geography,
                  GREATEST(h.action_radius * 1000, 1)
                )
              )
              OR (
                (z1.latitude IS NULL OR z2.latitude IS NULL)
                AND h.action_radius >= 30
              )
            )
        ORDER BY distance_km ASC`,
        [targetZip, trade.id]
      );

      // 4e) HW verknüpfen + Tracking + (optional) Mail
      for (const hw of matchingHandwerker.rows) {
        try {
          await query(
            `INSERT INTO tender_handwerker (tender_id, handwerker_id, status, notified_at, distance_km)
             VALUES ($1, $2, 'pending', NOW(), $3)
             ON CONFLICT (tender_id, handwerker_id) DO NOTHING`,
            [tenderId, hw.id, Math.round(hw.distance_km || 0)]
          );

          await query(
            `INSERT INTO tender_handwerker_status (tender_id, handwerker_id, status, created_at)
             VALUES ($1, $2, 'sent', NOW())
             ON CONFLICT (tender_id, handwerker_id)
             DO UPDATE SET status = 'sent', created_at = NOW()`,
            [tenderId, hw.id]
          );

          if (typeof transporter !== 'undefined' && transporter && hw.email) {
            try {
              await transporter.sendMail({
                from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
                to: hw.email,
                subject: `Neue Ausschreibung: ${trade.name} - ${project.category || 'Bauprojekt'}`,
                html: `
                  <!doctype html>
                  <html><body style="font-family:Arial,sans-serif;">
                    <h2>Neue passende Ausschreibung</h2>
                    <p>Guten Tag ${hw.company_name || hw.contact_person || ''},</p>
                    <p>Es gibt eine neue Ausschreibung in Ihrer Region.</p>
                    <table>
                      <tr><td><strong>Gewerk:</strong></td><td>${trade.name}</td></tr>
                      <tr><td><strong>Standort:</strong></td><td>${targetZip} (${Math.round(hw.distance_km || 0)} km)</td></tr>
                      <tr><td><strong>Geschätztes Volumen:</strong></td><td>${formatCurrency(estimatedValue)}</td></tr>
                      <tr><td><strong>Angebotsfrist:</strong></td><td>${new Date(tenderInsert.rows[0].deadline).toLocaleDateString('de-DE')}</td></tr>
                    </table>
                    <p><a href="https://byndl.de/handwerker/dashboard">Zum Dashboard →</a></p>
                  </body></html>`
              });

              await query(
                `INSERT INTO email_logs (recipient_email, email_type, status, sent_at, handwerker_id, metadata)
                 VALUES ($1,'tender_notification','sent',NOW(),$2,$3)`,
                [hw.email, hw.id, JSON.stringify({ tender_id: tenderId, trade_id: trade.id })]
              );
            } catch (mailErr) {
              console.error('E-Mail (HW) fehlgeschlagen:', mailErr?.message || mailErr);
            }
          }
        } catch (linkErr) {
          console.error(`Linking HW ${hw.id} fehlgeschlagen:`, linkErr?.message || linkErr);
        }
      }

      createdTenders.push({
        tenderId,
        tradeId: trade.id,
        tradeName: trade.name,
        matchedHandwerker: matchingHandwerker.rows.length
      });
    }

    // 5) Bundles automatisch prüfen und erstellen
if (typeof checkAndCreateBundles === 'function' && createdTenders.length > 0) {
  try {
    await checkAndCreateBundles(project, createdTenders);
  } catch (bundleErr) {
    console.warn('Bundle-Erstellung fehlgeschlagen:', bundleErr?.message || bundleErr);
  }
}

    // 6) E-Mail an Bauherr (Zusammenfassung)
    if (
      createdTenders.length > 0 &&
      project.bauherr_email &&
      typeof transporter !== 'undefined' &&
      transporter
    ) {
      const totalHw = createdTenders.reduce((s, t) => s + (t.matchedHandwerker || 0), 0);
      try {
        await transporter.sendMail({
          from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
          to: project.bauherr_email,
          subject: 'Ihre Ausschreibung wurde versendet',
          html: `
            <!doctype html>
            <html><body style="font-family:Arial,sans-serif;">
              <h2>Ihre Ausschreibung ist raus</h2>
              <p>Hallo ${project.bauherr_name || ''},</p>
              <p>Wir haben Ihre Ausschreibung an passende Handwerker versendet.</p>
              <ul>
                ${createdTenders
                  .map(t => `<li><strong>${t.tradeName}:</strong> ${t.matchedHandwerker} Handwerker benachrichtigt</li>`)
                  .join('')}
              </ul>
              <p><strong>Gesamt:</strong> ${totalHw} Handwerker</p>
              <p>Den Status sehen Sie jederzeit in Ihrem Dashboard.</p>
            </body></html>`
        });
      } catch (mailErr) {
        console.error('E-Mail (Bauherr) fehlgeschlagen:', mailErr?.message || mailErr);
      }
    }

    await query('COMMIT');
    return res.json({
      success: true,
      message: `${createdTenders.length} Ausschreibung(en) erstellt`,
      tenders: createdTenders,
      skipped
    });
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error creating tenders:', error);
    return res.status(500).json({ error: error.message || 'Interner Fehler' });
  }
}

// Behalte NUR diese Route:
app.post('/api/projects/:projectId/tender/create', createProjectTenders);

// Route für nachträgliches Matching von neuen Handwerkern zu bestehenden Tendern
app.post('/api/admin/rematch-tenders', async (req, res) => {
  const { 
    tenderId,      // Optional: Nur eine spezifische Tender
    tradeId,       // Optional: Nur ein spezifisches Gewerk
    handwerkerId,  // Optional: Nur einen spezifischen Handwerker
    dryRun = false // Optional: Simulationsmodus ohne DB-Änderungen
  } = req.body;

  try {
    await query('BEGIN');

    // 1) Relevante Tenders laden
    let tenderQuery = `
      SELECT DISTINCT t.*, p.zip_code as project_zip, tr.name as trade_name, tr.code as trade_code
      FROM tenders t
      JOIN projects p ON t.project_id = p.id
      JOIN trades tr ON t.trade_id = tr.id
      WHERE t.status = 'open'`;
    
    const tenderParams = [];
    let paramCount = 0;
    
    if (tenderId) {
      tenderQuery += ` AND t.id = $${++paramCount}`;
      tenderParams.push(tenderId);
    }
    
    if (tradeId) {
      tenderQuery += ` AND t.trade_id = $${++paramCount}`;
      tenderParams.push(tradeId);
    }
    
    tenderQuery += ` ORDER BY t.created_at DESC`;
    
    const tendersResult = await query(tenderQuery, tenderParams);
    
    if (tendersResult.rows.length === 0) {
      await query('ROLLBACK');
      return res.json({ 
        success: true, 
        message: 'Keine offenen Tenders gefunden',
        matched: 0 
      });
    }

    const matchResults = [];
    let totalNewMatches = 0;
    let totalSkipped = 0;

    // 2) Pro Tender neue Handwerker suchen
    for (const tender of tendersResult.rows) {
      const targetZip = tender.project_zip;
      
      if (!targetZip) {
        console.warn(`Tender ${tender.id} hat keine Projekt-PLZ`);
        continue;
      }

      // 3) Bereits verknüpfte Handwerker IDs holen
      const existingHandwerkerResult = await query(
        `SELECT handwerker_id FROM tender_handwerker WHERE tender_id = $1`,
        [tender.id]
      );
      const existingHandwerkerIds = existingHandwerkerResult.rows.map(r => r.handwerker_id);

      // 4) Neue passende Handwerker finden (gleiche Logik wie in createProjectTenders)
      let matchQuery = `
        SELECT DISTINCT h.*,
          CASE
            WHEN z1.latitude IS NOT NULL AND z2.latitude IS NOT NULL THEN
              ST_Distance(
                ST_MakePoint(z1.longitude, z1.latitude)::geography,
                ST_MakePoint(z2.longitude, z2.latitude)::geography
              ) / 1000
            WHEN h.zip_code = $1 THEN 0
            ELSE h.action_radius
          END AS distance_km
        FROM handwerker h
        JOIN handwerker_trades ht ON h.id = ht.handwerker_id
        LEFT JOIN zip_codes z1 ON z1.zip::text = h.zip_code::text
        LEFT JOIN zip_codes z2 ON z2.zip::text = $1::text
        WHERE ht.trade_id = $2
          AND h.active = true`;
      
      // Nur neue Handwerker (nicht bereits verknüpft)
      if (existingHandwerkerIds.length > 0) {
        matchQuery += ` AND h.id NOT IN (${existingHandwerkerIds.join(',')})`;
      }

      // Optional: Nur einen spezifischen Handwerker
      if (handwerkerId) {
        matchQuery += ` AND h.id = ${handwerkerId}`;
      }

      // Standard PostGIS Matching-Bedingungen
      matchQuery += `
          AND (
            h.zip_code = $1
            OR (
              z1.latitude IS NOT NULL AND z1.longitude IS NOT NULL
              AND z2.latitude IS NOT NULL AND z2.longitude IS NOT NULL
              AND ST_DWithin(
                ST_MakePoint(z1.longitude, z1.latitude)::geography,
                ST_MakePoint(z2.longitude, z2.latitude)::geography,
                GREATEST(h.action_radius * 1000, 1)
              )
            )
            OR (
              (z1.latitude IS NULL OR z2.latitude IS NULL)
              AND h.action_radius >= 30
            )
          )
        ORDER BY distance_km ASC`;

      const newHandwerker = await query(matchQuery, [targetZip, tender.trade_id]);
      
      const tenderMatchInfo = {
        tenderId: tender.id,
        tradeCode: tender.trade_code,
        tradeName: tender.trade_name,
        projectZip: targetZip,
        newMatches: [],
        existingCount: existingHandwerkerIds.length
      };

      // 5) Neue Handwerker verknüpfen
      for (const hw of newHandwerker.rows) {
        if (!dryRun) {
          try {
            // In tender_handwerker eintragen
            await query(
              `INSERT INTO tender_handwerker (tender_id, handwerker_id, status, notified_at, distance_km)
               VALUES ($1, $2, 'pending', NOW(), $3)
               ON CONFLICT (tender_id, handwerker_id) DO NOTHING`,
              [tender.id, hw.id, Math.round(hw.distance_km || 0)]
            );

            // Status tracking
            await query(
              `INSERT INTO tender_handwerker_status (tender_id, handwerker_id, status, created_at)
               VALUES ($1, $2, 'rematched', NOW())
               ON CONFLICT (tender_id, handwerker_id)
               DO UPDATE SET status = 'rematched', created_at = NOW()`,
              [tender.id, hw.id]
            );

            // Optional: E-Mail an neu gematchten Handwerker
            if (hw.email && typeof transporter !== 'undefined' && transporter) {
              try {
                const estimatedValue = Number(tender.estimated_value || 0);
                await transporter.sendMail({
                  from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
                  to: hw.email,
                  subject: `Neue Ausschreibung: ${tender.trade_name}`,
                  html: `
                    <!doctype html>
                    <html><body style="font-family:Arial,sans-serif;">
                      <h2>Neue passende Ausschreibung in Ihrer Region</h2>
                      <p>Guten Tag ${hw.company_name || hw.contact_person || ''},</p>
                      <p>Eine Ausschreibung in Ihrer Nähe passt zu Ihrem Gewerk.</p>
                      <table style="border-collapse:collapse;">
                        <tr><td style="padding:5px;"><strong>Gewerk:</strong></td><td>${tender.trade_name}</td></tr>
                        <tr><td style="padding:5px;"><strong>PLZ:</strong></td><td>${targetZip}</td></tr>
                        <tr><td style="padding:5px;"><strong>Entfernung:</strong></td><td>${Math.round(hw.distance_km || 0)} km</td></tr>
                        ${estimatedValue > 0 ? `<tr><td style="padding:5px;"><strong>Volumen:</strong></td><td>${formatCurrency(estimatedValue)}</td></tr>` : ''}
                        <tr><td style="padding:5px;"><strong>Frist:</strong></td><td>${tender.deadline ? new Date(tender.deadline).toLocaleDateString('de-DE') : 'Offen'}</td></tr>
                      </table>
                      <p style="margin-top:20px;">
                        <a href="https://byndl.de/handwerker/dashboard" 
                           style="background:#007bff;color:white;padding:10px 20px;text-decoration:none;border-radius:5px;">
                          → Jetzt Angebot abgeben
                        </a>
                      </p>
                    </body></html>`
                });
              } catch (mailErr) {
                console.error(`E-Mail an HW ${hw.id} fehlgeschlagen:`, mailErr?.message);
              }
            }

            totalNewMatches++;
          } catch (err) {
            console.error(`Fehler beim Verknüpfen HW ${hw.id} mit Tender ${tender.id}:`, err?.message);
            totalSkipped++;
          }
        } else {
          totalNewMatches++; // Im dry-run nur zählen
        }

        tenderMatchInfo.newMatches.push({
          handwerkerId: hw.id,
          companyName: hw.company_name,
          distance: Math.round(hw.distance_km || 0)
        });
      }

      if (tenderMatchInfo.newMatches.length > 0) {
        matchResults.push(tenderMatchInfo);
      }
    }

    // 6) Statistik für Admin
    const stats = {
      tendersProcessed: tendersResult.rows.length,
      totalNewMatches,
      totalSkipped,
      details: matchResults
    };

    if (!dryRun) {
      await query('COMMIT');
      
      // Optional: Log für Admin
      await query(
        `INSERT INTO admin_logs (action, metadata, created_at, created_by)
         VALUES ('rematch_tenders', $1, NOW(), 'system')`,
        [JSON.stringify(stats)]
      ).catch(e => console.log('Admin log fehlgeschlagen:', e.message));
    } else {
      await query('ROLLBACK');
    }

    return res.json({
      success: true,
      message: dryRun 
        ? `Simulation: ${totalNewMatches} neue Matches gefunden (keine Änderungen vorgenommen)`
        : `${totalNewMatches} neue Handwerker zu bestehenden Ausschreibungen hinzugefügt`,
      dryRun,
      stats
    });

  } catch (error) {
    await query('ROLLBACK');
    console.error('Fehler beim Rematch:', error);
    return res.status(500).json({ 
      error: error.message || 'Interner Fehler beim nachträglichen Matching'
    });
  }
});

// ============================================
// BUNDLE EXPANSION - Neue Projekte zu Bundles hinzufügen
// ============================================

async function checkAndAddToExistingBundle(tenderId) {
  console.log(`🔍 [BUNDLE-EXPANSION] Starting check for tender ${tenderId}`);
  
  try {
    // Hole Tender-Details
    const tenderResult = await query(
      `SELECT tn.*, p.zip_code, p.street, p.house_number, p.city,
              COALESCE(p.geocoded_lat, z.latitude) as lat,
              COALESCE(p.geocoded_lng, z.longitude) as lng,
              t.code as trade_code
       FROM tenders tn
       JOIN projects p ON tn.project_id = p.id
       JOIN trades t ON tn.trade_id = t.id
       LEFT JOIN zip_codes z ON p.zip_code = z.zip
       WHERE tn.id = $1 AND tn.bundle_id IS NULL`,
      [tenderId]
    );
    
    console.log(`📊 [BUNDLE-EXPANSION] Tender result:`, tenderResult.rows);
    
    if (tenderResult.rows.length === 0) {
      console.log(`⚠️ [BUNDLE-EXPANSION] Tender ${tenderId} not found or already in bundle`);
      return;
    }
    
    const tender = tenderResult.rows[0];
    console.log(`✅ [BUNDLE-EXPANSION] Tender ${tenderId} - Trade: ${tender.trade_code}, Coords: ${tender.lat}, ${tender.lng}`);
    
    // Finde passende offene Bundles
    const bundlesResult = await query(
      `SELECT b.id, b.region, b.trade_code, b.current_projects,
              array_agg(
                json_build_object(
                  'lat', COALESCE(p2.geocoded_lat, z2.latitude),
                  'lng', COALESCE(p2.geocoded_lng, z2.longitude)
                )
              ) as project_coords
       FROM bundles b
       JOIN tenders tn2 ON tn2.bundle_id = b.id
       JOIN projects p2 ON tn2.project_id = p2.id
       LEFT JOIN zip_codes z2 ON p2.zip_code = z2.zip
       WHERE b.trade_code = $1
       AND b.status IN ('forming', 'open', 'offered')
       AND b.current_projects < b.max_projects
       GROUP BY b.id, b.region, b.trade_code, b.current_projects`,
      [tender.trade_code]
    );
    
    console.log(`📦 [BUNDLE-EXPANSION] Found ${bundlesResult.rows.length} potential bundles for trade ${tender.trade_code}`);
    console.log(`📦 [BUNDLE-EXPANSION] Bundles:`, JSON.stringify(bundlesResult.rows, null, 2));
    
    if (bundlesResult.rows.length === 0) {
      console.log(`⚠️ [BUNDLE-EXPANSION] No bundles found for trade ${tender.trade_code}`);
      return;
    }
    
    // Prüfe Distanz zu jedem Bundle
    for (const bundle of bundlesResult.rows) {
      console.log(`🔍 [BUNDLE-EXPANSION] Checking bundle ${bundle.id}`);
      
      let maxDistance = 0;
      let allWithinRange = true;
      
      for (const coord of bundle.project_coords) {
        if (!coord.lat || !coord.lng || !tender.lat || !tender.lng) {
          console.log(`⚠️ [BUNDLE-EXPANSION] Missing coordinates - skipping`);
          continue;
        }
        
        const distance = haversineDistance(
          { lat: parseFloat(tender.lat), lng: parseFloat(tender.lng) },
          { lat: parseFloat(coord.lat), lng: parseFloat(coord.lng) }
        );
        
        console.log(`📏 [BUNDLE-EXPANSION] Distance: ${distance.toFixed(2)} km`);
        
        if (distance > maxDistance) maxDistance = distance;
        if (distance > 15) {
          allWithinRange = false;
          console.log(`❌ [BUNDLE-EXPANSION] Distance ${distance.toFixed(2)} km exceeds 15km limit`);
          break;
        }
      }
      
      if (allWithinRange) {
        console.log(`✅ [BUNDLE-EXPANSION] Bundle ${bundle.id} matches! Adding tender ${tenderId}...`);
        
        await query(
          `UPDATE tenders 
           SET bundle_id = $1 
           WHERE id = $2`,
          [bundle.id, tenderId]
        );
        
        await query(
          `UPDATE bundles 
           SET current_projects = current_projects + 1,
               total_volume = total_volume + $1
           WHERE id = $2`,
          [tender.estimated_value || 0, bundle.id]
        );
        
        console.log(`🎉 [BUNDLE-EXPANSION] Tender ${tenderId} successfully added to Bundle ${bundle.id}`);
        return;
      } else {
        console.log(`❌ [BUNDLE-EXPANSION] Bundle ${bundle.id} rejected - distance too far`);
      }
    }
    
    console.log(`⚠️ [BUNDLE-EXPANSION] No suitable bundle found for tender ${tenderId}`);
    
  } catch (error) {
    console.error(`❌ [BUNDLE-EXPANSION] Error:`, error);
  }
}

// ============================================
// 5. BUNDLE MANAGEMENT (PROJEKTBÜNDEL)
// ============================================

// Verfügbare Bündel für Handwerker laden
app.get('/api/handwerker/:identifier/bundles', async (req, res) => {
  try {
    const { identifier } = req.params;
    let handwerkerId;
    
    // Flexible ID-Erkennung
    if (/^\d+$/.test(identifier)) {
      handwerkerId = parseInt(identifier);
    } else {
      const result = await query(
        'SELECT id FROM handwerker WHERE company_id = $1',
        [identifier]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Handwerker nicht gefunden' });
      }
      handwerkerId = result.rows[0].id;
    }
    
    console.log(`Loading bundles for handwerker_id: ${handwerkerId}`);
    
    // Handwerker-Daten laden (für Firmenadresse)
    const handwerkerResult = await query(
      `SELECT h.*, z.latitude, z.longitude 
       FROM handwerker h
       LEFT JOIN zip_codes z ON h.zip_code = z.zip
       WHERE h.id = $1`,
      [handwerkerId]
    );
    
    if (handwerkerResult.rows.length === 0) {
      return res.status(404).json({ error: 'Handwerker nicht gefunden' });
    }
    
    const handwerker = handwerkerResult.rows[0];
    
    // Handwerker-Trades laden
    const tradesResult = await query(
      `SELECT ht.trade_id, t.code as trade_code, t.name as trade_name
       FROM handwerker_trades ht
       JOIN trades t ON ht.trade_id = t.id
       WHERE ht.handwerker_id = $1`,
      [handwerkerId]
    );
    
    const tradeIds = tradesResult.rows.map(t => t.trade_id);
    const tradeCodes = tradesResult.rows.map(t => t.trade_code);
    
    if (tradeCodes.length === 0) {
      return res.json([]);
    }
    
    // Aktive Bündel finden
    const bundlesResult = await query(
      `SELECT 
        b.id as bundle_id,
        b.trade_code,
        b.region,
        b.status,
        t.name as trade_name,
        COUNT(DISTINCT tn.id) as tender_count,
        COUNT(DISTINCT tn.project_id) as project_count,
        SUM(tn.estimated_value) as total_volume,
        b.created_at,
        json_agg(
          json_build_object(
            'tender_id', tn.id,
            'project_id', p.id,
            'type', p.category || ' - ' || p.sub_category,
            'address', CONCAT(p.street, ' ', p.house_number, ', ', p.zip_code, ' ', p.city),
            'zip', p.zip_code,
            'city', p.city,
            'lat', COALESCE(p.geocoded_lat, z.latitude),
            'lng', COALESCE(p.geocoded_lng, z.longitude),
            'has_exact_coords', CASE WHEN p.geocoded_lat IS NOT NULL THEN true ELSE false END,
            'volume', tn.estimated_value,
            'timeframe', tn.timeframe,
            'deadline', tn.deadline
          )
        ) as projects
       FROM bundles b
       JOIN trades t ON b.trade_code = t.code
       JOIN tenders tn ON tn.bundle_id = b.id
       JOIN projects p ON tn.project_id = p.id
       LEFT JOIN zip_codes z ON p.zip_code = z.zip
       WHERE b.trade_code = ANY($1::varchar[])
AND b.status IN ('forming', 'open', 'offered')
AND tn.status = 'open'
AND NOT EXISTS (
  SELECT 1 FROM offers o 
  WHERE o.tender_id = tn.id 
  AND o.handwerker_id = $2
)
AND NOT EXISTS (
  -- Bundle nicht anzeigen wenn Handwerker bereits für dieses Bundle angeboten hat
  SELECT 1 FROM offers o2
  JOIN tenders tn2 ON o2.tender_id = tn2.id
  WHERE tn2.bundle_id = b.id
  AND o2.handwerker_id = $2
)
       GROUP BY b.id, b.trade_code, b.region, b.status, t.name, b.created_at
       HAVING COUNT(DISTINCT tn.id) >= 2`,
      [tradeCodes, handwerkerId]
    );

    // Bundles mit berechneten Daten aufbereiten
const bundles = bundlesResult.rows.map(bundle => {
  const projects = bundle.projects || [];
  
  // Geocode fehlende Projekte im Hintergrund
  projects.forEach(project => {
    if (!project.has_exact_coords) {
      ensureProjectGeocoded(project.project_id).catch(err => 
        console.error('Background geocoding failed:', err)
      );
    }
  });
  
  // Füge 100m Offset für alle Projekte hinzu
  const projectsWithOffset = projects.map(p => {
    if (p.lat && p.lng) {
      const offsetCoords = addRandomOffset(p.lat, p.lng, 100);
      return {
        ...p,
        lat: offsetCoords.lat,
        lng: offsetCoords.lng
      };
    }
    return p;
  });
  
  // Berechne maximale Distanz zwischen Projekten (MIT OFFSET)
  let maxDistance = 0;
  for (let i = 0; i < projectsWithOffset.length; i++) {
    for (let j = i + 1; j < projectsWithOffset.length; j++) {
      if (projectsWithOffset[i].lat && projectsWithOffset[i].lng && 
          projectsWithOffset[j].lat && projectsWithOffset[j].lng) {
        const dist = haversineDistance(
          { lat: projectsWithOffset[i].lat, lng: projectsWithOffset[i].lng },
          { lat: projectsWithOffset[j].lat, lng: projectsWithOffset[j].lng }
        );
        if (dist > maxDistance) maxDistance = dist;
      }
    }
  }
  
  // Berechne Gesamtfahrzeit zwischen allen Projekten (Projekt 1→2→3→...)
  let totalTravelTime = 0;
  if (projectsWithOffset.length > 1) {
    for (let i = 0; i < projectsWithOffset.length - 1; i++) {
      const p1 = projectsWithOffset[i];
      const p2 = projectsWithOffset[i + 1];
      
      if (p1.lat && p1.lng && p2.lat && p2.lng) {
        const distance = haversineDistance(
          { lat: p1.lat, lng: p1.lng },
          { lat: p2.lat, lng: p2.lng }
        );
        // Faktor 1.4 für realistische Straßenstrecke, 40 km/h Stadt-Durchschnitt
        totalTravelTime += Math.round((distance * 1.4) / 40 * 60);
      }
    }
  }
  
  return {
    id: bundle.bundle_id,
    trade: bundle.trade_name,
    trade_code: bundle.trade_code,
    region: bundle.region,
    projectCount: parseInt(bundle.project_count),
    totalVolume: parseFloat(bundle.total_volume || 0),
    maxDistance: Math.round(maxDistance * 10) / 10,
    totalTravelTime: totalTravelTime,
    status: bundle.status,
    created_at: bundle.created_at,
    projects: projectsWithOffset.map(p => ({
      ...p,
      volume: parseFloat(p.volume || 0)
    }))
  };
});
    
    res.json(bundles);
  } catch (error) {
    console.error('Error fetching bundles:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Bündel', details: error.message });
  }
});

// Bündel-Details mit Karte und LV-Daten laden
app.get('/api/bundles/:bundleId/details', async (req, res) => {
  try {
    const { bundleId } = req.params;
    
    const bundleResult = await query(
  `SELECT 
    b.*,
    t.name as trade_name,
    array_agg(
      json_build_object(
        'tender_id', tn.id,
        'project_id', p.id,
        'title', p.category || ' - ' || p.sub_category,
        'description', p.description,
        'zip', p.zip_code,
        'city', p.city,
        'lat', COALESCE(p.geocoded_lat, z.latitude),
        'lng', COALESCE(p.geocoded_lng, z.longitude),
        'has_exact_coords', CASE WHEN p.geocoded_lat IS NOT NULL THEN true ELSE false END,
        'lv_data', tn.lv_data,
        'estimated_value', tn.estimated_value,
        'timeframe', tn.timeframe,
        'deadline', tn.deadline
      )
    ) as projects
   FROM bundles b
   JOIN tenders tn ON tn.bundle_id = b.id
   JOIN projects p ON tn.project_id = p.id
   JOIN trades t ON b.trade_code = t.code
   LEFT JOIN zip_codes z ON p.zip_code = z.zip
   WHERE b.id = $1
   GROUP BY b.id, t.name`,
  [bundleId]
);

if (bundleResult.rows.length === 0) {
  return res.status(404).json({ error: 'Bündel nicht gefunden' });
}

const bundle = bundleResult.rows[0];

// Geocode fehlende Projekte im Hintergrund
for (const project of bundle.projects) {
  if (!project.has_exact_coords) {
    ensureProjectGeocoded(project.project_id).catch(err => 
      console.error('Background geocoding failed:', err)
    );
  }
}

// Füge 100m Offset für Anonymisierung hinzu
for (const project of bundle.projects) {
  if (project.lat && project.lng) {
    const offsetCoords = addRandomOffset(project.lat, project.lng, 100);
    project.lat = offsetCoords.lat;
    project.lng = offsetCoords.lng;
  }
}
    
    // Berechne Gesamt-LV für das Bündel
    let totalPositions = [];
    let totalSum = 0;
    
    for (const project of bundle.projects) {
      const lvData = typeof project.lv_data === 'string' 
        ? JSON.parse(project.lv_data) 
        : project.lv_data;
      
      if (lvData?.positions) {
        totalPositions = totalPositions.concat(
          lvData.positions.map(pos => ({
            ...pos,
            project_id: project.project_id,
            project_title: project.title
          }))
        );
        totalSum += lvData.totalSum || 0;
      }
    }
    
    bundle.combined_lv = {
      positions: totalPositions,
      totalSum: totalSum,
      projectCount: bundle.projects.length
    };

    // Berechne maximale Distanz für UI
const projectCoords = bundle.projects
  .filter(p => p.lat && p.lng)
  .map(p => ({ lat: parseFloat(p.lat), lng: parseFloat(p.lng) }));

bundle.maxDistance = projectCoords.length > 1 
  ? calculateMaxDistance(projectCoords) 
  : 0;

// Berechne Zentrum für Karte
bundle.center = calculateCenter(bundle.projects);
    
    // Berechne optimale Route (nur wenn Funktionen existieren)
    if (typeof calculateOptimalRoute === 'function') {
      bundle.optimal_route = calculateOptimalRoute(bundle.projects);
    }
    
    // Map-Daten aufbereiten
    bundle.map_data = {
      center: calculateCenter(bundle.projects),
      zoom: calculateZoomLevel(bundle.projects),
      markers: bundle.projects.map(p => ({
        id: p.project_id,
        position: { lat: parseFloat(p.lat), lng: parseFloat(p.lng) },
        title: p.title,
        address: `${p.address}, ${p.zip} ${p.city}`
      }))
    };
    
    res.json(bundle);
    
  } catch (error) {
    console.error('Error fetching bundle details:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Bündeldetails' });
  }
});

// Bündel-Angebot abgeben (angepasst)
app.post('/api/bundles/:bundleId/submit-offer', async (req, res) => {
  try {
    const { bundleId } = req.params;
    const { companyId, bundleDiscount, individualOffers } = req.body;
    
    await query('BEGIN');
    
    // CompanyId zu HandwerkerId konvertieren - flexibel
let handwerkerId;

// Prüfe ob companyId eine Zahl ist (dann ist es möglicherweise schon die handwerker_id)
if (typeof companyId === 'number' || /^\d+$/.test(companyId)) {
  // Versuche zuerst als handwerker_id
  const directResult = await query(
    'SELECT id FROM handwerker WHERE id = $1',
    [parseInt(companyId)]
  );
  
  if (directResult.rows.length > 0) {
    handwerkerId = directResult.rows[0].id;
  } else {
    // Falls nicht gefunden, versuche als company_id
    const companyResult = await query(
      'SELECT id FROM handwerker WHERE company_id = $1',
      [companyId]
    );
    
    if (companyResult.rows.length === 0) {
      throw new Error('Handwerker nicht gefunden');
    }
    handwerkerId = companyResult.rows[0].id;
  }
} else {
  // String company_id
  const handwerkerResult = await query(
    'SELECT id FROM handwerker WHERE company_id = $1',
    [companyId]
  );
  
  if (handwerkerResult.rows.length === 0) {
    throw new Error('Handwerker nicht gefunden');
  }
  handwerkerId = handwerkerResult.rows[0].id;
}
    
    // Tenders für dieses Bundle laden
    const bundleTenders = await query(
      `SELECT id as tender_id, project_id 
       FROM tenders 
       WHERE bundle_id = $1`,
      [bundleId]
    );
    
    const createdOffers = [];
    let totalAmount = 0;
    
    // Für jede Tender im Bündel ein Angebot erstellen
    for (const tender of bundleTenders.rows) {
      const offerData = individualOffers[tender.tender_id];
      
      if (!offerData) continue;
      
      // Prüfe ob bundle_id Spalte in offers existiert
      const offerResult = await query(
  `INSERT INTO offers (
    tender_id, handwerker_id, 
    amount, lv_data, notes,
    bundle_discount,
    is_bundle_offer,
    status, stage, created_at
  ) VALUES ($1, $2, $3, $4, $5, $6, $7, 'submitted', 1, NOW())
  RETURNING id`,
  [
    tender.tender_id, 
    handwerkerId, 
    offerData.amount, 
    JSON.stringify(offerData.positions), 
    offerData.notes, 
    bundleDiscount || 0,
    true
  ]
);
      
      createdOffers.push(offerResult.rows[0].id);
      totalAmount += offerData.amount;
    }
    
    // tender_handwerker Status aktualisieren
    for (const tender of bundleTenders.rows) {
      await query(
        `UPDATE tender_handwerker 
         SET offered_at = NOW(), status = 'offered'
         WHERE tender_id = $1 AND handwerker_id = $2`,
        [tender.tender_id, handwerkerId]
      );
    }
    
    await query('COMMIT');
    
    res.json({
      success: true,
      message: `Bündel-Angebot über ${createdOffers.length} Projekte abgegeben`,
      totalAmount: bundleDiscount ? totalAmount * (1 - bundleDiscount/100) : totalAmount,
      offerIds: createdOffers
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error submitting bundle offer:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============================================
// 8. HELPER FUNCTIONS
// ============================================

// Bundle-Check-Funktion - ANGEPASST an tatsächliche DB-Struktur
async function checkAndCreateBundles(project, tenders) {
  for (const tender of tenders) {
    // Suche nach ähnlichen Projekten in der Region
    const similarProjects = await query(
      `SELECT DISTINCT t.*, p.zip_code, p.bauherr_id, tr.code as trade_code
       FROM tenders t
       JOIN projects p ON t.project_id = p.id
       JOIN trades tr ON t.trade_id = tr.id
       JOIN zip_codes z1 ON z1.zip = p.zip_code
       JOIN zip_codes z2 ON z2.zip = $1
       WHERE t.trade_id = $2
       AND t.status = 'open'
       AND t.project_id != $3
       AND t.bundle_id IS NULL  -- Noch nicht in einem Bundle
       AND ST_DWithin(
         ST_MakePoint(z1.longitude, z1.latitude)::geography,
         ST_MakePoint(z2.longitude, z2.latitude)::geography,
         5000 -- 5km Radius für Bündel
       )`,
      [project.zip_code, tender.tradeId, project.id]
    );
    
    if (similarProjects.rows.length > 0) {
      const tradeCode = similarProjects.rows[0].trade_code;
      
      // Existierendes offenes Bundle suchen oder neues erstellen
      let bundleId;
      const existingBundle = await query(
        `SELECT id FROM bundles 
         WHERE trade_code = $1 
         AND region = $2 
         AND status = 'forming'
         AND (max_projects IS NULL OR current_projects < max_projects)`,
        [tradeCode, project.zip_code]
      );
      
      if (existingBundle.rows.length > 0) {
        bundleId = existingBundle.rows[0].id;
      } else {
        // Neues Bundle erstellen
        const bundleResult = await query(
          `INSERT INTO bundles (
            trade_code, region, status, max_projects, current_projects, created_at
          ) VALUES ($1, $2, 'forming', 5, 0, NOW())
          RETURNING id`,
          [tradeCode, project.zip_code]
        );
        bundleId = bundleResult.rows[0].id;
      }
      
      // Tender mit Bundle verknüpfen
      await query(
        `UPDATE tenders SET bundle_id = $1 WHERE id = $2`,
        [bundleId, tender.tenderId]
      );
      
      // Ähnliche Tenders auch zum Bundle hinzufügen
      for (const similar of similarProjects.rows) {
        await query(
          `UPDATE tenders SET bundle_id = $1 WHERE id = $2 AND bundle_id IS NULL`,
          [bundleId, similar.id]
        );
      }
      
      // Bundle-Projekte Tabelle befüllen (falls verwendet)
      await query(
        `INSERT INTO bundle_projects (bundle_id, project_id, joined_at)
         SELECT $1, project_id, NOW() FROM tenders WHERE bundle_id = $1
         ON CONFLICT DO NOTHING`,
        [bundleId]
      );
      
      // Current_projects im Bundle aktualisieren
      await query(
        `UPDATE bundles 
         SET current_projects = (SELECT COUNT(*) FROM tenders WHERE bundle_id = $1),
             total_volume = (SELECT SUM(estimated_value) FROM tenders WHERE bundle_id = $1)
         WHERE id = $1`,
        [bundleId]
      );
    }
  }
}

// Berechne maximale Distanz zwischen Koordinaten
function calculateMaxDistance(coords) {
  let maxDist = 0;
  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      const dist = haversineDistance(coords[i], coords[j]);
      if (dist > maxDist) maxDist = dist;
    }
  }
  return Math.round(maxDist * 10) / 10;
}

// Haversine Distanz-Berechnung
function haversineDistance(coord1, coord2) {
  const R = 6371; // Erdradius in km
  const dLat = toRad(coord2.lat - coord1.lat);
  const dLng = toRad(coord2.lng - coord1.lng);
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) * 
    Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function toRad(deg) {
  return deg * (Math.PI/180);
}

// Berechne optimale Route (vereinfacht - TSP)
function calculateOptimalRoute(projects) {
  // Vereinfachte Implementation - in Produktion würde man hier
  // einen richtigen TSP-Algorithmus verwenden
  return projects.map(p => ({
    project_id: p.project_id,
    address: p.address,
    lat: p.lat,
    lng: p.lng
  }));
}

// Berechne Zentrum für Map
function calculateCenter(projects) {
  if (projects.length === 0) return { lat: 50.9375, lng: 6.9603 }; // Köln als Default
  
  const sumLat = projects.reduce((sum, p) => sum + p.lat, 0);
  const sumLng = projects.reduce((sum, p) => sum + p.lng, 0);
  
  return {
    lat: sumLat / projects.length,
    lng: sumLng / projects.length
  };
}

// Berechne Zoom-Level basierend auf Projektverteilung
function calculateZoomLevel(projects) {
  if (projects.length <= 1) return 14;
  
  const coords = projects.map(p => ({ lat: p.lat, lng: p.lng }));
  const maxDistance = calculateMaxDistance(coords);
  
  // Zoom-Level basierend auf maximaler Distanz
  if (maxDistance < 2) return 14;
  if (maxDistance < 5) return 13;
  if (maxDistance < 10) return 12;
  if (maxDistance < 20) return 11;
  return 10;
}

// ============================================
// GEOCODING FUNCTIONS
// ============================================

// Geocoding für genaue Adresse (Nominatim - kostenlos)
async function geocodeAddress(street, houseNumber, zip, city) {
  try {
    const address = `${street} ${houseNumber}, ${zip} ${city}, Germany`;
    const encodedAddress = encodeURIComponent(address);
    
    // Warte 1 Sekunde zwischen Requests (Nominatim Rate Limit)
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    const response = await fetch(
      `https://nominatim.openstreetmap.org/search?q=${encodedAddress}&format=json&limit=1`,
      {
        headers: {
          'User-Agent': 'byndl-platform/1.0'
        }
      }
    );
    
    const data = await response.json();
    
    if (data && data.length > 0) {
      return {
        lat: parseFloat(data[0].lat),
        lng: parseFloat(data[0].lon)
      };
    }
    
    return null;
  } catch (error) {
    console.error('Geocoding error:', error);
    return null;
  }
}

// Füge zufälligen Offset von ~100m hinzu (für Anonymisierung)
function addRandomOffset(lat, lng, radiusInMeters = 100) {
  // 1 Grad Latitude ≈ 111km
  // 1 Grad Longitude ≈ 111km * cos(latitude)
  
  const latOffset = (Math.random() - 0.5) * 2 * (radiusInMeters / 111000);
  const lngOffset = (Math.random() - 0.5) * 2 * (radiusInMeters / (111000 * Math.cos(lat * Math.PI / 180)));
  
  return {
    lat: lat + latOffset,
    lng: lng + lngOffset
  };
}

// Geocode Projekt falls noch nicht geschehen
async function ensureProjectGeocoded(projectId) {
  try {
    // Prüfe ob schon geocoded
    const checkResult = await query(
      `SELECT id, geocoded_lat, geocoded_lng, street, house_number, zip_code, city
       FROM projects 
       WHERE id = $1`,
      [projectId]
    );
    
    if (checkResult.rows.length === 0) return;
    
    const project = checkResult.rows[0];
    
    // Wenn bereits geocoded, nichts tun
    if (project.geocoded_lat && project.geocoded_lng) {
      return;
    }
    
    // Wenn Adresse vorhanden, geocode
    if (project.street && project.house_number && project.zip_code && project.city) {
      const coords = await geocodeAddress(
        project.street,
        project.house_number,
        project.zip_code,
        project.city
      );
      
      if (coords) {
        await query(
          `UPDATE projects 
           SET geocoded_lat = $1, geocoded_lng = $2, geocoded_at = NOW()
           WHERE id = $3`,
          [coords.lat, coords.lng, projectId]
        );
        console.log(`✓ Project ${projectId} geocoded: ${coords.lat}, ${coords.lng}`);
      }
    }
  } catch (error) {
    console.error(`Geocoding failed for project ${projectId}:`, error);
  }
}

// ============================================
// 9. NOTIFICATION & STATUS UPDATES
// ============================================

// Ungelesene Benachrichtigungen zählen
app.get('/api/:userType/:userId/notifications/unread-count', async (req, res) => {
  try {
    const { userType, userId } = req.params;
    
    const result = await query(
      `SELECT COUNT(*) as count
       FROM notifications
       WHERE user_type = $1 AND user_id = $2 AND read_at IS NULL`,
      [userType, userId]
    );
    
    res.json({ count: parseInt(result.rows[0].count) });
  } catch (error) {
    res.status(500).json({ error: 'Fehler beim Zählen' });
  }
});

// Benachrichtigungen als gelesen markieren
app.post('/api/notifications/:notificationId/mark-read', async (req, res) => {
  try {
    await query(
      `UPDATE notifications SET read_at = NOW() WHERE id = $1`,
      [req.params.notificationId]
    );
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// Handwerker Aufträge laden
app.get('/api/handwerker/:identifier/orders', async (req, res) => {
  try {
    const { identifier } = req.params;
    let handwerkerId;
    
    // Flexible ID-Erkennung
    if (/^\d+$/.test(identifier)) {
      handwerkerId = parseInt(identifier);
    } else {
      const result = await query(
        'SELECT id FROM handwerker WHERE company_id = $1',
        [identifier]
      );
      if (result.rows.length === 0) {
        return res.status(404).json({ error: 'Handwerker nicht gefunden' });
      }
      handwerkerId = result.rows[0].id;
    }
    
    const result = await query(
  `SELECT 
    ord.*,
    ord.amount as contract_amount,
    ord.created_at as contract_date,
    ord.execution_start,
    ord.execution_end,
    p.description as projectType,
    p.street as project_street,
    p.house_number as project_house_number,
    p.zip_code as project_zip,
    p.city as project_city,
    b.name as bauherr_name,
    b.email as bauherr_email,
    b.phone as bauherr_phone,
    b.address as bauherr_address,
    b.zip_code as bauherr_zip,
    b.city as bauherr_city,
    b.name as clientName,
    b.email as clientEmail,
    b.phone as clientPhone,
    t.name as trade,
    t.name as trade_name,
    CASE 
      WHEN ord.status = 'active' THEN 'In Ausführung'
      WHEN ord.status = 'completed' THEN 'Abgeschlossen'
      ELSE ord.status
    END as status_text,
    of.lv_data
   FROM orders ord
   JOIN projects p ON ord.project_id = p.id
   JOIN bauherren b ON ord.bauherr_id = b.id
   JOIN trades t ON ord.trade_id = t.id
   LEFT JOIN offers of ON ord.offer_id = of.id
   WHERE ord.handwerker_id = $1
   ORDER BY ord.created_at DESC`,
  [handwerkerId]
);
    
    res.json(result.rows);
  } catch (error) {
    console.error('Error fetching handwerker orders:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Aufträge' });
  }
});

// NEU - Fehlte komplett
app.get('/api/bundles/:bundleId/map-data', async (req, res) => {
  try {
    const { bundleId } = req.params;
    
    const mapData = await query(
      `SELECT 
        p.id,
        p.street || ' ' || p.house_number as address,
        p.zip_code,
        p.city,
        z.latitude as lat,
        z.longitude as lng,
        tn.estimated_value as value
       FROM bundle_projects bp
       JOIN tenders tn ON bp.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       JOIN zip_codes z ON p.zip_code = z.zip
       WHERE bp.bundle_id = $1`,
      [bundleId]
    );
    
    res.json(mapData.rows);
  } catch (error) {
    res.status(500).json({ error: 'Fehler beim Laden der Kartendaten' });
  }
});

// ============================================
// 8. HELPER FUNCTIONS
// ============================================

// Berechne maximale Distanz zwischen Koordinaten
function calculateMaxDistance(coords) {
  let maxDist = 0;
  for (let i = 0; i < coords.length; i++) {
    for (let j = i + 1; j < coords.length; j++) {
      const dist = haversineDistance(coords[i], coords[j]);
      if (dist > maxDist) maxDist = dist;
    }
  }
  return Math.round(maxDist * 10) / 10;
}

// Haversine Distanz-Berechnung
function haversineDistance(coord1, coord2) {
  const R = 6371; // Erdradius in km
  const dLat = toRad(coord2.lat - coord1.lat);
  const dLng = toRad(coord2.lng - coord1.lng);
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(toRad(coord1.lat)) * Math.cos(toRad(coord2.lat)) * 
    Math.sin(dLng/2) * Math.sin(dLng/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c;
}

function toRad(deg) {
  return deg * (Math.PI/180);
}

// Berechne optimale Route (vereinfacht - TSP)
function calculateOptimalRoute(projects) {
  // Vereinfachte Implementation - in Produktion würde man hier
  // einen richtigen TSP-Algorithmus verwenden
  return projects.map(p => ({
    project_id: p.project_id,
    address: p.address,
    lat: p.lat,
    lng: p.lng
  }));
}

// ============================================
// HANDWERKER SETTINGS ENDPOINTS
// ============================================

// Settings laden
app.get('/api/handwerker/:id/settings', async (req, res) => {
  try {
    const result = await query(
      `SELECT 
        company_name as "companyName",
        email, phone, street, house_number as "houseNumber",
        zip_code as "zipCode", city, website,
        action_radius as "actionRadius",
        min_order_value as "minOrderValue",
        hourly_rates as "hourlyRates",
        payment_terms as "paymentTerms",
        vacation_dates as "vacationDates",
        notification_settings as "notificationSettings",
        bank_iban as "bankIban",
        bank_bic as "bankBic",
        invoice_address as "invoiceAddress",
        two_factor_enabled as "twoFactorEnabled",
        excluded_areas as "excludedAreas",
        travel_cost_per_km as "travelCostPerKm"
       FROM handwerker WHERE id = $1`,
      [req.params.id]
    );
    
    if (result.rows.length > 0) {
      res.json(result.rows[0]);
    } else {
      res.status(404).json({ error: 'Handwerker nicht gefunden' });
    }
  } catch (err) {
    res.status(500).json({ error: 'Fehler beim Laden der Einstellungen' });
  }
});

// Firmendaten updaten
app.put('/api/handwerker/:id/firmendaten', async (req, res) => {
  try {
    const { companyName, email, phone, street, houseNumber, zipCode, city, website } = req.body;
    
    await query(
      `UPDATE handwerker SET
        company_name = $2,
        email = $3,
        phone = $4,
        street = $5,
        house_number = $6,
        zip_code = $7,
        city = $8,
        website = $9
       WHERE id = $1`,
      [req.params.id, companyName, email, phone, street, houseNumber, zipCode, city, website]
    );
    
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// ERSETZE die bestehende Einsatzgebiet-Route mit dieser:
app.put('/api/handwerker/:id/einsatzgebiet', async (req, res) => {
  try {
    const handwerkerId = req.params.id;
    console.log('Update Einsatzgebiet für Handwerker ID:', handwerkerId);
    
    const { 
      actionRadius,
      excludedAreas,
      travelCostPerKm,
      preferredZipCodes,
      minOrderValue10km,
      minOrderValue25km,
      minOrderValue50km,
      minOrderValueOver50km,
      latitude,
      longitude
    } = req.body;
    
    // Basis-Update - WICHTIG: excluded_areas ist JSONB, nicht TEXT!
    await query(
      `UPDATE handwerker SET
        action_radius = $2,
        excluded_areas = $3::jsonb,  -- Cast zu JSONB
        travel_cost_per_km = $4
       WHERE id = $1`,
      [
        handwerkerId, 
        actionRadius || 25,
        JSON.stringify(excludedAreas || []),  // JSON.stringify für JSONB
        travelCostPerKm || 0.5
      ]
    );
    
    // Erweiterte Einstellungen
    const coverageSettings = {
      preferred_zip_codes: preferredZipCodes || [],
      min_order_values: {
        up_to_10km: minOrderValue10km || 0,
        up_to_25km: minOrderValue25km || 0,
        up_to_50km: minOrderValue50km || 0,
        over_50km: minOrderValueOver50km || 0
      },
      coordinates: { 
        latitude: latitude || null, 
        longitude: longitude || null 
      }
    };
    
    // Update coverage_settings (auch JSONB)
    await query(
      `UPDATE handwerker SET coverage_settings = $2::jsonb WHERE id = $1`,
      [handwerkerId, JSON.stringify(coverageSettings)]
    );
    
    res.json({ 
      success: true,
      message: 'Einsatzgebiet erfolgreich aktualisiert'
    });
    
  } catch (err) {
    console.error('Update Einsatzgebiet Error:', err);
    res.status(500).json({ 
      error: 'Update fehlgeschlagen',
      details: process.env.NODE_ENV === 'development' ? err.message : undefined
    });
  }
});

// Verfügbarkeit updaten
app.put('/api/handwerker/:id/verfuegbarkeit', async (req, res) => {
  try {
    const { earliestStart, capacity, vacationDates } = req.body;
    
    await query(
      `UPDATE handwerker SET
        available_from = $2,
        vacation_dates = $3
       WHERE id = $1`,
      [req.params.id, earliestStart, JSON.stringify(vacationDates)]
    );
    
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Preise updaten
app.put('/api/handwerker/:id/preise', async (req, res) => {
  try {
    const { minOrderValue, travelCostPerKm, hourlyRates } = req.body;
    
    await query(
      `UPDATE handwerker SET
        min_order_value = $2,
        travel_cost_per_km = $3,
        hourly_rates = $4
       WHERE id = $1`,
      [req.params.id, minOrderValue, travelCostPerKm, JSON.stringify(hourlyRates)]
    );
    
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Benachrichtigungen updaten - ERWEITERTE VERSION
app.put('/api/handwerker/:id/benachrichtigungen', async (req, res) => {
  try {
    const { 
      emailNotifications, 
      smsNotifications, 
      newsletterSubscribed,
      notificationEmail,
      notificationPhone 
    } = req.body;
    
    // Validierung der E-Mail
    if (notificationEmail && !isValidEmail(notificationEmail)) {
      return res.status(400).json({ error: 'Ungültige E-Mail-Adresse' });
    }
    
    // Validierung der Telefonnummer
    if (notificationPhone && !isValidPhone(notificationPhone)) {
      return res.status(400).json({ error: 'Ungültige Telefonnummer' });
    }
    
    const notificationSettings = {
      email: emailNotifications,
      sms: smsNotifications,
      newsletter: newsletterSubscribed,
      notificationEmail: notificationEmail,
      notificationPhone: notificationPhone
    };
    
    // Update der Datenbank mit zusätzlichen Feldern
    await query(
      `UPDATE handwerker SET
        notification_settings = $2,
        notification_email = $3,
        notification_phone = $4,
        updated_at = CURRENT_TIMESTAMP
       WHERE id = $1`,
      [
        req.params.id, 
        JSON.stringify(notificationSettings),
        notificationEmail || null,
        notificationPhone || null
      ]
    );
    
    res.json({ 
      success: true,
      message: 'Benachrichtigungseinstellungen erfolgreich aktualisiert'
    });
  } catch (err) {
    console.error('Fehler beim Update der Benachrichtigungen:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Hilfsfunktionen für Validierung
function isValidEmail(email) {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}

function isValidPhone(phone) {
  // Erlaubt deutsche Telefonnummern mit verschiedenen Formaten
  const phoneRegex = /^(\+49|0049|0)?[1-9]\d{1,14}$/;
  return phoneRegex.test(phone.replace(/[\s\-\/\(\)]/g, ''));
}

// Zahlungsdaten updaten
app.put('/api/handwerker/:id/zahlungsdaten', async (req, res) => {
  try {
    const { bankIban, bankBic, paymentTerms, invoiceAddress } = req.body;
    
    await query(
      `UPDATE handwerker SET
        bank_iban = $2,
        bank_bic = $3,
        payment_terms = $4,
        invoice_address = $5
       WHERE id = $1`,
      [req.params.id, bankIban, bankBic, paymentTerms, invoiceAddress]
    );
    
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

const bcryptjs = require('bcryptjs');

// Passwort ändern - PRODUKTIONSREIFE VERSION
app.put('/api/handwerker/:id/password', async (req, res) => {
  try {
    const { currentPassword, newPassword, confirmPassword } = req.body;
    
    // Validierung
    if (!currentPassword || !newPassword || !confirmPassword) {
      return res.status(400).json({ 
        error: 'Alle Passwortfelder müssen ausgefüllt sein' 
      });
    }
    
    if (newPassword !== confirmPassword) {
      return res.status(400).json({ 
        error: 'Die neuen Passwörter stimmen nicht überein' 
      });
    }
    
    if (newPassword.length < 8) {
      return res.status(400).json({ 
        error: 'Das neue Passwort muss mindestens 8 Zeichen lang sein' 
      });
    }
    
    // Hole aktuelles Passwort-Hash aus DB
    const result = await query(
      'SELECT password_hash FROM handwerker WHERE id = $1',
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ 
        error: 'Handwerker nicht gefunden' 
      });
    }
    
    // Prüfe ob das aktuelle Passwort korrekt ist
    const isPasswordValid = await bcryptjs.compare(
      currentPassword, 
      result.rows[0].password_hash
    );
    
    if (!isPasswordValid) {
      return res.status(401).json({ 
        error: 'Das aktuelle Passwort ist falsch' 
      });
    }
    
    // Hashe das neue Passwort
    const hashedPassword = await bcryptjs.hash(newPassword, 10);
    
    // Update Passwort in DB
    await query(
      `UPDATE handwerker 
       SET password_hash = $2, 
           password_changed_at = CURRENT_TIMESTAMP,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $1`,
      [req.params.id, hashedPassword]
    );
    
    res.json({ 
      success: true, 
      message: 'Passwort erfolgreich geändert' 
    });
    
  } catch (err) {
    console.error('Passwort-Update Fehler:', err);
    res.status(500).json({ 
      error: 'Passwortänderung fehlgeschlagen' 
    });
  }
});

// Zwei-Faktor-Authentifizierung aktivieren/deaktivieren
app.put('/api/handwerker/:id/two-factor', async (req, res) => {
  try {
    const { twoFactorEnabled } = req.body;
    
    // Validierung
    if (typeof twoFactorEnabled !== 'boolean') {
      return res.status(400).json({ 
        error: 'Ungültiger Wert für Zwei-Faktor-Authentifizierung' 
      });
    }
    
    // Prüfe ob Handwerker existiert
    const checkResult = await query(
      'SELECT id, phone FROM handwerker WHERE id = $1',
      [req.params.id]
    );
    
    if (checkResult.rows.length === 0) {
      return res.status(404).json({ 
        error: 'Handwerker nicht gefunden' 
      });
    }
    
    // Wenn 2FA aktiviert werden soll, prüfe ob Telefonnummer vorhanden
    if (twoFactorEnabled && !checkResult.rows[0].phone) {
      return res.status(400).json({ 
        error: 'Für 2FA muss eine Telefonnummer hinterlegt sein' 
      });
    }
    
    // Update 2FA Status
    await query(
      `UPDATE handwerker 
       SET two_factor_enabled = $2,
           updated_at = CURRENT_TIMESTAMP
       WHERE id = $1`,
      [req.params.id, twoFactorEnabled]
    );
    
    res.json({ 
      success: true,
      message: twoFactorEnabled 
        ? 'Zwei-Faktor-Authentifizierung wurde aktiviert' 
        : 'Zwei-Faktor-Authentifizierung wurde deaktiviert'
    });
    
  } catch (err) {
    console.error('2FA Update Fehler:', err);
    res.status(500).json({ 
      error: 'Änderung der Zwei-Faktor-Authentifizierung fehlgeschlagen' 
    });
  }
});

// Account löschen - MIT PASSWORT-BESTÄTIGUNG
app.delete('/api/handwerker/:id/account', async (req, res) => {
  try {
    const { password } = req.body;
    
    // Passwort ist erforderlich für Account-Löschung
    if (!password) {
      return res.status(400).json({ 
        error: 'Passwort zur Bestätigung erforderlich' 
      });
    }
    
    // Hole Passwort-Hash aus DB
    const result = await query(
      'SELECT password_hash, company_name FROM handwerker WHERE id = $1',
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ 
        error: 'Account nicht gefunden' 
      });
    }
    
    // Prüfe Passwort
    const isPasswordValid = await bcryptjs.compare(
      password, 
      result.rows[0].password_hash
    );
    
    if (!isPasswordValid) {
      return res.status(401).json({ 
        error: 'Falsches Passwort. Account-Löschung abgebrochen.' 
      });
    }
    
    // Start Transaction für sichere Löschung
    await query('BEGIN');
    
    try {
      // Lösche zuerst alle abhängigen Daten
      await query('DELETE FROM handwerker_trades WHERE handwerker_id = $1', [req.params.id]);
      await query('DELETE FROM handwerker_insurances WHERE handwerker_id = $1', [req.params.id]);
      await query('DELETE FROM handwerker_certifications WHERE handwerker_id = $1', [req.params.id]);
      await query('DELETE FROM handwerker_documents WHERE handwerker_id = $1', [req.params.id]);
      
      // Optional: Soft Delete (markiere als gelöscht statt zu löschen)
      // await query(
      //   `UPDATE handwerker 
      //    SET deleted_at = CURRENT_TIMESTAMP,
      //        active = false,
      //        email = CONCAT(email, '_deleted_', $2)
      //    WHERE id = $1`,
      //   [req.params.id, Date.now()]
      // );
      
      // Hard Delete - endgültiges Löschen
      await query('DELETE FROM handwerker WHERE id = $1', [req.params.id]);
      
      await query('COMMIT');
      
      res.json({ 
        success: true, 
        message: `Account '${result.rows[0].company_name}' wurde erfolgreich gelöscht` 
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      throw innerErr;
    }
    
  } catch (err) {
    console.error('Account-Löschung Fehler:', err);
    res.status(500).json({ 
      error: 'Account konnte nicht gelöscht werden' 
    });
  }
});

// Account-Einstellungen abrufen (für initiales Laden)
app.get('/api/handwerker/:id/account', async (req, res) => {
  try {
    const result = await query(
      `SELECT 
        two_factor_enabled,
        last_login,
        created_at,
        password_changed_at
       FROM handwerker 
       WHERE id = $1`,
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ 
        error: 'Handwerker nicht gefunden' 
      });
    }
    
    res.json({
      twoFactorEnabled: result.rows[0].two_factor_enabled || false,
      lastLogin: result.rows[0].last_login,
      createdAt: result.rows[0].created_at,
      passwordChangedAt: result.rows[0].password_changed_at
    });
    
  } catch (err) {
    console.error('Account-Daten Abruf Fehler:', err);
    res.status(500).json({ 
      error: 'Abrufen der Account-Daten fehlgeschlagen' 
    });
  }
});

// Allgemeine Settings-Route (für alle Tabs)
app.get('/api/handwerker/:id/settings', async (req, res) => {
  try {
    const result = await query(
      `SELECT 
        company_name,
        email,
        phone,
        street,
        house_number,
        zip_code,
        city,
        website,
        action_radius,
        two_factor_enabled,
        last_login,
        created_at,
        notification_settings
       FROM handwerker 
       WHERE id = $1`,
      [req.params.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ 
        error: 'Handwerker nicht gefunden' 
      });
    }
    
    const data = result.rows[0];
    const notificationSettings = data.notification_settings 
      ? JSON.parse(data.notification_settings) 
      : {};
    
    res.json({
      // Firmendaten
      companyName: data.company_name,
      email: data.email,
      phone: data.phone,
      street: data.street,
      houseNumber: data.house_number,
      zipCode: data.zip_code,
      city: data.city,
      website: data.website,
      
      // Einsatzgebiet
      actionRadius: data.action_radius,
      
      // Account
      twoFactorEnabled: data.two_factor_enabled || false,
      lastLogin: data.last_login,
      createdAt: data.created_at,
      
      // Benachrichtigungen
      emailNotifications: notificationSettings.email || true,
      smsNotifications: notificationSettings.sms || false,
      newsletterSubscribed: notificationSettings.newsletter || false,
      notificationEmail: notificationSettings.notificationEmail || data.email,
      notificationPhone: notificationSettings.notificationPhone || data.phone
    });
    
  } catch (err) {
    console.error('Settings Abruf Fehler:', err);
    res.status(500).json({ 
      error: 'Abrufen der Einstellungen fehlgeschlagen' 
    });
  }
});

// Logo upload
app.post('/api/handwerker/:id/logo', upload.single('logo'), async (req, res) => {
  try {
    const fileBuffer = req.file.buffer;
    
    await query(
      `UPDATE handwerker SET logo_url = $2 WHERE id = $1`,
      [req.params.id, `data:${req.file.mimetype};base64,${fileBuffer.toString('base64')}`]
    );
    
    res.json({ success: true });
  } catch (err) {
    res.status(500).json({ error: 'Logo-Upload fehlgeschlagen' });
  }
});

// Dokument hochladen
app.post('/api/handwerker/documents/upload', upload.single('document'), async (req, res) => {
  try {
    const handwerkerId = req.params.id;
    if (!handwerkerId) {
      return res.status(401).json({ error: 'Nicht authentifiziert' });
    }
    
    const { document_type } = req.body;
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'Keine Datei hochgeladen' });
    }
    
    // Speichere in DB
    const result = await query(
      `INSERT INTO handwerker_documents 
       (handwerker_id, document_type, file_name, file_data, uploaded_at)
       VALUES ($1, $2, $3, $4, NOW())
       RETURNING id, document_type, file_name, uploaded_at`,
      [handwerkerId, document_type, file.originalname, file.buffer]
    );
    
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Upload error:', err);
    res.status(500).json({ error: 'Upload fehlgeschlagen' });
  }
});

// Dokumente abrufen - KORRIGIERT
app.get('/api/handwerker/:id/documents', async (req, res) => {
  try {
    const handwerkerId = req.params.id; // :id aus der URL
    
    const result = await query(
      `SELECT id, document_type, file_name, uploaded_at
       FROM handwerker_documents
       WHERE handwerker_id = $1
       ORDER BY uploaded_at DESC`,
      [handwerkerId]
    );
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching documents:', err);
    res.status(500).json({ error: 'Fehler beim Laden' });
  }
});

// Dokument hochladen - KORRIGIERT
app.post('/api/handwerker/:id/documents/upload', upload.single('document'), async (req, res) => {
  try {
    const handwerkerId = req.params.id; // :id aus der URL
    const { document_type } = req.body;
    const file = req.file;
    
    if (!file) {
      return res.status(400).json({ error: 'Keine Datei hochgeladen' });
    }
    
    const result = await query(
      `INSERT INTO handwerker_documents 
       (handwerker_id, document_type, file_name, file_data, uploaded_at)
       VALUES ($1, $2, $3, $4, NOW())
       RETURNING id, document_type, file_name, uploaded_at`,
      [handwerkerId, document_type, file.originalname, file.buffer]
    );
    
    res.json(result.rows[0]);
  } catch (err) {
    console.error('Upload error:', err);
    res.status(500).json({ error: 'Upload fehlgeschlagen' });
  }
});

// Dokument herunterladen - KORRIGIERT
app.get('/api/handwerker/:handwerkerId/documents/:docId', async (req, res) => {
  try {
    const { handwerkerId, docId } = req.params;
    
    const result = await query(
      `SELECT file_name, file_data
       FROM handwerker_documents
       WHERE id = $1 AND handwerker_id = $2`,
      [docId, handwerkerId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Dokument nicht gefunden' });
    }
    
    const doc = result.rows[0];
    res.setHeader('Content-Type', 'application/octet-stream');
    res.setHeader('Content-Disposition', `attachment; filename="${doc.file_name}"`);
    res.send(doc.file_data);
  } catch (err) {
    console.error('Download error:', err);
    res.status(500).json({ error: 'Download fehlgeschlagen' });
  }
});

// Dokument löschen - KORRIGIERT
app.delete('/api/handwerker/:handwerkerId/documents/:docId', async (req, res) => {
  try {
    const { handwerkerId, docId } = req.params;
    
    await query(
      'DELETE FROM handwerker_documents WHERE id = $1 AND handwerker_id = $2',
      [docId, handwerkerId]
    );
    
    res.json({ success: true });
  } catch (err) {
    console.error('Delete error:', err);
    res.status(500).json({ error: 'Löschen fehlgeschlagen' });
  }
});

// ============= ERWEITERTE TENDER & TRACKING ROUTES =============

// Ausschreibungs-Status tracken
app.post('/api/tenders/:tenderId/track-view', async (req, res) => {
  try {
    const { tenderId } = req.params;
    const { handwerkerId } = req.body;
    
    await query(
      `UPDATE tender_handwerker 
       SET viewed_at = COALESCE(viewed_at, NOW()), status = 'viewed'
       WHERE tender_id = $1 AND handwerker_id = $2`,
      [tenderId, handwerkerId]
    );
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error tracking view:', error);
    res.status(500).json({ error: 'Fehler beim Tracking' });
  }
});

// Ausschreibungs-Status auf "in Bearbeitung" setzen
app.post('/api/tenders/:tenderId/start-offer', async (req, res) => {
  try {
    const { tenderId } = req.params;
    const { handwerkerId } = req.body;
    
    await query(
      `UPDATE tender_handwerker_status 
       SET status = 'in_progress', in_progress_at = NOW()
       WHERE tender_id = $1 AND handwerker_id = $2`,
      [tenderId, handwerkerId]
    );
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error updating status:', error);
    res.status(500).json({ error: 'Fehler beim Status-Update' });
  }
});

// Erweiterte Route für Handwerker-Tenders mit Status
app.get('/api/handwerker/:handwerkerId/tenders/detailed', async (req, res) => {
  try {
    const { handwerkerId } = req.params;
    
    const result = await query(
      `SELECT DISTINCT ON (t.id)
        t.*,
        tr.name as trade_name,
        tr.code as trade_code,
        p.id as project_id,
        p.category as project_category,
        p.sub_category as project_sub_category,
        p.description as project_description,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        p.street || ' ' || p.house_number || ', ' || p.zip_code || ' ' || p.city as project_address,
        b.name as bauherr_name,
        b.email as bauherr_email,
        b.phone as bauherr_phone,
        b.address as bauherr_address,
        ths.status as tender_status,
        ths.viewed_at,
        th.status as th_status,
        o.id as offer_id,
        o.amount as offer_amount,
        o.status as offer_status,
        o.stage as offer_stage,
        o.preliminary_accepted_at,
        o.offer_confirmed_at,
        o.notes as offer_notes,
        o.execution_start,
        o.execution_end
       FROM tenders t
       JOIN trades tr ON t.trade_id = tr.id
       JOIN projects p ON t.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN tender_handwerker th ON t.id = th.tender_id AND th.handwerker_id = $1
       LEFT JOIN tender_handwerker_status ths ON t.id = ths.tender_id AND ths.handwerker_id = $1
       LEFT JOIN offers o ON t.id = o.tender_id AND o.handwerker_id = $1
       WHERE t.trade_id IN (SELECT trade_id FROM handwerker_trades WHERE handwerker_id = $1)
       AND t.status = 'open'
       AND th.status != 'rejected'
       AND (o.id IS NULL OR o.status IN ('preliminary', 'confirmed'))
       ORDER BY t.id, t.created_at DESC`,
      [handwerkerId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching detailed tenders:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Ausschreibungen' });
  }
});

// Aufträge für Handwerker laden
app.get('/api/handwerker/:handwerkerId/orders', async (req, res) => {
  try {
    const { handwerkerId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        t.name as trade_name,
        t.code as trade_code,
        p.street as project_street,
        p.house_number as project_house_number,
        p.zip_code as project_zip,
        p.city as project_city,
        b.name as bauherr_name,
        b.email as bauherr_email,
        b.phone as bauherr_phone,
        b.address as bauherr_address
       FROM orders o
       JOIN trades t ON o.trade_id = t.id
       JOIN projects p ON o.project_id = p.id
       JOIN bauherren b ON o.bauherr_id = b.id
       WHERE o.handwerker_id = $1
       ORDER BY o.created_at DESC`,
      [handwerkerId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching orders:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Aufträge' });
  }
});

// Angebote als gelesen markieren
app.post('/api/projects/:projectId/offers/mark-all-read', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    await query(
      `UPDATE offers o
       SET viewed_at = NOW()
       FROM tenders t
       WHERE o.tender_id = t.id 
       AND t.project_id = $1 
       AND o.viewed_at IS NULL`,
      [projectId]
    );
    
    res.json({ success: true });
  } catch (error) {
    res.status(500).json({ error: 'Fehler beim Markieren' });
  }
});

// Fehlende Route: LV-Daten für Projekt
app.get('/api/projects/:projectId/lv', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT l.*, t.name as trade_name, t.code as trade_code
       FROM lvs l
       JOIN trades t ON l.trade_id = t.id
       WHERE l.project_id = $1
       ORDER BY t.name`,
      [projectId]
    );
    
    res.json({ 
      lvs: result.rows.map(lv => ({
        ...lv,
        content: typeof lv.content === 'string' ? JSON.parse(lv.content) : lv.content
      }))
    });
    
  } catch (error) {
    console.error('Error fetching LVs:', error);
    res.status(500).json({ error: 'Fehler beim Laden der LVs' });
  }
});

// Fehlende Route: Projekt mit Bauherr verknüpfen
app.post('/api/projects/claim', async (req, res) => {
  try {
    const { projectId, bauherrId } = req.body;
    
    await query(
      `UPDATE projects 
       SET bauherr_id = $2, updated_at = NOW()
       WHERE id = $1`,
      [projectId, bauherrId]
    );
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error claiming project:', error);
    res.status(500).json({ error: 'Fehler bei der Projektzuweisung' });
  }
});

// LV-Status für Dashboard
app.get('/api/projects/:projectId/lv-status', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT 
        COUNT(DISTINCT pt.trade_id) as total_trades,
        COUNT(DISTINCT CASE 
          WHEN l.content IS NOT NULL AND l.content::text != '{}' 
          THEN l.trade_id 
        END) as completed_lvs,
        COUNT(DISTINCT CASE 
          WHEN pt.trade_id = (SELECT id FROM trades WHERE code = 'INT')
          THEN pt.trade_id 
        END) as internal_trades
       FROM project_trades pt
       LEFT JOIN lvs l ON pt.project_id = l.project_id AND pt.trade_id = l.trade_id
       WHERE pt.project_id = $1`,
      [projectId]
    );
    
    const status = result.rows[0];
    // INT-Trade von der Gesamtzahl abziehen
    status.total_trades = status.total_trades - status.internal_trades;
    
    res.json(status);
    
  } catch (error) {
    console.error('Error fetching LV status:', error);
    res.status(500).json({ error: 'Fehler beim Laden des LV-Status' });
  }
});

// Helper-Funktion (fehlte)
async function getHandwerkerIdFromCompanyId(companyId) {
  const result = await query(
    'SELECT id FROM handwerker WHERE company_id = $1',
    [companyId]
  );
  return result.rows.length > 0 ? result.rows[0].id : null;
}

app.post('/api/projects/:projectId/mark-lvs-complete', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    await query(
      `UPDATE projects SET lvs_completed = true, lvs_completed_at = NOW() WHERE id = $1`,
      [projectId]
    );
    
    res.json({ success: true });
  } catch (err) {
    console.error(err);
    res.status(500).json({ error: 'Fehler' });
  }
});

// ============= TERMINVEREINBARUNGS-ROUTES =============

// Angebotsdaten mit Kontaktinfos für Ortstermin
app.get('/api/offers/:offerId/details-with-contacts', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    const result = await query(
      `SELECT 
        o.*,
        h.company_name,
        h.email as handwerker_email,
        h.phone as handwerker_phone,
        h.contact_person,
        b.name as bauherr_name,
        b.email as bauherr_email,
        b.phone as bauherr_phone,
        p.street as project_street,
        p.house_number as project_house_number,
        p.zip_code as project_zip,
        p.city as project_city,
        p.description as project_description,
        t.name as trade_name
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Angebot nicht gefunden' });
    }
    
    res.json(result.rows[0]);
    
  } catch (error) {
    console.error('Error fetching offer details:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Details' });
  }
});

// Terminvorschläge abrufen
app.get('/api/offers/:offerId/appointments', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    const result = await query(
      `SELECT * FROM appointment_proposals 
       WHERE offer_id = $1 
       ORDER BY created_at DESC`,
      [offerId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching appointments:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Termine' });
  }
});

// Neuen Terminvorschlag erstellen
app.post('/api/offers/:offerId/appointments/propose', async (req, res) => {
  try {
    const { offerId } = req.params;
    const { proposed_by, proposed_date, duration, message } = req.body;
    
    const result = await query(
      `INSERT INTO appointment_proposals 
       (offer_id, proposed_by, proposed_date, proposed_duration, message, status)
       VALUES ($1, $2, $3, $4, $5, 'proposed')
       RETURNING id`,
      [offerId, proposed_by, proposed_date, duration, message]
    );
    
    // Benachrichtigung erstellen
const offerData = await query(
  `SELECT o.*, tn.project_id, h.id as handwerker_id, h.email as handwerker_email, 
   h.company_name, p.bauherr_id, b.email as bauherr_email, b.name as bauherr_name,
   p.street, p.house_number, p.zip_code, p.city, t.name as trade_name
   FROM offers o
   JOIN tenders tn ON o.tender_id = tn.id
   JOIN handwerker h ON o.handwerker_id = h.id
   JOIN projects p ON tn.project_id = p.id
   JOIN bauherren b ON p.bauherr_id = b.id
   JOIN trades t ON tn.trade_id = t.id
   WHERE o.id = $1`,
  [offerId]
);

if (offerData.rows.length > 0) {
  const offer = offerData.rows[0];
  const recipient_type = proposed_by === 'bauherr' ? 'handwerker' : 'bauherr';
  const recipient_id = proposed_by === 'bauherr' ? offer.handwerker_id : offer.bauherr_id;
  const recipient_email = proposed_by === 'bauherr' ? offer.handwerker_email : offer.bauherr_email;
  const recipient_name = proposed_by === 'bauherr' ? offer.company_name : offer.bauherr_name;
  const sender_name = proposed_by === 'bauherr' ? offer.bauherr_name : offer.company_name;
  
// Notification in DB
await query(
  `INSERT INTO notifications 
   (user_type, user_id, type, reference_id, message, metadata, created_at)
   VALUES ($1, $2, 'appointment_request', $3, $4, $5, NOW())`,
  [
    recipient_type, 
    recipient_id, 
    offerId,  // WICHTIG: offerId statt result.rows[0].id
    `Neuer Terminvorschlag für Ortstermin`,
    JSON.stringify({
      senderName: sender_name,
      offerId: offerId,  // Fügen Sie die offerId hinzu
      appointmentId: result.rows[0].id,  // Die proposal ID
      companyName: proposed_by === 'handwerker' ? offer.company_name : undefined,
      bauherrName: proposed_by === 'bauherr' ? offer.bauherr_name : undefined,
      tradeName: offer.trade_name,
      offerTitle: offer.trade_name,  // Fügen Sie das für die Anzeige hinzu
      projectName: offer.project_description || `${offer.street} ${offer.house_number}`,
      appointmentDate: proposed_date,  // Verwenden Sie appointmentDate statt proposed_date
      appointmentTime: new Date(proposed_date).toLocaleTimeString('de-DE', {hour: '2-digit', minute: '2-digit'})
    })
  ]
);
  
  // EMAIL-VERSAND
  if (transporter && recipient_email) {
    try {
      await transporter.sendMail({
        from: process.env.SMTP_FROM || '"byndl" <info@byndl.de>',
        to: recipient_email,
        subject: `Terminvorschlag für Ortstermin - ${offer.trade_name}`,
        html: `
          <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
            <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 10px 10px 0 0;">
              <h1>Neuer Terminvorschlag</h1>
            </div>
            
            <div style="padding: 30px; background: #f7f7f7;">
              <p>Hallo ${recipient_name},</p>
              
              <p><strong>${sender_name}</strong> hat einen Terminvorschlag für einen Ortstermin gemacht:</p>
              
              <div style="background: white; padding: 20px; border-radius: 8px; margin: 20px 0;">
                <h3 style="color: #667eea;">Termindetails:</h3>
                <table style="width: 100%;">
                  <tr>
                    <td style="padding: 8px 0;"><strong>Datum/Zeit:</strong></td>
                    <td>${new Date(proposed_date).toLocaleString('de-DE', {
                      weekday: 'long',
                      year: 'numeric',
                      month: 'long',
                      day: 'numeric',
                      hour: '2-digit',
                      minute: '2-digit'
                    })}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0;"><strong>Dauer:</strong></td>
                    <td>${duration} Minuten</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0;"><strong>Projekt:</strong></td>
                    <td>${offer.trade_name}</td>
                  </tr>
                  <tr>
                    <td style="padding: 8px 0;"><strong>Adresse:</strong></td>
                    <td>${offer.street} ${offer.house_number}, ${offer.zip_code} ${offer.city}</td>
                  </tr>
                  ${message ? `
                  <tr>
                    <td style="padding: 8px 0; vertical-align: top;"><strong>Nachricht:</strong></td>
                    <td>${message}</td>
                  </tr>
                  ` : ''}
                </table>
              </div>
              
              <p><strong>Was möchten Sie tun?</strong></p>
              <p>Bitte melden Sie sich in Ihrem Dashboard an, um den Termin zu bestätigen oder einen alternativen Termin vorzuschlagen.</p>
              
              <div style="text-align: center; margin-top: 30px;">
                <a href="https://byndl.de/${recipient_type}/dashboard" 
                   style="display: inline-block; padding: 12px 30px; background: #667eea; color: white; text-decoration: none; border-radius: 5px;">
                  Zum Dashboard →
                </a>
              </div>
              
              <div style="margin-top: 30px; padding: 15px; background: #fff3cd; border-left: 4px solid #ffc107; border-radius: 4px;">
                <strong>Hinweis:</strong> Sie befinden sich in der Vertragsanbahnung. 
                Die Kontaktdaten wurden bereits freigegeben und die 24-monatige Nachwirkfrist ist aktiv.
              </div>
            </div>
            
            <div style="text-align: center; padding: 20px; color: #666; font-size: 12px; background: #e9ecef;">
              <p>© 2025 byndl - Die digitale Handwerkerplattform</p>
            </div>
          </div>
        `
      });
      
      // Email-Log
      await query(
        `INSERT INTO email_logs (recipient, type, reference_id, status, sent_at)
         VALUES ($1, 'appointment_proposal', $2, 'sent', NOW())`,
        [recipient_email, result.rows[0].id]
      );
    } catch (emailError) {
      console.error('Email-Versand fehlgeschlagen:', emailError);
    }
  }
}
    
    res.json({ success: true, id: result.rows[0].id });
    
  } catch (error) {
    console.error('Error proposing appointment:', error);
    res.status(500).json({ error: 'Fehler beim Erstellen des Terminvorschlags' });
  }
});

// Auf Terminvorschlag antworten
app.post('/api/appointments/:appointmentId/respond', async (req, res) => {
  try {
    const { appointmentId } = req.params;
    const { response } = req.body;
    
    await query('BEGIN');
    
    // Hole Appointment-Details für Notification
    const appointmentData = await query(
      `SELECT ap.*, o.id as offer_id, 
       h.id as handwerker_id, h.company_name,
       b.id as bauherr_id, b.name as bauherr_name,
       t.name as trade_name
       FROM appointment_proposals ap
       JOIN offers o ON ap.offer_id = o.id
       JOIN handwerker h ON o.handwerker_id = h.id
       JOIN tenders tn ON o.tender_id = tn.id
       JOIN projects p ON tn.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON tn.trade_id = t.id
       WHERE ap.id = $1`,
      [appointmentId]
    );
    
    if (appointmentData.rows.length > 0) {
      const appointment = appointmentData.rows[0];
      
      // Update appointment status
      await query(
        `UPDATE appointment_proposals 
         SET status = $2, responded_at = NOW()
         WHERE id = $1`,
        [appointmentId, response]
      );
      
      // Notification an den ursprünglichen Vorschlagenden
      const recipient_type = appointment.proposed_by === 'bauherr' ? 'bauherr' : 'handwerker';
      const recipient_id = appointment.proposed_by === 'bauherr' ? appointment.bauherr_id : appointment.handwerker_id;
      const responder_name = appointment.proposed_by === 'bauherr' ? appointment.company_name : appointment.bauherr_name;
      
      await query(
        `INSERT INTO notifications 
         (user_type, user_id, type, reference_id, message, metadata, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
        [
          recipient_type,
          recipient_id,
          response === 'accepted' ? 'appointment_confirmed' : 'appointment_rejected',
          appointment.offer_id,  // WICHTIG: offer_id als reference_id!
          response === 'accepted' 
            ? `Termin wurde von ${responder_name} bestätigt`
            : `Termin wurde von ${responder_name} abgelehnt`,
          JSON.stringify({
            senderName: responder_name,
            offerId: appointment.offer_id,  // WICHTIG!
            appointmentId: appointmentId,
            tradeName: appointment.trade_name,
            appointmentDate: appointment.proposed_date,
            status: response
          })
        ]
      );
      
      // Falls accepted: Update offer
      if (response === 'accepted') {
        await query(
          `UPDATE offers 
           SET appointment_confirmed = true,
               appointment_skipped = false,
               appointment_date = $2,
               updated_at = NOW()
           WHERE id = $1`,
          [appointment.offer_id, appointment.proposed_date]
        );
      }
    }
    
    await query('COMMIT');
    res.json({ success: true });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error responding to appointment:', error);
    res.status(500).json({ error: 'Fehler beim Antworten' });
  }
});

// Appointment-Status prüfen
app.get('/api/offers/:offerId/appointment-status', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    const offerResult = await query(
      `SELECT appointment_confirmed, appointment_skipped FROM offers WHERE id = $1`,
      [offerId]
    );
    
    const appointmentsResult = await query(
      `SELECT COUNT(*) as count FROM appointments 
       WHERE offer_id = $1 AND status = 'proposed'`,
      [offerId]
    );
    
    res.json({
      appointment_confirmed: offerResult.rows[0]?.appointment_confirmed || false,
      appointment_skipped: offerResult.rows[0]?.appointment_skipped || false,
      has_proposed: parseInt(appointmentsResult.rows[0]?.count) > 0
    });
  } catch (error) {
    console.error('Error checking appointment status:', error);
    res.status(500).json({ error: error.message });
  }
});

// Ortstermin überspringen
app.post('/api/offers/:offerId/skip-appointment', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    await query(
      `UPDATE offers 
       SET appointment_skipped = true,
           appointment_confirmed = false,
           updated_at = NOW()
       WHERE id = $1`,
      [offerId]
    );
    
    res.json({ success: true });
  } catch (error) {
    console.error('Error skipping appointment:', error);
    res.status(500).json({ error: error.message });
  }
});

// ============= ERWEITERTE LV-ROUTES FÜR TENDER =============

// LV-Daten für Tender (für HandwerkerOfferPage)
app.get('/api/tenders/:tenderId/lv', async (req, res) => {
  try {
    const { tenderId } = req.params;
    
    const result = await query(
      `SELECT 
        t.lv_data,
        t.project_id,
        t.trade_id,
        tr.name as trade_name,
        p.description as project_description
      FROM tenders t
      JOIN trades tr ON t.trade_id = tr.id
      JOIN projects p ON t.project_id = p.id
      WHERE t.id = $1`,
      [tenderId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Ausschreibung nicht gefunden' });
    }
    
    const tender = result.rows[0];
    const lv = typeof tender.lv_data === 'string' 
      ? JSON.parse(tender.lv_data) 
      : tender.lv_data;
    
    // Preise entfernen für Handwerker-Ansicht
    const lvWithoutPrices = {
      ...lv,
      positions: lv.positions?.map(pos => ({
        ...pos,
        unitPrice: 0,
        totalPrice: 0
      })) || []
    };
    
    res.json({
      tenderId,
      projectId: tender.project_id,
      tradeId: tender.trade_id,
      tradeName: tender.trade_name,
      projectDescription: tender.project_description,
      lv: lvWithoutPrices
    });
    
  } catch (error) {
    console.error('Error fetching tender LV:', error);
    res.status(500).json({ error: 'Fehler beim Abrufen des LV' });
  }
});

// Handwerker kann Ausschreibung ablehnen/ausblenden
app.post('/api/tenders/:tenderId/reject', async (req, res) => {
  try {
    const { tenderId } = req.params;
    const { handwerkerId } = req.body;
    
    await query(
      `UPDATE tender_handwerker 
       SET status = 'rejected', 
           rejected_at = NOW()
       WHERE tender_id = $1 AND handwerker_id = $2`,
      [tenderId, handwerkerId]
    );
    
    res.json({ success: true });
    
  } catch (error) {
    console.error('Error rejecting tender:', error);
    res.status(500).json({ error: 'Fehler beim Ablehnen' });
  }
});

// ============= ANGEBOTS-STATUS-VERWALTUNG =============

// Erweiterte Angebots-Submission mit Phasen-Management
app.post('/api/tenders/:tenderId/submit-offer', async (req, res) => {
  try {
    const { tenderId } = req.params;
    const { 
      handwerkerId, 
      positions, 
      notes, 
      totalSum, 
      stage = 'preliminary',      
      isPreliminary,              
      bundleDiscount = isBundleOffer ? (bundleDiscount || 0) : 0,
      isBundleOffer = false
    } = req.body;
    
    // ✅ FIX: Unterstütze BEIDE Formate (isPreliminary Boolean + stage String)
    let stageValue;
    let stageString;
    
    if (isPreliminary !== undefined) {
      // Frontend sendet isPreliminary (Boolean)
      stageValue = isPreliminary ? 0 : 1;
      stageString = isPreliminary ? 'preliminary' : 'final';
    } else {
      // Backend/API sendet stage (String)
      const stageMap = { 'preliminary': 0, 'final': 1 };
      stageValue = stageMap[stage] ?? 0;
      stageString = stage;
    }
    
    await query('BEGIN');
    
    // Update tender-handwerker status
    await query(
      `UPDATE tender_handwerker_status 
       SET status = 'submitted', submitted_at = NOW()
       WHERE tender_id = $1 AND handwerker_id = $2`,
      [tenderId, handwerkerId]
    );
    
    // Prüfen ob bereits ein Angebot existiert
    const existingOffer = await query(
      'SELECT id, stage FROM offers WHERE tender_id = $1 AND handwerker_id = $2',
      [tenderId, handwerkerId]
    );
    
    let offerId;
    
    if (existingOffer.rows.length > 0) {
      offerId = existingOffer.rows[0].id;
      const oldStage = existingOffer.rows[0].stage;
      
     await query(
  `UPDATE offers 
   SET lv_data = $1, 
       notes = $2, 
       amount = $3, 
       stage = $4, 
       bundle_discount = $5,
       is_bundle_offer = $6,  // NEU
       status = CASE 
         WHEN $7 = 0 AND $4 != 0 THEN 'confirmed'
         ELSE status 
       END,
       updated_at = NOW()
   WHERE id = $8`,
  [
    JSON.stringify({ positions }), 
    notes, 
    totalSum, 
    stageValue, 
    bundleDiscount,
    isBundleOffer,  
    oldStage,       
    offerId         
  ]
);
    } else {
      const result = await query(
  `INSERT INTO offers (
    tender_id, handwerker_id, amount, 
    lv_data, notes, status, stage, bundle_discount, is_bundle_offer, created_at
  ) VALUES ($1, $2, $3, $4, $5, 'submitted', $6, $7, $8, NOW())
  RETURNING id`,
  [
    tenderId, 
    handwerkerId, 
    totalSum, 
    JSON.stringify({ positions }), 
    notes, 
    stageValue, 
    bundleDiscount,
    isBundleOffer  // NEU: Flag setzen
  ]
);
      offerId = result.rows[0].id;
    }
    
    // Benachrichtigung für Bauherr
    const tenderInfo = await query(
      `SELECT project_id FROM tenders WHERE id = $1`,
      [tenderId]
    );
    
    if (tenderInfo.rows.length > 0) {
      const projectInfo = await query(
        `SELECT bauherr_id FROM projects WHERE id = $1`,
        [tenderInfo.rows[0].project_id]
      );
      
      if (projectInfo.rows.length > 0) {
        // Hole die fehlenden Informationen
        const offerDetails = await query(
          `SELECT h.company_name, t.name as trade_name, p.description as project_description
           FROM handwerker h
           CROSS JOIN tenders tn
           JOIN trades t ON tn.trade_id = t.id
           JOIN projects p ON tn.project_id = p.id
           WHERE h.id = $1 AND tn.id = $2`,
          [handwerkerId, tenderId]
        );
        
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, reference_id, message, metadata)
           VALUES ('bauherr', $1, 'new_offer', $2, $3, $4)`,
          [
            projectInfo.rows[0].bauherr_id, 
            offerId,
            'Neues Angebot eingegangen',
            JSON.stringify({
              company_name: offerDetails.rows[0]?.company_name || 'Handwerker',
              trade_name: offerDetails.rows[0]?.trade_name || 'Gewerk',
              project_name: offerDetails.rows[0]?.project_description || 'Projekt',
              amount: totalSum
            })
          ]
        );
      } 
    }
    
    await query('COMMIT');
    
    res.json({ 
      success: true, 
      offerId,
      message: stageString === 'preliminary' ? 
        'Vorläufiges Angebot abgegeben. Der Bauherr kann nun Kontakt aufnehmen.' :
        'Verbindliches Angebot abgegeben.'
    });
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error submitting offer:', error);
    res.status(500).json({ error: 'Fehler beim Abgeben des Angebots' });
  }
});

// GET /api/project/:projectId/tender/:tenderId/lv-preview
app.get('/api/project/:projectId/tender/:tenderId/lv-preview', async (req, res) => {
  const { projectId, tenderId } = req.params;
  
  try {
    // 1. Hole Tender-Info mit Trade-Name
    const tenderData = await query(
      `SELECT t.*, tr.name as trade_name 
       FROM tenders t 
       LEFT JOIN trades tr ON t.trade_id = tr.id 
       WHERE t.id = $1 AND t.project_id = $2`,
      [tenderId, projectId]
    );
    
    if (!tenderData.rows || tenderData.rows.length === 0) {
      return res.status(404).json({ error: 'Ausschreibung nicht gefunden' });
    }
    
    const tender = tenderData.rows[0];
    
    // 2. Hole LV-Daten für das Gewerk
    const lvData = await query(
      'SELECT * FROM lvs WHERE project_id = $1 AND trade_id = $2',
      [projectId, tender.trade_id]
    );
    
    if (!lvData.rows || lvData.rows.length === 0) {
      return res.status(404).json({ error: 'LV nicht gefunden' });
    }
    
    const lv = lvData.rows[0];
    
    // 3. Hole Projektdaten
    const projectData = await query(
      'SELECT street, zip, city FROM projects WHERE id = $1',
      [projectId]
    );
    const project = projectData.rows[0] || {};
    
    // 4. Parse LV-Content und entferne Preise
    const lvContent = typeof lv.content === 'string' 
      ? JSON.parse(lv.content) 
      : lv.content;
    
    // Entferne alle Preisinformationen aus den Positionen ABER behalte pos, title, description, shortText
    const lvWithoutPrices = {
      ...lvContent,
      positions: lvContent.positions?.map(pos => ({
        pos: pos.pos,              // Positionsnummer WICHTIG!
        title: pos.title,          // Titel/Überschrift
        description: pos.description,
        shortText: pos.shortText,
        unit: pos.unit,
        quantity: pos.quantity
        // unitPrice, totalPrice, isNEP werden weggelassen
      })),
      totalSum: undefined,
      subtotal: undefined,
      vat: undefined
    };
    
    res.json({
      tender: {
        id: tender.id,
        trade_name: tender.trade_name,
        created_at: tender.created_at,
        estimated_value: tender.estimated_value
      },
      lv: lvWithoutPrices,
      project: {
        street: project.street || '',
        zip: project.zip || '',
        city: project.city || ''
      }
    });
    
  } catch (error) {
    console.error('Error fetching LV preview:', error);
    res.status(500).json({ 
      error: 'Fehler beim Laden der LV-Vorschau',
      details: error.message 
    });
  }
});

// POST /api/tenders/:tenderId/cancel
app.post('/api/tenders/:tenderId/cancel', async (req, res) => {
  const { tenderId } = req.params;
  const { projectId, reason } = req.body;
  
  try {
    await query('BEGIN');
    
    // 1. Prüfe ob Ausschreibung existiert und hole Gewerk-Namen
    const tenderData = await query(
      `SELECT t.*, tr.name as trade_name 
       FROM tenders t
       LEFT JOIN trades tr ON t.trade_id = tr.id
       WHERE t.id = $1 AND t.project_id = $2`,
      [tenderId, projectId]
    );
    
    if (!tenderData.rows || tenderData.rows.length === 0) {
      await query('ROLLBACK');
      return res.status(404).json({ error: 'Ausschreibung nicht gefunden' });
    }
    
    const tender = tenderData.rows[0];
    
    if (tender.status === 'cancelled') {
      await query('ROLLBACK');
      return res.status(400).json({ error: 'Ausschreibung wurde bereits zurückgezogen' });
    }
    
    if (tender.status === 'awarded') {
      await query('ROLLBACK');
      return res.status(400).json({ error: 'Ausschreibung wurde bereits vergeben' });
    }
    
    // 2. Finde alle Handwerker mit Angeboten für diese Ausschreibung
    const offersData = await query(
      `SELECT o.id, o.handwerker_id, h.email, h.company_name 
       FROM offers o
       JOIN handwerker h ON o.handwerker_id = h.id
       WHERE o.tender_id = $1`,
      [tenderId]
    );
    
    // 3. Erstelle Notifications für alle betroffenen Handwerker
    for (const offer of offersData.rows) {
      await query(
        `INSERT INTO notifications (
          user_id, user_type, type, reference_id, message, metadata, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
        [
          offer.handwerker_id,
          'handwerker',
          'tender_cancelled',
          tenderId,
          `Der Bauherr hat die Ausschreibung für "${tender.trade_name || 'das Gewerk'}" zurückgezogen. Ihr Angebot ist nicht mehr gültig.`,
          JSON.stringify({
            tenderId: tenderId,
            offerId: offer.id,
            tradeName: tender.trade_name,
            projectId: projectId
          })
        ]
      );
    }
    
    // 4. Setze Status der Angebote auf 'cancelled' (damit Handwerker sie noch sehen können)
    await query(
      `UPDATE offers 
       SET status = 'cancelled', 
           updated_at = NOW()
       WHERE tender_id = $1`,
      [tenderId]
    );
    
    // 5. Lösche Tender-Handwerker Zuordnungen
    await query(
      'DELETE FROM tender_handwerker WHERE tender_id = $1',
      [tenderId]
    );
    
    // 6. Lösche Tender-Tracking Einträge
    await query(
      'DELETE FROM tender_tracking WHERE tender_id = $1',
      [tenderId]
    );
    
    // 7. Lösche Tender-Handwerker Status Einträge
    await query(
      'DELETE FROM tender_handwerker_status WHERE tender_id = $1',
      [tenderId]
    );
    
    // 8. Lösche die Ausschreibung selbst
    await query(
      'DELETE FROM tenders WHERE id = $1',
      [tenderId]
    );
    
    await query('COMMIT');
    
    res.json({
      success: true,
      message: 'Ausschreibung wurde erfolgreich zurückgezogen und gelöscht',
      tenderId: tenderId,
      affectedHandwerkers: offersData.rows.length
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error cancelling tender:', error);
    res.status(500).json({ 
      error: 'Fehler beim Zurückziehen der Ausschreibung',
      details: error.message 
    });
  }
});

// DELETE /api/offers/:offerId/remove-cancelled
app.delete('/api/offers/:offerId/remove-cancelled', async (req, res) => {
  const { offerId } = req.params;
  
  try {
    // Prüfe ob Angebot existiert und status 'cancelled' hat
    const offerData = await query(
      'SELECT * FROM offers WHERE id = $1 AND status = $2',
      [offerId, 'cancelled']
    );
    
    if (!offerData.rows || offerData.rows.length === 0) {
      return res.status(404).json({ 
        error: 'Storniertes Angebot nicht gefunden' 
      });
    }
    
    // Lösche das Angebot
    await query('DELETE FROM offers WHERE id = $1', [offerId]);
    
    res.json({
      success: true,
      message: 'Storniertes Angebot wurde erfolgreich entfernt'
    });
    
  } catch (error) {
    console.error('Error removing cancelled offer:', error);
    res.status(500).json({ 
      error: 'Fehler beim Entfernen des Angebots',
      details: error.message 
    });
  }
});

// POST /api/tenders/:tenderId/extend-deadline
app.post('/api/tenders/:tenderId/extend-deadline', async (req, res) => {
  const { tenderId } = req.params;
  const { newDeadline, projectId } = req.body;
  
  try {
    await query('BEGIN');
    
    // 1. Prüfe ob Ausschreibung existiert
   const tenderData = await query(
  `SELECT t.*, COALESCE(tr.name, t.trade_code, 'Unbekanntes Gewerk') as trade_name 
   FROM tenders t
   LEFT JOIN trades tr ON t.trade_id = tr.id
   WHERE t.id = $1 AND t.project_id = $2`,
  [tenderId, projectId]
);
    
    if (!tenderData.rows || tenderData.rows.length === 0) {
      await query('ROLLBACK');
      return res.status(404).json({ error: 'Ausschreibung nicht gefunden' });
    }
    
    const tender = tenderData.rows[0];
    
    // 2. Aktualisiere Deadline
    await query(
      'UPDATE tenders SET deadline = $1 WHERE id = $2',
      [newDeadline, tenderId]
    );
    
    // 3. Finde alle Handwerker für diese Ausschreibung
    const handwerkersData = await query(
      `SELECT th.handwerker_id, h.email, h.company_name
       FROM tender_handwerker th
       JOIN handwerker h ON th.handwerker_id = h.id
       WHERE th.tender_id = $1`,
      [tenderId]
    );
    
    // 4. Benachrichtige alle Handwerker über Fristverlängerung
    for (const hw of handwerkersData.rows) {
      await query(
        `INSERT INTO notifications (
          user_id, user_type, type, reference_id, message, metadata, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
        [
          hw.handwerker_id,
          'handwerker',
          'deadline_extended',
          tenderId,
          `Die Angebotsfrist für "${tender.trade_name}" wurde bis zum ${new Date(newDeadline).toLocaleDateString('de-DE')} verlängert.`,
          JSON.stringify({
            tenderId: tenderId,
            tradeName: tender.trade_name,
            newDeadline: newDeadline,
            projectId: projectId
          })
        ]
      );
    }
    
    await query('COMMIT');
    
    res.json({
      success: true,
      message: 'Frist wurde erfolgreich verlängert',
      newDeadline: newDeadline,
      notifiedHandwerkers: handwerkersData.rows.length
    });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error extending deadline:', error);
    res.status(500).json({ 
      error: 'Fehler beim Verlängern der Frist',
      details: error.message 
    });
  }
});

// GET /api/bauherr/:bauherrId/expiring-tenders
app.get('/api/bauherr/:bauherrId/expiring-tenders', async (req, res) => {
  const { bauherrId } = req.params;
  
  try {
    // Finde Ausschreibungen die in 1-2 Tagen ablaufen
    const tomorrow = new Date();
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    const dayAfterTomorrow = new Date();
    dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 2);
    
    const expiringTenders = await query(
      `SELECT t.id, t.trade_name, t.deadline, t.project_id, p.name as project_name
       FROM tenders t
       JOIN projects p ON t.project_id = p.id
       WHERE p.bauherr_id = $1
       AND t.status = 'active'
       AND t.deadline >= $2
       AND t.deadline <= $3
       AND NOT EXISTS (
         SELECT 1 FROM notifications 
         WHERE user_id = $1 
         AND user_type = 'bauherr'
         AND type = 'deadline_warning'
         AND reference_id = t.id
         AND created_at > NOW() - INTERVAL '24 hours'
       )`,
      [bauherrId, tomorrow.toISOString().split('T')[0], dayAfterTomorrow.toISOString().split('T')[0]]
    );
    
    // Erstelle Notifications für ablaufende Fristen
    for (const tender of expiringTenders.rows) {
      const daysRemaining = Math.ceil((new Date(tender.deadline) - new Date()) / (1000 * 60 * 60 * 24));
      
      await query(
        `INSERT INTO notifications (
          user_id, user_type, type, reference_id, message, metadata, created_at
        ) VALUES ($1, $2, $3, $4, $5, $6, NOW())`,
        [
          bauherrId,
          'bauherr',
          'deadline_warning',
          tender.id,
          `⏰ Die Angebotsfrist für "${tender.trade_name}" läuft in ${daysRemaining} Tag${daysRemaining !== 1 ? 'en' : ''} ab!`,
          JSON.stringify({
            tenderId: tender.id,
            tradeName: tender.trade_name,
            deadline: tender.deadline,
            projectId: tender.project_id,
            projectName: tender.project_name,
            action: 'view_tenders'
          })
        ]
      );
    }
    
    res.json({
      success: true,
      expiringTenders: expiringTenders.rows.length
    });
    
  } catch (error) {
    console.error('Error checking expiring tenders:', error);
    res.status(500).json({ 
      error: 'Fehler beim Prüfen ablaufender Fristen',
      details: error.message 
    });
  }
});

// ============================================================================
// WICHTIG: Diese Helper-Funktionen MÜSSEN VOR den Routen stehen!
// ============================================================================

// Helper: Lade LV-Daten für ein Gewerk
async function loadLVForTrade(projectId, tradeId) {
  const lvResult = await query(
    `SELECT l.*, t.name as trade_name, t.code as trade_code
     FROM lvs l
     JOIN trades t ON t.id = l.trade_id
     WHERE l.project_id = $1 AND l.trade_id = $2`,
    [projectId, tradeId]
  );
  
  if (!lvResult.rows[0]) {
    throw new Error('LV nicht gefunden');
  }
  
  const lv = lvResult.rows[0];
  
  // Parse LV content
  let lvContent;
  if (typeof lv.content === 'string') {
    lvContent = JSON.parse(lv.content);
  } else if (typeof lv.content === 'object' && lv.content !== null) {
    lvContent = lv.content;
  } else {
    throw new Error('LV-Daten ungültig');
  }
  
  if (!lvContent.positions || !Array.isArray(lvContent.positions)) {
    throw new Error('Keine Positionen im LV gefunden');
  }
  
  return { lv, lvContent };
}

// Helper: Lade Angebot mit Details
async function loadOfferDetails(offerId) {
  const offerResult = await query(
    `SELECT o.*,
            h.company_name,
            h.email,
            h.phone,
            t.name as trade_name,
            t.code as trade_code,
            tn.project_id
     FROM offers o
     JOIN handwerker h ON o.handwerker_id = h.id
     JOIN tenders tn ON o.tender_id = tn.id
     JOIN trades t ON tn.trade_id = t.id
     WHERE o.id = $1`,
    [offerId]
  );
  
  if (!offerResult.rows[0]) {
    throw new Error('Angebot nicht gefunden');
  }
  
  const offer = offerResult.rows[0];
  
  // Parse lv_data
  let offerPositions;
  if (offer.lv_data) {
    if (typeof offer.lv_data === 'string') {
      offerPositions = JSON.parse(offer.lv_data);
    } else {
      offerPositions = offer.lv_data;
    }
  } else {
    throw new Error('Angebot enthält keine Positionen');
  }
  
  return { offer, offerPositions };
}

// ----------------------------------------------------------------------------
// 1. EINZELNE ANGEBOTSBEWERTUNG (Ein Angebot)
// ----------------------------------------------------------------------------
app.post('/api/projects/:projectId/trades/:tradeId/offers/:offerId/evaluate', async (req, res) => {
  console.log('[OFFER-EVALUATE] Starting single offer evaluation');
  
  try {
    const { projectId, tradeId, offerId } = req.params;
    console.log('[OFFER-EVALUATE] Params:', { projectId, tradeId, offerId });
    
    // 1. Lade Original-LV mit KI-Preisen
    console.log('[OFFER-EVALUATE] Step 1: Loading LV...');
    const lvData = await query(
      `SELECT l.*, t.name as trade_name, t.code as trade_code 
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id 
       WHERE l.project_id = $1 AND l.trade_id = $2`,
      [projectId, tradeId]
    );
    console.log('[OFFER-EVALUATE] LV found:', !!lvData.rows[0]);
    
    if (!lvData.rows[0]) {
      console.log('[OFFER-EVALUATE] ERROR: No LV found!');
      return res.status(404).json({ error: 'Leistungsverzeichnis nicht gefunden' });
    }
    console.log('[OFFER-EVALUATE] Step 2: Parsing LV...');
    const lv = lvData.rows[0];
    
    // Parse LV Content
    let lvContent;
    if (typeof lv.content === 'string') {
      try {
        lvContent = JSON.parse(lv.content);
      } catch (parseError) {
        console.error('[OFFER-EVALUATE] Failed to parse LV content:', parseError);
        return res.status(500).json({ error: 'LV-Daten fehlerhaft' });
      }
    } else if (typeof lv.content === 'object' && lv.content !== null) {
      lvContent = lv.content;
    } else {
      return res.status(500).json({ error: 'LV-Daten ungültig' });
    }
    
    if (!lvContent.positions || !Array.isArray(lvContent.positions)) {
      return res.status(400).json({ error: 'Keine Positionen im LV gefunden' });
    }
    
    // 2. Lade Angebotsdaten
    const offerData = await query(
  `SELECT 
    o.*, 
    o.bundle_discount,     
    h.company_name, 
    h.email, 
    h.phone, 
    t.name as trade_name,
    tn.bundle_id,          
    tn.project_id,
    p.bauherr_id,          
    b.name as bauherr_name 
   FROM offers o
   JOIN handwerker h ON o.handwerker_id = h.id
   JOIN tenders tn ON o.tender_id = tn.id
   JOIN trades t ON tn.trade_id = t.id
   JOIN projects p ON tn.project_id = p.id       
   JOIN bauherren b ON p.bauherr_id = b.id        
   WHERE o.id = $1 AND tn.project_id = $2 AND tn.trade_id = $3`,
  [offerId, projectId, tradeId]
);
    
    if (!offerData.rows[0]) {
      return res.status(404).json({ error: 'Angebot nicht gefunden' });
    }
    
    const offer = offerData.rows[0];
    
    // Parse Offer LV Data
    let offerLvData;
    if (typeof offer.lv_data === 'string') {
      try {
        offerLvData = JSON.parse(offer.lv_data);
      } catch (parseError) {
        console.error('[OFFER-EVALUATE] Failed to parse offer lv_data:', parseError);
        return res.status(500).json({ error: 'Angebotsdaten fehlerhaft' });
      }
    } else if (typeof offer.lv_data === 'object' && offer.lv_data !== null) {
      offerLvData = offer.lv_data;
    } else {
      return res.status(500).json({ error: 'Angebotsdaten ungültig' });
    }

    // FÜGE DIESE ZEILEN HIER EIN:
if (Array.isArray(offerLvData)) {
  offerLvData = { positions: offerLvData };
}
    
    if (!offerLvData.positions || !Array.isArray(offerLvData.positions)) {
      return res.status(400).json({ error: 'Keine Positionen im Angebot gefunden' });
    }
    
    // 3. Lade Projekt-Kontext
    const projectData = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    // 4. System-Prompt für Einzelbewertung
    const systemPrompt = `Du bist ein erfahrener Baukalkulator und Sachverständiger für ${lv.trade_name}.

AUFGABE: Bewerte dieses einzelne Angebot professionell und objektiv. Erstelle eine verständliche Empfehlung für einen Bauherren (Laien).

WICHTIGE PRÜFPUNKTE:

1. VOLLSTÄNDIGKEIT
   - Sind ALLE Positionen aus dem LV ausgefüllt?
   - Fehlen Positionen komplett?
   - Sind Mengen korrekt übernommen?
   - Sind alle Einheitspreise angegeben?

2. PREISLICHE PLAUSIBILITÄT
   - Vergleiche JEDEN Preis mit dem KI-Referenzpreis
   - Identifiziere Ausreißer (>20% Abweichung)
   - Bewerte ob Abweichungen nachvollziehbar sind
   - Prüfe Gesamtsumme vs. KI-Schätzung

3. ZUSÄTZLICHE POSITIONEN
   - Gibt es Positionen die NICHT im Original-LV sind?
   - Ist die Begründung plausibel und notwendig?
   - Sind die Preise dafür angemessen?

4. QUALITÄTSMERKMALE
   - Materialqualität erkennbar?
   - Ausführungsstandard klar beschrieben?
   - Gewährleistung/Garantie angegeben?

5. VERTRAGLICHE ASPEKTE
   - Sind Ausführungszeiten realistisch?
   - Zahlungsbedingungen fair?
   - Gibt es versteckte Kosten?

BEWERTUNGSSYSTEM (AMPEL):

🟢 GRÜN = Gutes Angebot
- Vollständig ausgefüllt
- Preise im marktüblichen Rahmen (±15% vom KI-Preis)
- Keine gravierenden Auffälligkeiten
- Klare und nachvollziehbare Positionen
→ Empfehlung: Kann beauftragt werden

🟡 GELB = Angebot mit Auffälligkeiten
- Kleinere Lücken oder Unklarheiten
- Preise teilweise außerhalb Rahmen (±15-30%)
- Einzelne Positionen erklärungsbedürftig
- Zusatzpositionen sollten hinterfragt werden
→ Empfehlung: Nachverhandlung empfohlen

🔴 ROT = Problematisches Angebot
- Wesentliche Positionen fehlen
- Preise unrealistisch (>30% Abweichung)
- Viele ungeklärte Zusatzpositionen
- Unklare oder unfaire Vertragsbedingungen
→ Empfehlung: Vergabe nicht empfohlen

AUSGABE als JSON:
{
  "rating": "green|yellow|red",
  "overallScore": 1-100,
  "summary": "Kurze 2-3 Sätze Zusammenfassung",
  
  "completeness": {
    "score": 1-100,
    "missingPositions": ["Pos 1.2", "Pos 3.4"],
    "incompletePositions": ["Pos 2.1: Fehlende Menge"],
    "assessment": "Detaillierte Bewertung"
  },
  
  "priceAnalysis": {
    "totalOffer": Zahl,
    "totalReference": Zahl,
    "deviationPercent": Zahl,
    "deviationAmount": Zahl,
    "outliers": [
      {
        "position": "Pos-Nr",
        "title": "Positionstitel",
        "offerPrice": Zahl,
        "referencePrice": Zahl,
        "deviationPercent": Zahl,
        "severity": "low|medium|high",
        "explanation": "Warum ist das auffällig?"
      }
    ],
    "assessment": "Gesamtbewertung der Preise"
  },
  
  "additionalPositions": [
    {
      "position": "Neue Pos-Nr",
      "title": "Titel",
      "amount": Zahl,
      "justification": "Ist die Begründung plausibel?",
      "recommendation": "Sollte akzeptiert/verhandelt/abgelehnt werden"
    }
  ],
  
  "qualityAssessment": {
    "materialsSpecified": true/false,
    "executionStandardClear": true/false,
    "warrantyIncluded": true/false,
    "notes": "Qualitätsmerkmale"
  },
  
  "negotiationPoints": [
    {
      "position": "Pos-Nr oder Thema",
      "issue": "Was ist das Problem?",
      "suggestion": "Konkrete Verhandlungsempfehlung",
      "potentialSaving": Zahl
    }
  ],
  
  "risks": [
    "Konkrete Risiken und Bedenken"
  ],
  
  "recommendation": {
    "action": "accept|negotiate|reject",
    "reasoning": "Begründung der Empfehlung",
    "nextSteps": [
      "Konkreter nächster Schritt für den Bauherren"
    ]
  }
}

WICHTIG:
- Sei objektiv und fair
- Erkläre Fachbegriffe in einfacher Sprache
- Gib konkrete, umsetzbare Empfehlungen
- Bei Gelb/Rot: Klare Handlungsanweisungen

KRITISCH: Antworte NUR mit validem JSON ohne Markdown-Codeblocks!`;

    // 5. User-Prompt zusammenstellen
    const userPrompt = `ORIGINAL-LEISTUNGSVERZEICHNIS (KI-REFERENZPREISE):
Gewerk: ${lv.trade_name}
Gesamtsumme (KI-Schätzung): ${lvContent.totalSum}€

POSITIONEN MIT REFERENZPREISEN:
${lvContent.positions.map(pos => 
  `Position ${pos.pos}:
   Titel: ${pos.title}
   Beschreibung: ${pos.description || 'Keine Details'}
   Menge: ${pos.quantity} ${pos.unit}
   KI-Einzelpreis: ${pos.unitPrice}€
   KI-Gesamtpreis: ${pos.totalPrice}€
   ${pos.isNEP ? '(NEP - Eventualposition)' : ''}
   ---`
).join('\n')}

═══════════════════════════════════════════════════════════════

EINGEREICHTES ANGEBOT:
Firma: ${offer.company_name}
Angebotssumme: ${offer.amount}€
Ausführungszeit: ${offer.execution_time || 'Nicht angegeben'}

ANGEBOTSPOSITIONEN:
${offerLvData.positions.map(pos => 
  `Position ${pos.pos}:
   Titel: ${pos.title}
   Beschreibung: ${pos.description || 'Keine Details'}
   Menge: ${pos.quantity} ${pos.unit}
   ANGEBOTS-Einzelpreis: ${pos.unitPrice}€
   ANGEBOTS-Gesamtpreis: ${pos.totalPrice}€
   ---`
).join('\n')}

PROJEKT-KONTEXT:
Kategorie: ${projectData.rows[0]?.category || 'Sanierung'}
Beschreibung: ${projectData.rows[0]?.description || 'Keine Details'}

Bewerte dieses Angebot umfassend und erstelle eine Empfehlung!`;

    // 6. Claude API Call
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });

    console.log('[OFFER-EVALUATE] Calling Claude API...');
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 16000,
      temperature: 0.3,
      system: systemPrompt,
      messages: [
        { 
          role: 'user', 
          content: userPrompt
        }
      ]
    });

    // 7. Parse Response
    let evaluation;
    try {
      let responseText = response.content[0].text.trim();
      
      // Bereinigung
      responseText = responseText
        .replace(/^```json\s*\n?/, '')
        .replace(/^```\s*\n?/, '')
        .replace(/\n?```\s*$/, '')
        .trim();
      
      console.log('[OFFER-EVALUATE] Response length:', responseText.length);
      
      evaluation = JSON.parse(responseText);
      
    } catch (parseError) {
      console.error('[OFFER-EVALUATE] Parse error:', parseError.message);
      console.error('[OFFER-EVALUATE] Response snippet:', response.content[0].text.substring(0, 500));
      
      return res.status(500).json({ 
        error: 'Fehler bei der Analyse', 
        details: parseError.message 
      });
    }
    
    // 8. Speichere Bewertung in DB
    const bauherrResult = await query(
      'SELECT bauherr_id FROM projects WHERE id = $1',
      [projectId]
    );
    
    await query(
      `INSERT INTO offer_evaluations 
       (project_id, trade_id, evaluation_type, offer_ids, rating, recommendation, evaluation_data, created_by, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())`,
      [
        projectId, 
        tradeId, 
        'single', 
        `{${offerId}}`,
        evaluation.rating,
        evaluation.recommendation?.reasoning || evaluation.summary,
        JSON.stringify(evaluation),
        bauherrResult.rows[0]?.bauherr_id
      ]
    );
    
    console.log(`[OFFER-EVALUATE] Evaluation completed with rating: ${evaluation.rating}`);
    res.json(evaluation);
    
  } catch (err) {
    console.error('[OFFER-EVALUATE] Evaluation failed:', err);
    console.error('[OFFER-EVALUATE] ERROR DETAILS:', err.message);
    res.status(500).json({ 
      error: 'Bewertung fehlgeschlagen',
      details: err.message 
    });
  }
});

// ----------------------------------------------------------------------------
// 2. VERGABEEMPFEHLUNG (Mehrere Angebote vergleichen)
// ----------------------------------------------------------------------------
app.post('/api/projects/:projectId/trades/:tradeId/offers/compare', async (req, res) => {
  console.log('[OFFER-COMPARE] Starting offer comparison');
  
  try {
    const { projectId, tradeId } = req.params;
    const offersData = await query(
  `SELECT 
    o.*, 
    o.bundle_discount,     
    h.company_name, 
    h.email, 
    h.phone, 
    t.name as trade_name,
    tn.bundle_id,          
    p.bauherr_id,          
    b.name as bauherr_name 
   FROM offers o
   JOIN handwerker h ON o.handwerker_id = h.id
   JOIN tenders tn ON o.tender_id = tn.id
   JOIN trades t ON tn.trade_id = t.id
   JOIN projects p ON tn.project_id = p.id        
   JOIN bauherren b ON p.bauherr_id = b.id        
   WHERE tn.project_id = $1 AND tn.trade_id = $2
     AND o.status IN ('submitted', 'preliminary', 'confirmed')
   ORDER BY o.amount ASC`,
  [projectId, tradeId]
);

if (offersData.rows.length < 2) {
  return res.status(400).json({ error: 'Mindestens 2 Angebote erforderlich' });
}

const offers = offersData.rows;
const offerIds = offers.map(o => o.id);
    
    // 1. Lade Original-LV mit KI-Preisen
    const lvData = await query(
      `SELECT l.*, t.name as trade_name, t.code as trade_code 
       FROM lvs l 
       JOIN trades t ON t.id = l.trade_id 
       WHERE l.project_id = $1 AND l.trade_id = $2`,
      [projectId, tradeId]
    );
    
    if (!lvData.rows[0]) {
      return res.status(404).json({ error: 'Leistungsverzeichnis nicht gefunden' });
    }
    
    const lv = lvData.rows[0];
    
    // Parse LV Content
    let lvContent;
    if (typeof lv.content === 'string') {
      lvContent = JSON.parse(lv.content);
    } else {
      lvContent = lv.content;
    }
    
    // Parse alle Offer LV Data
    const parsedOffers = offers.map(offer => {
      let offerLvData;
      if (typeof offer.lv_data === 'string') {
        offerLvData = JSON.parse(offer.lv_data);
      } else {
        offerLvData = offer.lv_data;
      }

      // HIER EINFÜGEN (nach Zeile 386):
  if (Array.isArray(offerLvData)) {
    offerLvData = { positions: offerLvData };
  }
      
      return {
        ...offer,
        parsed_lv: offerLvData
      };
    });
    
    // 3. Lade Projekt-Kontext
    const projectData = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    // 4. System-Prompt für Vergleich
    const systemPrompt = `Du bist ein erfahrener Baukalkulator und Sachverständiger für ${lv.trade_name}.

AUFGABE: Vergleiche diese ${offers.length} Angebote professionell und objektiv. Erstelle eine klare Vergabeempfehlung für einen Bauherren (Laien).

WICHTIGE VERGLEICHSKRITERIEN:

1. PREISVERGLEICH
   - Gesamtpreise im Vergleich
   - Positionsweise Vergleiche
   - Identifiziere wo welches Angebot günstiger/teurer ist
   - Bewerte Preis-Leistungs-Verhältnis vs. KI-Referenz

2. VOLLSTÄNDIGKEIT & QUALITÄT
   - Welches Angebot ist am vollständigsten?
   - Welches hat die besten Materialbeschreibungen?
   - Wo fehlen wichtige Informationen?

3. AUFFÄLLIGKEITEN
   - Gibt es bei einzelnen Angeboten Besonderheiten?
   - Unrealistisch niedrige oder hohe Preise?
   - Zusatzpositionen die nur bei einem vorkommen?

4. RISIKOBEWERTUNG
   - Welches Angebot birgt die wenigsten Risiken?
   - Wo könnten Nachträge drohen?
   - Qualitätsrisiken?

RECHTLICHER HINWEIS:
Die Bewertung erfolgt ohne Gewähr auf Basis der vorliegenden Informationen. Sie ersetzt keine fachliche Beratung durch einen Sachverständigen. Der Bauherr trägt die Verantwortung für die finale Vergabeentscheidung.

AUSGABE als JSON:
{
  "summary": "Kurze 3-4 Sätze Executive Summary mit klarer Empfehlung",
  
  "legalDisclaimer": "Rechtlich saubere Formulierung des Haftungsausschlusses",
  
  "priceComparison": {
    "cheapest": {
      "offerId": Zahl,
      "company": "Name",
      "amount": Zahl
    },
    "mostExpensive": {
      "offerId": Zahl,
      "company": "Name",
      "amount": Zahl
    },
    "referencePrice": Zahl,
    "priceRange": {
      "min": Zahl,
      "max": Zahl,
      "spread": Zahl,
      "spreadPercent": Zahl
    },
    "assessment": "Bewertung der Preisunterschiede"
  },
  
  "offerAnalysis": [
    {
      "offerId": Zahl,
      "company": "Name",
      "amount": Zahl,
      "rank": Zahl (1 = beste Empfehlung),
      "rating": "green|yellow|red",
      "score": 1-100,
      
      "strengths": [
        "Stärke 1",
        "Stärke 2"
      ],
      
      "weaknesses": [
        "Schwäche 1",
        "Schwäche 2"
      ],
      
      "priceDeviation": {
        "vsReference": Zahl (in Prozent),
        "vsCheapest": Zahl (in Euro),
        "assessment": "Bewertung"
      },
      
      "completeness": 1-100,
      "qualityIndicators": 1-100,
      "riskLevel": "low|medium|high",
      
      "detailedFindings": [
        {
          "category": "Preis|Vollständigkeit|Qualität|Risiko",
          "finding": "Konkrete Feststellung",
          "impact": "Auswirkung",
          "severity": "low|medium|high"
        }
      ]
    }
  ],
  
  "positionComparison": [
    {
      "position": "Pos-Nr",
      "title": "Positionstitel",
      "referencePrice": Zahl,
      "offers": [
        {
          "offerId": Zahl,
          "company": "Name",
          "price": Zahl,
          "deviation": Zahl (in Prozent)
        }
      ],
      "assessment": "Bewertung dieser Position über alle Angebote",
      "noteworthy": true/false,
      "reason": "Warum ist das bemerkenswert?"
    }
  ],
  
  "recommendation": {
    "recommendedOfferId": Zahl,
    "recommendedCompany": "Name",
    "confidence": "high|medium|low",
    
    "reasoning": "Ausführliche Begründung warum dieses Angebot empfohlen wird",
    
    "alternatives": [
      {
        "offerId": Zahl,
        "company": "Name",
        "condition": "Unter welcher Bedingung wäre das eine Alternative?"
      }
    ],
    
    "negotiationStrategy": [
      {
        "offerId": Zahl,
        "company": "Name",
        "points": [
          "Konkreter Verhandlungspunkt mit der empfohlenen Firma"
        ]
      }
    ],
    
    "redFlags": [
      {
        "offerId": Zahl,
        "company": "Name",
        "issue": "Warnung/Problem"
      }
    ]
  },
  
  "nextSteps": [
    "Konkreter nächster Schritt 1",
    "Konkreter nächster Schritt 2"
  ]
}

WICHTIG:
- Sei objektiv aber klar in der Empfehlung
- Das günstigste Angebot ist NICHT automatisch das beste
- Berücksichtige Preis UND Qualität UND Vollständigkeit
- Erkläre komplexe Sachverhalte verständlich
- Gib umsetzbare Handlungsempfehlungen

KRITISCH: Antworte NUR mit validem JSON ohne Markdown-Codeblocks!`;

    // 5. User-Prompt zusammenstellen
    const userPrompt = `ORIGINAL-LEISTUNGSVERZEICHNIS (KI-REFERENZPREISE):
Gewerk: ${lv.trade_name}
Gesamtsumme (KI-Schätzung): ${lvContent.totalSum}€

REFERENZPOSITIONEN:
${lvContent.positions.map(pos => 
  `Pos ${pos.pos}: ${pos.title}
   Menge: ${pos.quantity} ${pos.unit}
   KI-Preis: ${pos.unitPrice}€/Einheit = ${pos.totalPrice}€ gesamt
   ---`
).join('\n')}

═══════════════════════════════════════════════════════════════

EINGEREICHTE ANGEBOTE (${offers.length} Stück):

${parsedOffers.map((offer, idx) => `
ANGEBOT ${idx + 1}:
Firma: ${offer.company_name}
Angebotssumme: ${offer.amount}€
Ausführungszeit: ${offer.execution_time || 'Nicht angegeben'}
Notizen: ${offer.notes || 'Keine'}

POSITIONEN:
${offer.parsed_lv.positions.map(pos => 
  `Pos ${pos.pos}: ${pos.title}
   Menge: ${pos.quantity} ${pos.unit}
   Preis: ${pos.unitPrice}€/Einheit = ${pos.totalPrice}€ gesamt`
).join('\n')}

───────────────────────────────────────────────────────────────
`).join('\n')}

PROJEKT-KONTEXT:
Kategorie: ${projectData.rows[0]?.category || 'Sanierung'}

Vergleiche diese Angebote und erstelle eine fundierte Vergabeempfehlung!`;

    // 6. Claude API Call
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });

    console.log('[OFFER-COMPARE] Calling Claude API...');
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 16000,
      temperature: 0.3,
      system: systemPrompt,
      messages: [
        { 
          role: 'user', 
          content: userPrompt
        }
      ]
    });

    // 7. Parse Response
    let comparison;
    try {
      let responseText = response.content[0].text.trim();
      
      responseText = responseText
        .replace(/^```json\s*\n?/, '')
        .replace(/^```\s*\n?/, '')
        .replace(/\n?```\s*$/, '')
        .trim();
      
      console.log('[OFFER-COMPARE] Response length:', responseText.length);
      
      comparison = JSON.parse(responseText);
      
    } catch (parseError) {
      console.error('[OFFER-COMPARE] Parse error:', parseError.message);
      console.error('[OFFER-COMPARE] Response snippet:', response.content[0].text.substring(0, 500));
      
      return res.status(500).json({ 
        error: 'Fehler beim Vergleich', 
        details: parseError.message 
      });
    }
    
    // 8. Speichere Vergleich in DB
    const bauherrResult = await query(
      'SELECT bauherr_id FROM projects WHERE id = $1',
      [projectId]
    );
    
    await query(
      `INSERT INTO offer_evaluations 
       (project_id, trade_id, evaluation_type, offer_ids, rating, recommendation, evaluation_data, created_by, created_at)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, NOW())`,
      [
        projectId, 
        tradeId, 
        'comparison', 
        offerIds,
        null, // Kein einzelnes Rating bei Vergleich
        comparison.recommendation?.reasoning || comparison.summary,
        JSON.stringify(comparison),
        bauherrResult.rows[0]?.bauherr_id
      ]
    );
    
    console.log(`[OFFER-COMPARE] Comparison completed for ${offers.length} offers`);
    res.json(comparison);
    
  } catch (err) {
    console.error('[OFFER-COMPARE] Comparison failed:', err);
    res.status(500).json({ 
      error: 'Vergleich fehlgeschlagen',
      details: err.message 
    });
  }
});

// ----------------------------------------------------------------------------
// 3. GESPEICHERTE BEWERTUNGEN ABRUFEN
// ----------------------------------------------------------------------------
app.get('/api/projects/:projectId/trades/:tradeId/evaluations', async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    
    const result = await query(
      `SELECT * FROM offer_evaluations 
       WHERE project_id = $1 AND trade_id = $2
       ORDER BY created_at DESC`,
      [projectId, tradeId]
    );
    
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching evaluations:', error);
    res.status(500).json({ error: 'Fehler beim Laden der Bewertungen' });
  }
});

// ============================================================================
// TERMINPLANUNGS-SYSTEM - BACKEND ROUTES
// ============================================================================
// Zweck: KI-gestützte Bauablaufplanung mit Handwerker-Koordination
// ============================================================================

const { validateAndFixDependencies } = require('./dependency-validator');

// ============================================================================
// HILFSFUNKTIONEN - KORRIGIERT MIT FEIERTAGEN
// ============================================================================

// Lade Feiertage beim Start
let publicHolidays = new Set();

async function loadPublicHolidays() {
  try {
    const result = await query('SELECT day, month FROM public_holidays');
    publicHolidays = new Set(result.rows.map(row => `${row.month}-${row.day}`));
    console.log('[SCHEDULE] Loaded', publicHolidays.size, 'public holidays');
  } catch (err) {
    console.error('[SCHEDULE] Failed to load holidays:', err);
  }
}

loadPublicHolidays();

function isWorkday(date) {
  const dayOfWeek = date.getDay();
  
  // Wochenende?
  if (dayOfWeek === 0 || dayOfWeek === 6) return false;
  
  // Feiertag?
  const dateKey = `${date.getMonth() + 1}-${date.getDate()}`;
  if (publicHolidays.has(dateKey)) return false;
  
  return true;
}

// Berechne Arbeitstage (Mo-Fr, OHNE Feiertage) zwischen zwei Daten
function calculateWorkdays(startDate, endDate) {
  let count = 0;
  const current = new Date(startDate);
  const end = new Date(endDate);
  
  while (current <= end) {
    if (isWorkday(current)) {  // ← JETZT mit Feiertags-Check!
      count++;
    }
    current.setDate(current.getDate() + 1);
  }
  
  return count;
}

// Addiere Arbeitstage zu einem Datum (überspringt Wochenenden UND Feiertage)
function addWorkdays(startDate, days) {
  const result = new Date(startDate);
  let addedDays = 0;
  
  while (addedDays < days) {
    result.setDate(result.getDate() + 1);
    
    if (isWorkday(result)) {  // ← JETZT mit Feiertags-Check!
      addedDays++;
    }
  }
  
  return result;
}

// Prüfe ob genug Gewerke für Terminplan vorhanden sind
async function checkScheduleEligibility(projectId) {
  const result = await query(
    `SELECT COUNT(DISTINCT pt.trade_id) as trade_count
     FROM project_trades pt
     JOIN trades t ON pt.trade_id = t.id
     WHERE pt.project_id = $1 AND t.code != 'INT'`,
    [projectId]
  );
  
  return result.rows[0].trade_count >= 2;
}

// Lade Gewerkeabgrenzungs-Dokument für KI-Kontext
function getTradeInterfacesPrompt() {
  return `GEWERKEABGRENZUNG & SCHNITTSTELLENKLARHEIT:
   - KEINE Doppelungen zwischen Gewerken
   - Hierarchie: Spezialgewerk > Hauptgewerk > Nebengewerk
   
   KRITISCHE ZUORDNUNGEN (IMMER EINHALTEN):
   * Fliesenarbeiten: AUSSCHLIESSLICH Gewerk FLI (Fliesenarbeiten), NIEMALS BOD (Bodenbelagsarbeiten)
   * Innentüren/Zargen: AUSSCHLIESSLICH Gewerk TIS (Tischlerarbeiten), NIEMALS TRO (Trockenbau) oder FEN (Fenster/Türen)
   * Rigips/Gipskartonwände: AUSSCHLIESSLICH Gewerk TRO (Trockenbau), NIEMALS ROH (Rohbau)
   * Elektroschlitze: NUR bei ELEKT, nicht bei ROH oder ABBR
   * Sanitärschlitze: NUR bei SAN, nicht bei ROH oder ABBR
   * Elektrische Fußbodenheizung: NUR bei ELEKT oder FLI, NIEMALS bei SAN
   * Warmwasser-Fußbodenheizung: NUR bei HEI (Heizung), nicht bei SAN
   * Vorwandinstallation: NUR bei TRO (Trockenbau), nicht bei SAN
   * Abdichtungen Bad: NUR bei FLI (unter Fliesen), nicht bei SAN
   
   WICHTIGE SCHNITTSTELLEN-MATRIX:
   
   - Bad-Sanierung: 
     SAN/ELEKT/HEI (Rohinstallation) → TRO (Vorwand) → FLI (Abdichtung + Fliesen) → MAL (Anstrich) → SAN/ELEKT/HEI (Endmontage)
     
   - Dachausbau: 
     ZIMM/DACH (Konstruktion) → ELEKT/SAN/HEI (Leitungen) → TRO (Verkleidung) → MAL/BOD/FLI (Finish) → SAN/ELEKT/HEI (Endmontage)
     
   - Fassade mit WDVS und Fenstern: 
     GER (Gerüst) → FEN (Einbau Fenster) → FASS (WDVS + Dämmung) → FASS (Putz + Anstrich)
   
   - Heizungstausch: 
     HEI (Heizung) → ELEKT (Stromanschluss) → MAL (Anstrich Heizungsraum)
   
   - Kernsanierung Wohnung:
     ABBR (Entkernung) → ELEKT/SAN (Grundleitungen) → ROH (Wanddurchbrüche) → TRO (neue Raumaufteilung) → ESTR (Estrich) → FLI/BOD (Bodenbeläge) → TIS (Türen) → MAL (Komplettanstrich)
   
   REIHENFOLGE-PRINZIPIEN:
   1. Abbruch/Rückbau immer zuerst
   2. Rohbau/Statik vor Ausbau
   3. Installationen (ELEKT/SAN/HEI) Rohinstallation vor Verkleidung
   4. Trockenbau vor Nassarbeiten wo möglich
   5. Bodenbeläge nach Wänden
   6. Malerarbeiten als Finish
   7. Endmontage Sanitär/Elektro ganz zum Schluss`;
}

// ============================================================================
// 1. TERMINPLAN INITIIEREN (von Bauherrn)
// ============================================================================

app.post('/api/projects/:projectId/schedule/initiate', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { targetDate, dateType } = req.body; // dateType: 'start' oder 'end'
    
    console.log('[SCHEDULE] Initiating schedule for project:', projectId);
    
    // Prüfe ob Projekt existiert
    const projectResult = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Projekt nicht gefunden' });
    }
    
    const project = projectResult.rows[0];
    
    // Prüfe ob genug Gewerke vorhanden sind (mind. 2)
    const isEligible = await checkScheduleEligibility(projectId);
    if (!isEligible) {
      return res.status(400).json({ 
        error: 'Mindestens 2 Gewerke erforderlich für Terminplanung' 
      });
    }
    
   // Prüfe ob bereits ein AKTIVER Terminplan existiert 
const existingSchedule = await query(
  `SELECT id, status FROM project_schedules 
   WHERE project_id = $1 
   AND status IN ('pending_approval', 'locked', 'active', 'completed')`,
  [projectId]
);

if (existingSchedule.rows.length > 0) {
  return res.status(400).json({ 
    error: 'Terminplan existiert bereits für dieses Projekt',
    scheduleId: existingSchedule.rows[0].id,
    status: existingSchedule.rows[0].status
  });
}
    
    // Erstelle Draft-Schedule
    const scheduleResult = await query(
      `INSERT INTO project_schedules 
       (project_id, status, ${dateType === 'start_date' ? 'target_start_date' : 'target_completion_date'}, input_type)
       VALUES ($1, 'draft', $2, $3)
       RETURNING id`,
      [projectId, targetDate, dateType]
    );
    
    const scheduleId = scheduleResult.rows[0].id;
    
    console.log('[SCHEDULE] Created draft schedule:', scheduleId);
    
    res.json({ 
      success: true, 
      scheduleId,
      message: 'Terminplan initiiert, KI-Generierung kann gestartet werden'
    });
    
  } catch (err) {
    console.error('[SCHEDULE] Initiation failed:', err);
    res.status(500).json({ error: 'Fehler beim Initiieren des Terminplans' });
  }
});

// ============================================================================
// 2. TERMINPLAN GENERIEREN (KI-basiert) - FIXED VERSION
// ============================================================================

app.post('/api/projects/:projectId/schedule/generate', async (req, res) => {
  try {
    const { projectId } = req.params;

    runningGenerations.add(projectId);
    
    console.log('[SCHEDULE-GEN] Starting generation for project:', projectId);
    
    // Lade Schedule
    const scheduleResult = await query(
      'SELECT * FROM project_schedules WHERE project_id = $1',
      [projectId]
    );
    
    if (scheduleResult.rows.length === 0) {
      return res.status(404).json({ error: 'Terminplan nicht gefunden. Bitte zuerst initiieren.' });
    }
    
    const schedule = scheduleResult.rows[0];
    
    if (schedule.status !== 'draft') {
      return res.status(400).json({ error: 'Terminplan kann nicht mehr generiert werden' });
    }
    
    // Lade Projektdaten
    const projectResult = await query(
      `SELECT p.*, 
        ARRAY_AGG(
          json_build_object(
            'id', t.id,
            'code', t.code,
            'name', t.name
          )
        ) as trades
       FROM projects p
       JOIN project_trades pt ON p.id = pt.project_id
       JOIN trades t ON pt.trade_id = t.id
       WHERE p.id = $1 AND t.code != 'INT'
       GROUP BY p.id`,
      [projectId]
    );
    
    const project = projectResult.rows[0];
    
    // Lade Standard-Phasen für alle Gewerke
    const phasesResult = await query(
      `SELECT * FROM trade_standard_phases 
       WHERE trade_code = ANY($1::text[])
       ORDER BY trade_code, phase_number`,
      [project.trades.map(t => t.code)]
    );
    
    const tradePhases = {};
    phasesResult.rows.forEach(phase => {
      if (!tradePhases[phase.trade_code]) {
        tradePhases[phase.trade_code] = [];
      }
      tradePhases[phase.trade_code].push(phase);
    });
    
    // Lade Intake-Antworten für Kontext
    const intTradeResult = await query("SELECT id FROM trades WHERE code='INT'");
    const intTradeId = intTradeResult.rows[0]?.id;
    
    let intakeAnswers = [];
    if (intTradeId) {
      const answersResult = await query(
  `SELECT q.text as question, a.answer_text as answer
   FROM answers a
   JOIN questions q ON q.project_id = a.project_id 
     AND q.trade_id = a.trade_id 
     AND q.question_id = a.question_id
   WHERE a.project_id=$1 AND a.trade_id=$2
   ORDER BY q.question_id`,
  [projectId, intTradeId]
);
      intakeAnswers = answersResult.rows;
    }
    // NEU: Lade fertige LVs für jeden Trade
    const lvsResult = await query(
      `SELECT l.trade_id, t.code, t.name, l.content
       FROM lvs l
       JOIN trades t ON l.trade_id = t.id
       WHERE l.project_id = $1 AND t.code = ANY($2::text[])`,
      [projectId, project.trades.map(t => t.code)]
    );
    
    const lvsByTrade = {};
    let totalProjectValue = 0;
    
    lvsResult.rows.forEach(lv => {
      const positions = lv.content?.positions || [];
      const totalSum = lv.content?.totalSum || 0;
      totalProjectValue += totalSum;
      
      // Analysiere Umfang pro Gewerk - ALLE Positionen
      const positionSummary = positions.map(pos => ({
        title: pos.title,
        quantity: pos.quantity,
        unit: pos.unit,
        description: pos.description?.substring(0, 100)
      }));
      
      lvsByTrade[lv.code] = {
        trade_name: lv.name,
        total_positions: positions.length,
        total_sum: totalSum,
        position_summary: positionSummary,
        has_complex_positions: positions.some(p => p.quantity > 100 || p.totalPrice > 5000)
      };
    });
    
    // System-Prompt für KI
    const systemPrompt = `Du bist ein erfahrener Bauleiter mit 20+ Jahren Erfahrung in privaten Bau- und Sanierungsprojekten. 
Deine Aufgabe ist es, einen realistischen, professionellen Bauablaufplan zu erstellen, der auf den TATSÄCHLICHEN Leistungsmengen aus den Leistungsverzeichnissen basiert.

${getTradeInterfacesPrompt()}

# KERNPRINZIPIEN DER TERMINPLANUNG

## 1. LV-BASIERTE DAUERSCHÄTZUNG

### Bewertungsmatrix nach Gewerk und Umfang:
  
**ROHBAU (ROH):**
- Klein (<15k€): 5-8 Tage
- Mittel (15-40k€): 10-20 Tage
- Groß (>40k€): 20-40 Tage
- Sanierung: +30% (unvorhergesehene Probleme)
- **WICHTIG: Kleinere Rohbauarbeiten (Wanddurchbrüche, Ausstemmen) mit <5k€ können parallel zu anderen Gewerken laufen!**
  - Setze bei solchen Arbeiten: is_minor_work: true
  - Setze can_parallel_with: ["DACH", "FEN", "FASS", "MAL", "TRO"] (je nach Kontext)

**GERÜSTBAU (GER):**
- Aufbau: 1-2 Tage (abhängig von Gebäudehöhe)
  - <250m² Fassade: 1 Tag
  - >250m² Fassade oder >3 Geschosse: 2 Tage
- Abbau: 0,5-1 Tag
- WICHTIG: NUR Auf- und Abbau als separate Phasen
- Standzeit wird NICHT als Phase eingeplant (nur Info für Bauherrn in general_explanation)
- Aufbau muss VOR allen Außenarbeiten (DACH, ZIMM, FEN, FASS)
- Abbau muss NACH allen Außenarbeiten
- Dependencies Aufbau: Keine (kann nach ROH starten)
- Dependencies Abbau: ["DACH", "ZIMM", "FEN", "FASS"]

**ELEKTRO (ELEKT):**
Rohinstallation:
- Bis 20 Positionen: 2-3 Tage
- 21-40 Positionen: 4-5 Tage
- 41-60 Positionen: 6-7 Tage
- >60 Positionen: 8-10 Tage

Feininstallation:
- 50% der Rohinstallation + 1 Tag
- Bei Smart Home: +1-2 Tage
- Bei KNX/komplexer Steuerung: +2-3 Tage

**SANITÄR (SAN):**
Rohinstallation:
- 1 Bad: 3-4 Tage
- 2 Bäder: 5-6 Tage
- 3+ Bäder: 7-10 Tage
- Küche zusätzlich: +2-3 Tage

Feininstallation:
- Pro Bad: 1-2 Tage
- Pro Küche: 1 Tag

**HEIZUNG (HEI):**
- Heizkörper-Tausch: 0,5 Tag pro Heizkörper
- Fußbodenheizung: 2-3 Tage pro 50m²
- Heizungsanlage neu: 3-5 Tage
- Hydraulischer Abgleich: 1 Tag

**TROCKENBAU (TRO):**
- Ständerwerk: 1 Tag pro 20m²
- Beplankung: 1 Tag pro 30m²
- Spachtelung: 2-3 Tage (Trocknungszeiten!)
- Abhangdecke: 1 Tag pro 25m²

**FLIESEN (FLI):**
- Abdichtung: 1 Tag + 1 Tag Trocknung
- Verlegung: 10-15m² pro Tag (Wand schneller als Boden)
- Verfugung: 1 Tag pro 40m²
- Naturstein: -30% Geschwindigkeit

**MALER (MAL):**
- Grundierung: 100m² pro Tag
- 1. Anstrich: 80m² pro Tag
- 2. Anstrich: 100m² pro Tag
- Trocknungszeit zwischen Anstrichen: 1 Tag

**BODEN (BOD):**
- Vorbereitung/Estrich: 2-3 Tage
- Parkett/Laminat: 30-40m² pro Tag
- Vinyl/PVC: 50-60m² pro Tag
- Schleifen/Versiegeln: 2-3 Tage

**DACH (DACH):**
- Dacheindeckung: 50-60m² pro Tag
- Dachfenster: 0,5 Tag pro Fenster
- Dachrinnen: 1 Tag
- Komplettsanierung: mind. 5-10 Tage

**FENSTER (FEN):**
- Einbau: 2-3 Fenster pro Tag
- Bei Altbau/Sanierung: 1-2 pro Tag
- Große Elemente (Terrasse): 1 Tag pro Element

**FASSADE (FASS):**
- Gerüst: 1-2 Tage
- WDVS: 20-30m² pro Tag
- Putz: 35-40m² pro Tag
- Anstrich: 50-80m² pro Tag

**ZIMMEREI (ZIMM):**
- Dachstuhl neu: 5-10 Tage
- Neue Gaube: 3-5 Tage
- Carport: 2-3 Tage
- Balkon: 3-5 Tage

**ABBRUCH (ABBR):**
- Leichte Abbrucharbeiten: 25-40m² pro Tag
- Schwere Abbrucharbeiten: 15-25m² pro Tag
- Entsorgung: +1 Tag pro 10m³

**ESTRICH (ESTR):**
- Verlegung: 50-80m² pro Tag
- Trocknungszeit Zementestrich: 7 Tage pro cm (!)
- Heizestrich: mind. 21 Tage + Aufheizprotokoll
- Schnellestrich: 3-5 Tage

**SCHLOSSER (SCHL):**
- Geländer: 1-2 Tage
- Balkone: 2-3 Tage
- Treppen: 3-5 Tage

**TISCHLER (TIS):**
- Küche Einbau: 2-3 Tage
- Innentüren: 3-4 Türen pro Tag
- Wohnungseingangstüren: 1-2 pro Tag
- Einbauschränke: 1-2 Tage pro Schrank

**PHOTOVOLTAIK (PV):**
- Module Montage: 1 Tag pro 5kWp
- Elektroarbeiten: 1-2 Tage
- Anmeldung/Inbetriebnahme: 1 Tag

**KLIMA (KLIMA):**
- Split-Gerät: 0,5 Tag pro Gerät
- Zentral-Klima: 3-5 Tage

**AUSSEN (AUSS):**
- Pflasterarbeiten: 10-15m² pro Tag
- Zaunbau: 10-15m pro Tag
- Terrasse: 15-20m² pro Tag

## 2. PROJEKTTYP-SPEZIFISCHE FAKTOREN

### NEUBAU:
- Wetterabhängigkeit Rohbau: +10-20% Puffer
- Parallele Gewerke möglich
- Standard-Puffer ausreichend
- Estrich-Trocknungszeiten kritisch!

### SANIERUNG:
- Altbau-Überraschungen: +20-30% Puffer
- Weniger Parallelbetrieb möglich
- Abbruch oft länger als geplant
- Koordination kritischer

### KERNSANIERUNG:
- Abbruch: +40% Puffer
- Rohbau: +30% Puffer  
- Schadstoffentsorgung einplanen
- Bausubstanz-Risiken hoch

### ANBAU/ERWEITERUNG:
- Anschluss an Bestand: +2-3 Tage
- Koordination laufender Betrieb
- Wetter-Risiko bei Öffnungen

## 3. ABHÄNGIGKEITEN & GEWERK-REIHENFOLGE

**ZWINGENDE DEPENDENCIES (IMMER SETZEN!):**

   // GEBÄUDEHÜLLE (sequentiell)
   - ABBR → ROH (falls Abbruch nötig)
   - ROH → ZIMM
   - ZIMM → DACH
   - DACH → FEN (FEN kann während DACH starten, braucht aber Referenz)
   - FEN → FASS
   - [DACH, ZIMM, FEN, FASS] → GER Phase 2 (Abbau)
   
   // ROHINSTALLATIONEN (parallel möglich, aber alle brauchen ROH)
   - ROH → ELEKT-Roh
   - ROH → SAN-Roh
   - ROH → HEI-Roh
   
   // WANDSCHLIESSUNG (braucht alle Rohinstallationen)
   - [ELEKT-Roh, SAN-Roh, HEI-Roh] → TRO
   - [ELEKT-Roh, SAN-Roh, HEI-Roh] → ESTR
   
   // MALERARBEITEN (nach Wandschliessung)
   - TRO → MAL
   - ESTR → MAL
   
   // FEININSTALLATIONEN (nach Malerarbeiten)
   - MAL → ELEKT-Fein
   - MAL → HEI-Fein
   - [MAL, FLI] → SAN-Fein (in Nassbereichen)
   
   // BODENBELÄGE
   - MAL → BOD
   - ESTR → BOD (falls Estrich vorhanden)
   - FLI-Abdichtung → FLI-Verlegung → FLI-Verfugung
   
   // TISCHLEREI (ganz am Schluss)
   - MAL → TIS-Zargen
   - [MAL, BOD] → TIS-Türen
   - [ELEKT-Fein, SAN-Fein, FLI] → TIS-Küche
   
   // AUSSENANLAGEN (nach Gebäudehülle fertig)
   - [DACH, FEN, FASS] → AUSS
   
### ZWINGENDE ABFOLGEN:

1. **VORBEREITUNGSPHASE:**
   - ABBR (falls nötig) → ROH möglich
   - Keine parallelen Gewerke

2. **ROHBAUPHASE:**
   - ROH immer zuerst oder nach ABBR (falls nötig)
   - ROH abgeschlossen → ZIMM/DACH/FEN möglich
   - **WICHTIG: ROH Wanddurchbrüche/kleinere Rohbauarbeiten im Bestand (<5k€) → können parallel laufen!**
     - Setze: is_minor_work: true
     - Setze: can_parallel_with: ["DACH", "FEN", "FASS", "MAL", "TRO"]

3. **GERÜST/ZIMMERER/DACH/FENSTER/FASSADE (Gebäudehülle) - STRIKTE REIHENFOLGE:**
   - Gerüstaufbau GER Phase 1 immer zuerst
   - ZIMM MUSS IMMER VOR DACH kommen!** Dachstuhl/Gauben müssen stehen bevor Dach gedeckt wird
   - ZIMM NIEMALS parallel zu DACH!** Erst wenn ZIMM komplett fertig, dann DACH
   - DACH startet 1 Tag nach ZIMM-Ende
   - FEN startet wenn DACH zu 60% fertig ist (kann leicht überschneidend laufen)
   - FEN MUSS 100% fertig sein bevor FASS startet! (WDVS braucht fertige Fenster)
   - FASS startet 1 Tag nach FEN-Ende
   - Gerüstabbau GER Phase 2 erst nach DACH + ZIMM + FEN + FASS komplett fertig

   **NIEMALS:**
   - ROH ohne ABBR in dependencies ❌ (falls ABBR vorhanden)
   - ZIMM ohne ROH in dependencies ❌
   - DACH vor ZIMM ❌
   - DACH parallel zu ZIMM ❌
   - DACH ohne ZIMM in dependencies ❌
   - FASS vor FEN ❌
   - FASS parallel zu FEN ❌
   - FASS ohne FEN in dependencies ❌
   - FASS ohne DACH in dependencies ❌
   - GER Phase 2 (Abbau) ohne DACH, ZIMM, FEN, FASS in dependencies ❌
   
   // MEHRSTUFIGE GEWERKE
   - Phase 2 ohne Phase 1 desselben Gewerks ❌
   - Phase 3 ohne Phase 2 desselben Gewerks ❌
   - Feininstallation ohne Rohinstallation ❌
   
4. **ROHINSTALLATIONEN (PARALLEL MÖGLICH):**
   - Abschluss dichte Gebäudehülle → Start Innenausbau, zuerst Rohinstallationen
   - ELEKT Rohinstallation
   - SAN Rohinstallation  
   - HEI Rohinstallation
   - Alle BEVOR Trockenbau/Putz!

5. **ESTRICH & TROCKNUNG:**
   - Nach allen Rohinstallationen
   - VOR Feininstallationen
   - KRITISCHER PFAD: Trocknungszeit!

6. **PUTZ/TROCKENBAU:**
   - TRO nach Rohinstallationen
   - Spachtelung braucht Trocknungszeit
   - Dann erst MAL möglich

7. **FEININSTALLATIONEN:**
   - ELEKT Feininstallation (Schalter, Steckdosen)
   - SAN Feininstallation (Armaturen, WCs)
   - HEI Feininstallation (Heizkörper)
   - FEN (falls nicht schon früher)

8. **BODEN & FLIESEN:**
   - FLI (Bäder/Küche)
   - BOD (Wohnräume)
   - Nach Malerarbeiten!

9. **ABSCHLUSSPHASE:**
   - TIS (Küche, Türen)
   - Restarbeiten aller Gewerke
   - Endreinigung

KRITISCHE LOGIK-REGELN:
1. Gerüst MUSS während der gesamten Dach-und Fassadenarbeiten stehen bleiben
2. Gerüstabbau ERST NACH allen Arbeiten die Gerüst benötigen (DACH, FASS mit Gerüst)
3. NIEMALS Gerüst abbauen bevor DACH und FASS fertig ist

### PARALLELISIERUNG (wo möglich):
- Gebäudehülle DACH und FEN (teilweise überschneidend möglich) 
- Rohinstallationen ELEKT + SAN + HEI
- Feininstallationen teilweise parallel
- Boden + Fliesen in verschiedenen Räumen
- AUSSEN-Arbeiten parallel zum Innenausbau

## 3A. KRITISCHE GEWERKESCHNITTSTELLEN (ABSOLUT ZWINGEND!)

**GERÜSTBAU (GER) - NUR 2 PHASEN:**
- **Aufbau:** 1-2 Tage
  - <250m² Fassade: 1 Tag
  - >250m² Fassade: 2 Tage
  - Muss VOR allen Außenarbeiten erfolgen
  - Dependencies: [] (kann nach ROH starten)

- **Abbau:** 0,5-1 Tag  
  - Muss NACH allen Außenarbeiten erfolgen
  - Dependencies: ["DACH", "FEN", "FASS", "ZIMM"]
  - Frühester Start: 1 Tag nach letzter Außenarbeit

**ZIMMERER VOR DACH (ABSOLUT ZWINGEND!):**
- ZIMM muss IMMER komplett fertig sein bevor DACH startet
- Dachstuhl/Gauben/Verstärkungen müssen stehen
- Dann erst Dacheindeckung möglich
- Dependencies: ZIMM → DACH (niemals parallel!), letzte ZIMM-Phase → DACH Phase 1
- Zeitversatz: DACH startet 1 Tag nach LETZTER ZIMM-Phase

**🔴 FASSADE & FENSTER (EXTREM WICHTIG!):**
- FEN muss IMMER VOR FASS kommen!
- Bei WDVS-Fassade: Fenster MÜSSEN bereits eingebaut sein
- WDVS-Platten werden an eingebauten Fenstern angeschlossen
- Fensterbank muss unter WDVS verlaufen
- Anputzleisten werden am Fensterrahmen befestigt
- Dependencies: FEN → FASS (niemals umgekehrt!)

**ROHINSTALLATIONEN VOR WANDSCHLIESSUNG:**
- ELEKT-Roh, SAN-Roh, HEI-Roh müssen ALLE komplett fertig sein
- Erst dann TRO/Putz möglich
- Erst dann ESTR möglich
- Nach Wandschließung sind Nacharbeiten extrem teuer
- Dependencies: ELEKT-Roh, SAN-Roh, HEI-Roh → TRO/ESTR

**FEININSTALLATIONEN NACH MALERARBEITEN:**
- MAL muss komplett fertig sein (beide Anstriche)
- Dann erst ELEKT-Fein (Schalter/Steckdosen)
- Dann erst SAN-Fein (Armaturen/WC)
- Dann erst HEI-Fein (Heizkörper)
- Grund: Farbspritzer auf neuen Armaturen = Katastrophe
- Dependencies: MAL → ELEKT-Fein, SAN-Fein, HEI-Fein

**FLIESEN VOR SANITÄROBJEKTEN:**
- FLI muss komplett fertig sein (Verlegung + Verfugung)
- Dann erst SAN-Fein (WC, Waschbecken, Duschen montieren)
- Sanitärobjekte werden AUF Fliesen montiert
- Dependencies: FLI → SAN-Fein

**BODENBELAG NACH MALERARBEITEN:**
- MAL muss komplett fertig sein (beide Anstriche)
- Dann erst BOD verlegen
- Dann erst TIS Sockelleisten
- Grund: Farbspritzer auf neuem Boden = sehr teuer
- Dependencies: MAL → BOD → TIS-Sockelleisten

**ESTRICH-TROCKNUNG NICHT VERHANDELBAR:**
- Heizestrich: Mind. 21 Tage + 10-14 Tage Aufheizprotokoll
- Zementestrich: 7 Tage pro cm Dicke (bei 5cm = 35 Tage!)
- Dann erst BOD möglich
- KEINE Abkürzungen möglich - sonst Schäden!
- Dependencies: ESTR → WARTEN (21-35 Tage) → BOD

**FUSSBODENHEIZUNG SPEZIAL:**
- HEI Rohre verlegen und unter Druck setzen
- HEI Drucktest (Rohre bleiben unter Druck!)
- ESTR Heizestrich verlegen (Rohre unter Druck)
- Trocknungszeit 21 Tage
- Aufheizprotokoll 10-14 Tage
- Erst dann BOD verlegen
- Dependencies: HEI-Roh → ESTR → Trocknung → Aufheizen → BOD

**KÜCHE GANZ AM SCHLUSS:**
- ELEKT-Fein, SAN-Fein, FLI alle fertig
- Dann erst TIS Küche einbauen
- Dann erst Geräteanschlüsse (Herd, Geschirrspüler)
- Dependencies: ELEKT-Fein, SAN-Fein, FLI → TIS-Küche → Anschlüsse

**TISCHLER MEHRFACH-EINSÄTZE:**
- TIS Zargen einbauen (für Türhöhen)
- Dann MAL + BOD
- Dann TIS Türen einhängen
- Dann TIS Sockelleisten montieren
- Dependencies: TIS-Zargen → MAL/BOD → TIS-Türen → TIS-Sockelleisten

**MEHRFACH-EINSÄTZE IMMER BEACHTEN:**
- ELEKT: Roh → [TRO/MAL] → Fein (2 Phasen zwingend!)
- SAN: Roh → [FLI] → Fein (2 Phasen zwingend!)
- HEI: Roh → [ESTR/MAL] → Fein (2 Phasen zwingend!)
- TIS: Zargen → [MAL/BOD] → Türen → Sockelleisten (4 Phasen!)

## 4. PUFFER-STRATEGIE

### GEWERK-SPEZIFISCHE PUFFER:

**KRITISCH (3-5 Tage):**
- DACH (Wetter + Komplexität)
- ROH bei Sanierung (Überraschungen)
- ESTR (Trocknungszeit-Risiko)
- FASS mit WDVS (Wetter)

**WICHTIG (2-3 Tage):**
- ELEKT (Koordination)
- SAN (Koordination)
- HEI (Koordination)
- TRO (Trocknungszeiten)
- FLI (Präzisionsarbeit)
- ZIMM (Wetter bei Außenarbeiten)

**STANDARD (1-2 Tage):**
- TIS (Maßarbeit)
- FEN (Anschlüsse)
- SCHL (Maßarbeit)
- PV (Wetter)

**MINIMAL (0-1 Tage):**
- MAL (flexibel)
- BOD (flexibel)
- Kleingewerke

### PUFFER-PLATZIERUNG:
- NACH kritischen Gewerken
- VOR Meilensteinen
- NICHT gleichmäßig verteilen
- Bei wetterabhängigen Gewerken

## 5. RISIKEN & BESONDERHEITEN

### WITTERUNGSABHÄNGIGKEIT:
- DACH: Nur bei trockenem Wetter
- FASS: Temp >5°C, kein Regen
- AUSSEN: Temp >3°C für Beton
- ROH: Frost-Risiko im Winter

### TROCKNUNGSZEITEN (NICHT VERHANDELBAR):
- Estrich Zement: 7 Tage/cm
- Heizestrich: 21+ Tage + Aufheizen
- TRO Spachtel: 2-3 Tage
- FLI Abdichtung: 1 Tag
- MAL zwischen Anstrichen: 1 Tag

### KOORDINATIONS-RISIKEN:
- ELEKT + SAN + HEI: Leitungsführung abstimmen
- TRO + ELEKT: Durchbrüche koordinieren
- FLI + SAN: Anschlüsse exakt planen
- BOD + TIS: Sockelleisten-Anschluss

### VERFÜGBARKEITS-RISIKEN:
- Materiallieferzeiten einplanen
- Sonderanfertigungen: +2-4 Wochen
- Fenster: 4-8 Wochen Lieferzeit
- Türen: 3-6 Wochen
- Küchen: 6-12 Wochen

## 6. QUALITÄTSSICHERUNG DER PLANUNG

### PLAUSIBILITÄTSCHECKS:

1. **Gesamt-Dauer plausibel?**
   - EFH-Bad-Sanierung: 3-6 Wochen
   - EFH-Komplett-Sanierung: 6-8 Monate
   - Neubau EFH: 16-18 Monate

2. **Trocknungszeiten berücksichtigt?**
   - Estrich ist IMMER kritischer Pfad!
   - Spachtelarbeiten brauchen Zeit
   - Nicht zu optimistisch!

3. **Abhängigkeiten korrekt?**
   - Keine Feininstallation vor Putz/TRO
   - Kein Boden vor Malerarbeiten
   - Keine Innenarbeiten vor dichtem Dach

4. **Gerüst korrekt strukturiert?**
   - Genau 2 Phasen (Aufbau, Abbau)?
   - Abbau erst nach letzter Außenarbeit (DACH, ZIMM, FEN, FASS) ?
   
5. **Puffer sinnvoll platziert?**
   - Nach ESTR (Trocknungs-Risiko)
   - Nach DACH (Wetter-Risiko)
   - Nach ROH bei Sanierung

6. **Parallelisierung realistisch?**
   - Nicht zu viele Gewerke gleichzeitig
   - Räumliche Trennung möglich?
   - Bauherr kann das koordinieren?

## 7. KOMMUNIKATION MIT BAUHERRN

### ERKLÄRUNGEN MÜSSEN:
- Verständlich für Laien sein
- Konkrete LV-Bezüge haben
- Risiken transparent benennen
- Zeitreserven begründen

### BEISPIEL GUTE ERKLÄRUNG:
"Die Elektro-Rohinstallation dauert 4 Tage, weil laut Leistungsverzeichnis 45 Positionen verbaut werden müssen, darunter 38 Steckdosen, 24 Schalter und 12 Leuchtenanschlüsse. Die Leitungen müssen vor dem Verputzen verlegt werden. Wir haben 2 Tage Puffer eingeplant, da die Abstimmung mit dem Sanitär-Gewerk (zeitgleiche Rohinstallation) erfahrungsgemäß Verzögerungen verursachen kann."

### BEISPIEL SCHLECHTE ERKLÄRUNG:
"Elektro dauert halt so lange. Standard-Dauer laut Datenbank."

UMFANGS-BEWERTUNG BASIEREND AUF LV-DATEN:
- Anzahl Positionen: Wenige (<20) = kurz, Viele (>50) = lang
- Gesamtsumme: <10.000€ = 1-2 Tage, 10-30k€ = 3-5 Tage, >30k€ = 5-10+ Tage
- Komplexe Positionen (hohe Menge/Preis): +20-50% Zeit
- Beispiel: 80 Steckdosen = 2 Tage, 15 Steckdosen = 1 Tag

DAUER-BERECHNUNG PRO GEWERK:
1. Basis: typical_duration_days aus Standard-Phasen
2. Skalierung nach LV-Umfang:
   - Kleine Projekte (<10k€): Basis × 0.6-0.8
   - Mittlere Projekte (10-30k€): Basis × 0.8-1.2
   - Große Projekte (>30k€): Basis × 1.2-2.0
3. Komplexitäts-Faktor: +10-30% bei vielen komplexen Positionen
4. Mehrfach-Einsätze: Aufteilen nach Phasen

BEISPIEL ELEKTRO (LV: 35 Positionen, 18.000€):
- Rohinstallation: 3 Tage Basis × 1.1 (mittlerer Umfang) = 3 Tage
- Feininstallation: 2 Tage Basis × 1.1 = 2 Tage
- Puffer: 2 Tage (kritisches Gewerk)

BEISPIEL GERÜST (bei Fassadensanierung):
- Fassadenfläche: 120m² WDVS, Putz, Anstrich
- Phase 1 Aufbau: 1 Tag (<250m²)
- Phase 3 Abbau: 1 Tag

PROJEKTTYP-SPEZIFISCHE PUFFER:
- Sanierung: 20-30% höhere Puffer (unvorhergesehene Probleme häufig)
- Neubau: Standard-Puffer ausreichend
- Kernsanierung: Besonders hohe Puffer bei Abbruch und Rohbau

GEWERK-SPEZIFISCHE KOMPLEXITÄT & PUFFER:
- SEHR KOMPLEX (3-5 Tage Puffer): DACH, ZIMM, ROH, FASS (mit WDVS)
- KOMPLEX (2-3 Tage Puffer): ELEKT, SAN, HEI, TRO, FEN, TIS, PV, KLIMA
- MITTEL (1-2 Tage Puffer): FLI, TIS, ESTR, AUSS, ABBR, SCHL
- EINFACH (0-1 Tage Puffer): MAL, BOD

MEHRFACH-EINSÄTZE:
Bei folgenden Gewerken MÜSSEN mehrere Phasen eingeplant werden:
- ELEKT: Rohinstallation → [andere Gewerke] → Feininstallation
- SAN: Rohinstallation → [TRO, FLI] → Feininstallation  
- HEI: Rohinstallation → [andere Gewerke] → Feininstallation
- TRO: Ständerwerk → Beplankung → Spachtelung (bei größeren Projekten)
- FLI: Abdichtung → Verlegung → Verfugung

WICHTIGE REGELN:
1. IMMER die LV-Mengen für realistische Zeitschätzung nutzen
2. Schnittstellen beachten
3. Realistische Arbeitstage (nur Mo-Fr, keine Feiertage)
4. Klare, verständliche Erklärungen für Laien
5. Puffer NACH kritischen Gewerken
6. Risiken transparent kommunizieren

# WICHTIG: DETAILLIERTE ABER KOMPAKTE PHASEN-AUFTEILUNG

Teile jedes Gewerk in 2-4 sinnvolle HAUPTPHASEN auf, nicht mehr!

**BEISPIELE FÜR RICHTIGE AUFTEILUNG:**

MAL (Malerarbeiten):
❌ FALSCH: "Malerarbeiten komplett" (1 Phase)
✅ RICHTIG: 
  - Phase 1: Spachtel & Grundierung (2-3 Tage)
  - Phase 2: Anstrich Wände & Decken 2x (4-5 Tage)

FLI (Fliesenarbeiten):
❌ FALSCH: "Fliesenarbeiten" (1 Phase)
✅ RICHTIG:
  - Phase 1: Abdichtung & Vorbereitung (1-2 Tage)
  - Phase 2: Verlegung Boden & Wand (4-6 Tage)
  - Phase 3: Verfugung & Reinigung (1-2 Tage)

TRO (Trockenbau):
❌ FALSCH: "Trockenbauarbeiten" (1 Phase)
✅ RICHTIG:
  - Phase 1: Ständerwerk & Beplankung (3-4 Tage)
  - Phase 2: Spachtelung inkl. Trocknung (3-4 Tage)

DACH (Dacharbeiten):
❌ FALSCH: "Dachsanierung komplett" (1 Phase)
✅ RICHTIG:
  - Phase 1: Abriss & Entsorgung (2-3 Tage)
  - Phase 2: Lattung & Dämmung (4-5 Tage)
  - Phase 3: Eindeckung & Dachfenster (6-9 Tage)
  - Phase 4: Dachrinnen & Abschluss (2 Tage)

FASS (Fassadenarbeiten):
❌ FALSCH: "Fassadendämmung" (1 Phase)
✅ RICHTIG:
  - Phase 1: Untergrund & WDVS-Montage (6-8 Tage)
  - Phase 2: Armierung & Grundierung (4-5 Tage)
  - Phase 3: Oberputz & Anstrich (5-7 Tage)

FEN (Fensterarbeiten):
❌ FALSCH: "Fenster einbauen" (1 Phase)
✅ RICHTIG:
  - Phase 1: Ausbau & Vorbereitung (1-2 Tage)
  - Phase 2: Einbau & Abdichtung (4-6 Tage)
  - Phase 3: Fensterbänke & Abschluss (1-2 Tage)

ELEKT (Elektroarbeiten):
❌ FALSCH: "Elektroarbeiten komplett" (1 Phase)
✅ RICHTIG:
  - Phase 1: Rohinstallation (4-6 Tage)
  - Phase 2: Zählerschrank & Verteilung (2-3 Tage)
  - Phase 3: Feininstallation & Prüfung (4-5 Tage)

**WICHTIG:** Die Phasen-Nummerierung muss der LOGISCHEN REIHENFOLGE folgen!
- Phase 1 = ERSTE Arbeit
- Phase 2 = ZWEITE Arbeit  
- Phase 3 = DRITTE Arbeit

NIEMALS:
- Phase 1: Einbau ❌
- Phase 2: Demontage ❌ (falsche Reihenfolge!)

**WICHTIGE REGEL:** 
- 2-4 Phasen pro Gewerk, niemals mehr! 
- Phasen MÜSSEN in logischer Arbeitsreihenfolge nummeriert sein!
- Phase 1 ist IMMER die erste Arbeit, Phase 2 die zweite, usw.

OUTPUT (NUR valides JSON):
{
  "complexity_level": "EINFACH|MITTEL|HOCH|SEHR_HOCH",
  "total_duration_days": <Anzahl Arbeitstage>,
  "estimated_calendar_weeks": <Umrechnung in Kalenderwochen>,
  "critical_path": ["GEWERK1", "GEWERK2"],
  "critical_path_explanation": "Diese Gewerke bestimmen die Mindest-Projektdauer, weil...",
  
  "general_explanation": "2-3 verständliche Sätze für den Bauherrn: Warum dauert es so lange? Was sind die Haupt-Zeitfresser? Konkrete LV-Bezüge nennen.",
  
  "schedule": [
    {
      "trade_code": "ROH",
      "trade_name": "Rohbauarbeiten",
      "lv_reference": {
        "total_positions": 15,
        "total_value": 28500,
        "key_items": ["Mauerwerk 45m²", "Beton 12m³"]
      },
      "phases": [
        {
          "phase_name": "Rohbau",
          "phase_number": 1,
          "duration_days": 8,
          "duration_calculation": "Mittelgroßes Projekt (28.500€), 45m² Mauerwerk = ca. 2 Tage, 12m³ Beton = ca. 3 Tage, Nebenarbeiten 3 Tage",
          "buffer_days": 3,
          "buffer_reason": "Sanierungsprojekt: Altbau-Überraschungen sind wahrscheinlich. Bei unerwarteten Schäden kann Mehraufwand entstehen.",
          "sequence_order": 1,
          "dependencies": [],
          "can_parallel_with": [],
          "is_standzeit": false,
          "is_minor_work": false,
          "scheduling_reason": "Rohbau ist Grundlage für alle Folgetermine. Muss abgeschlossen sein, bevor Gewerke beginnen können.",
          "risks": "Bei tragenden Wänden können statische Probleme auftreten. Feuchte Wände verlängern Trocknungszeit.",
          "weather_dependent": false,
          "material_lead_time": "Beton: 1 Woche Vorlauf"
        }
      ]
    }
  ],
  
  "warnings": [
    "Estrich-Trocknungszeit von 21 Tagen ist nicht verhandelbar - frühere Begehung führt zu Schäden",
    "Bei Verzögerung im Rohbau verschieben sich ALLE Folgetermine um dieselbe Dauer"
  ],
  
  "recommendations": [
    "Fenster sollten JETZT bestellt werden (8 Wochen Lieferzeit)",
    "Küche frühzeitig aussuchen (12 Wochen Lieferzeit)",
    "Materialbestellung für Elektro 2 Wochen vor Beginn"
  ],
  
  "project_specific_notes": "Bei diesem Sanierungsprojekt ist mit unvorhergesehenen Problemen zu rechnen. Die eingeplanten Puffer sind realistisch und sollten nicht gekürzt werden."
}

## 9. WICHTIGE QUALITÄTSKRITERIEN

✓ Alle Dauern sind durch LV-Positionen begründet
✓ Trocknungszeiten sind berücksichtigt
✓ Abhängigkeiten sind technisch korrekt
✓ Puffer sind sinnvoll platziert und begründet
✓ Erklärungen sind für Laien verständlich
✓ Risiken sind transparent benannt
✓ Lieferzeiten sind berücksichtigt
✓ Wetterabhängigkeiten sind markiert
✓ Kritischer Pfad ist korrekt identifiziert
✓ Gesamtdauer ist plausibel für Projekttyp
✓ **is_minor_work: true ist bei kleinen Rohbauarbeiten (<5k€) gesetzt**

NUR valides JSON ausgeben - keine zusätzlichen Texte oder Markdown!`;

    // User-Prompt
    const userPrompt = `Erstelle einen Bauablaufplan für folgendes Projekt:

PROJEKT:
Kategorie: ${project.category || 'Sanierung'}
Unterkategorie: ${project.sub_category || ''}
Beschreibung: ${project.description || 'Keine detaillierte Beschreibung'}
Ort: ${project.zip_code} ${project.city}

VORGABE:
${schedule.input_type === 'start_date' 
  ? `Gewünschter STARTTERMIN: ${schedule.target_start_date}
     WICHTIG: Plane VORWÄRTS ab diesem Datum. Erstes Gewerk startet an diesem Termin.`
  : `Gewünschter FERTIGSTELLUNGSTERMIN: ${schedule.target_completion_date}
     WICHTIG: Plane RÜCKWÄRTS! Letztes Gewerk muss an diesem Datum fertig sein. Berechne wie viele Tage vorher der Start sein muss.`
}

BETEILIGTE GEWERKE:
${project.trades.map(t => `- ${t.code}: ${t.name}`).join('\n')}

VERFÜGBARE STANDARD-PHASEN:
${Object.entries(tradePhases).map(([code, phases]) => 
  `${code}: ${phases.map(p => `${p.phase_name} (Basis: ${p.typical_duration_days}d)`).join(', ')}`
).join('\n')}

${intakeAnswers.length > 0 ? `
PROJEKT-KONTEXT AUS INTAKE:
${intakeAnswers.map(a => `- ${a.question}: ${a.answer}`).join('\n')}
` : ''}

LEISTUNGSVERZEICHNISSE (DETAILLIERTE ANALYSE):
Gesamtprojektwert: ${totalProjectValue.toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}

${Object.entries(lvsByTrade).map(([code, lv]) => `
${code} - ${lv.trade_name}:
  • Auftragssumme: ${lv.total_sum.toLocaleString('de-DE', {style: 'currency', currency: 'EUR'})}
  • Anzahl Positionen: ${lv.total_positions}
  • Komplexität: ${lv.has_complex_positions ? 'HOCH (große Mengen/teure Positionen)' : 'NORMAL'}
  
Alle Positionen:
${lv.position_summary.map(pos => 
  `    - ${pos.title}: ${pos.quantity} ${pos.unit}${pos.description ? ` (${pos.description})` : ''}`
).join('\n')}
`).join('\n')}

WICHTIG: 
- Nutze die LV-Daten für REALISTISCHE Zeitschätzungen
- Passe die Standard-Dauern an den tatsächlichen Umfang an
- Erkläre dem Bauherrn transparent, warum welches Gewerk wie lange dauert
- Berücksichtige die Auftragssummen: Höhere Summe = mehr Arbeitsaufwand
- Setze bei kleinen Rohbauarbeiten (<5k€) is_minor_work: true und can_parallel_with**

Erstelle einen realistischen, professionellen Bauablaufplan mit klaren Erklärungen basierend auf den tatsächlichen Leistungsmengen.`;

    // KI-Call
    const anthropic = new Anthropic({
      apiKey: process.env.ANTHROPIC_API_KEY
    });
    
    console.log('[SCHEDULE-GEN] Calling Claude API...');
    
    const response = await anthropic.messages.create({
      model: 'claude-sonnet-4-5-20250929',
      max_tokens: 16000,
      temperature: 0.3,
      system: systemPrompt,
      messages: [{ role: 'user', content: userPrompt }]
    });
    
    // Parse Response
    let scheduleData;
    try {
      let responseText = response.content[0].text.trim();
      responseText = responseText
        .replace(/^```json\s*\n?/, '')
        .replace(/^```\s*\n?/, '')
        .replace(/\n?```\s*$/, '')
        .trim();
      
      scheduleData = JSON.parse(responseText);
      
    } catch (parseError) {
      console.error('[SCHEDULE-GEN] Parse error:', parseError);
      return res.status(500).json({ 
        error: 'Fehler beim Parsen der KI-Antwort',
        details: parseError.message 
      });
    }

    console.log('[DEBUG] Schedule data:', {
  input_type: schedule.input_type,
  target_start_date: schedule.target_start_date,
  target_completion_date: schedule.target_completion_date
});
    
    // Start-Datum für Terminplanung
const currentDate = new Date(schedule.target_start_date);
    
    // Speichere Schedule Entries
await query('BEGIN');

try {
  // 1. SAMMLE ALLE EINTRÄGE MIT METADATEN
  const allEntries = [];
  
  for (const trade of scheduleData.schedule) {
    const tradeInfo = project.trades.find(t => t.code === trade.trade_code);
    if (!tradeInfo) continue;
    
    for (const phase of trade.phases) {
      allEntries.push({
        trade_code: trade.trade_code,
        trade_id: tradeInfo.id,
        trade_name: tradeInfo.name,
        phase: phase,
        dependencies: phase.dependencies || [],
        can_parallel_with: phase.can_parallel_with || [],
        is_minor_work: phase.is_minor_work || false // NEU
      });
    }
  }
  
  // 2. BERECHNE TERMINE MIT INTELLIGENTER PARALLELITÄTS-LOGIK
  const scheduledEntries = [];
  let currentSequenceDate = new Date(currentDate);
  const processedIndices = new Set();

// ================================================================
// PHASE 1: Minor Works werden später parallel eingeplant
// ================================================================
for (let i = 0; i < allEntries.length; i++) {
  if (processedIndices.has(i)) continue;
  
  const entry = allEntries[i];
  const phase = entry.phase;
  
  // SKIP: Minor Works werden später parallel eingeplant
// AUSNAHME: Wenn Gewerk mehrere Phasen hat, dann sequentiell!
const tradePhaseCount = allEntries.filter(e => e.trade_code === entry.trade_code).length;

if (entry.is_minor_work && tradePhaseCount === 1) {
  // Nur einzelne Minor Works werden parallel eingeplant
  console.log(`[SKIP-FOR-LATER] ${entry.trade_code} (Single-Phase Minor Work)`);
  continue;
}

// Multi-Phasen-Gewerke sind immer sequentiell (auch wenn Minor Work dabei ist)
  
  // Prüfe Dependencies
const allDependenciesMet = entry.dependencies.every(dep => {
  if (typeof dep === 'string' && dep.includes('-')) {
    const [tradeDep, phaseDep] = dep.split('-');
    return scheduledEntries.some(s => 
      s.trade_code === tradeDep && 
      s.phase.phase_name?.toLowerCase().includes(phaseDep.toLowerCase())
    );
  }
  return scheduledEntries.some(s => s.trade_code === dep);
});

if (!allDependenciesMet && entry.dependencies.length > 0) {
  continue;
}

    // WICHTIG: Phasen des gleichen Gewerks NIEMALS parallel!
const sameTradeEntries = scheduledEntries.filter(s => 
  s.trade_code === entry.trade_code && 
  s.phase.phase_number < phase.phase_number
);

if (sameTradeEntries.length > 0) {
  // Vorherige Phase des gleichen Gewerks muss fertig sein
  const previousPhase = sameTradeEntries[sameTradeEntries.length - 1];
  const nextStart = addWorkdays(new Date(previousPhase.endDate), 1);
  
  scheduledEntries.push({
    ...entry,
    startDate: nextStart.toISOString().split('T')[0],
    endDate: addWorkdays(nextStart, phase.duration_days - 1).toISOString().split('T')[0],
    isParallel: false
  });
  processedIndices.add(i);
  console.log(`[SAME-TRADE-SEQUENTIAL] ${entry.trade_code} Phase ${phase.phase_number} nach Phase ${previousPhase.phase.phase_number}`);
  continue;
}

// SPEZIAL-REGEL: FASS Phase 1 muss warten bis DACH UND FEN 100% FERTIG sind!
// (Andere FASS-Phasen werden oben durch same-trade-check behandelt)
if (entry.trade_code === 'FASS' && phase.phase_number === 1) {
  const fenEntries = scheduledEntries.filter(s => s.trade_code === 'FEN');
  const allFenPhases = allEntries.filter(e => e.trade_code === 'FEN');
  
  const dachEntries = scheduledEntries.filter(s => s.trade_code === 'DACH');
  const allDachPhases = allEntries.filter(e => e.trade_code === 'DACH');
  
  // FASS wartet bis ALLE FEN-Phasen eingeplant sind
  if (fenEntries.length < allFenPhases.length) {
    console.log(`[WAITING] FASS Phase 1 wartet auf alle FEN-Phasen (${fenEntries.length}/${allFenPhases.length})`);
    continue;
  }
  
  // FASS wartet bis ALLE DACH-Phasen eingeplant sind
  if (dachEntries.length < allDachPhases.length) {
    console.log(`[WAITING] FASS Phase 1 wartet auf alle DACH-Phasen (${dachEntries.length}/${allDachPhases.length})`);
    continue;
  }
  
  // FASS startet 1 Tag NACH der SPÄTEREN von DACH/FEN
  const lastFenEntry = fenEntries.reduce((latest, curr) => 
    new Date(curr.endDate) > new Date(latest.endDate) ? curr : latest
  );
  const lastDachEntry = dachEntries.reduce((latest, curr) => 
    new Date(curr.endDate) > new Date(latest.endDate) ? curr : latest
  );
  
  const lastEndDate = new Date(lastFenEntry.endDate) > new Date(lastDachEntry.endDate) 
    ? lastFenEntry.endDate 
    : lastDachEntry.endDate;
  
  const fassStart = addWorkdays(new Date(lastEndDate), 1);
  
  scheduledEntries.push({
    ...entry,
    startDate: fassStart.toISOString().split('T')[0],
    endDate: addWorkdays(fassStart, phase.duration_days - 1).toISOString().split('T')[0],
    isParallel: false
  });
  processedIndices.add(i);
  console.log(`[SEQUENTIAL] FASS Phase 1 startet NACH DACH und FEN`);
  continue;
}
  
// ================================================================
// FALL 1: EXPLIZITE can_parallel_with (aus LLM)
// ================================================================
if (entry.can_parallel_with.length > 0) {
  const parallelTrades = entry.can_parallel_with;
  const parallelEntries = scheduledEntries.filter(s => 
    parallelTrades.includes(s.trade_code)
  );
  
  if (parallelEntries.length > 0) {
    const referenceEntry = parallelEntries[0];
    scheduledEntries.push({
      ...entry,
      startDate: referenceEntry.startDate,
      endDate: addWorkdays(new Date(referenceEntry.startDate), phase.duration_days - 1).toISOString().split('T')[0],
      isParallel: true,
      parallelTo: parallelTrades
    });
    processedIndices.add(i);
    console.log(`[PARALLEL-EXPLICIT] ${entry.trade_code} Phase ${phase.phase_number} läuft parallel zu ${parallelTrades.join(', ')}`);
    continue;
  }
}
    
    // ================================================================
    // FALL 2: IMPLIZITE PARALLELITÄTEN (nach Prompt-Regeln)
    // ================================================================
    
    const isRohinstallation = phase.phase_name?.toLowerCase().includes('rohinstallation');
    const isFeininstallation = phase.phase_name?.toLowerCase().includes('feininstallation');
    
    // 2A. ROHINSTALLATIONEN PARALLEL (ELEKT + SAN + HEI)
    if (isRohinstallation && ['ELEKT', 'SAN', 'HEI'].includes(entry.trade_code)) {
      const otherRohinstallations = scheduledEntries.filter(s => 
        s.phase.phase_name?.toLowerCase().includes('rohinstallation') &&
        ['ELEKT', 'SAN', 'HEI'].includes(s.trade_code) &&
        !s.isParallel
      );
      
      if (otherRohinstallations.length > 0) {
        const refEntry = otherRohinstallations[0];
        scheduledEntries.push({
          ...entry,
          startDate: refEntry.startDate,
          endDate: addWorkdays(new Date(refEntry.startDate), phase.duration_days - 1).toISOString().split('T')[0],
          isParallel: true,
          parallelTo: ['Rohinstallationen']
        });
        processedIndices.add(i);
        console.log(`[PARALLEL-IMPLICIT] ${entry.trade_code} Rohinstallation läuft parallel`);
        continue;
      }
    }
    
    // 2B. FEININSTALLATIONEN PARALLEL (ELEKT + SAN + HEI)
    if (isFeininstallation && ['ELEKT', 'SAN', 'HEI'].includes(entry.trade_code)) {
      const otherFeininstallations = scheduledEntries.filter(s => 
        s.phase.phase_name?.toLowerCase().includes('feininstallation') &&
        ['ELEKT', 'SAN', 'HEI'].includes(s.trade_code)
      );
      
      if (otherFeininstallations.length > 0) {
        const refEntry = otherFeininstallations[0];
        scheduledEntries.push({
          ...entry,
          startDate: refEntry.startDate,
          endDate: addWorkdays(new Date(refEntry.startDate), phase.duration_days - 1).toISOString().split('T')[0],
          isParallel: true,
          parallelTo: ['Feininstallationen']
        });
        processedIndices.add(i);
        console.log(`[PARALLEL-IMPLICIT] ${entry.trade_code} Feininstallation läuft parallel`);
        continue;
      }
    }
    
    // 2C. DACH UND FEN TEILWEISE ÜBERSCHNEIDEND
    if (entry.trade_code === 'FEN') {
      const dachEntries = scheduledEntries.filter(s => s.trade_code === 'DACH');
      
      if (dachEntries.length > 0) {
        const dachEntry = dachEntries[dachEntries.length - 1];
        const dachDuration = dachEntry.phase.duration_days;
        const dachTwoThirds = Math.floor(dachDuration * 0.66);
        
        const fenStart = addWorkdays(new Date(dachEntry.startDate), dachTwoThirds);
        
        scheduledEntries.push({
          ...entry,
          startDate: fenStart.toISOString().split('T')[0],
          endDate: addWorkdays(fenStart, phase.duration_days - 1).toISOString().split('T')[0],
          isParallel: true,
          parallelTo: ['DACH']
        });
        processedIndices.add(i);
        console.log(`[PARALLEL-IMPLICIT] FEN läuft teilweise parallel zu DACH`);
        continue;
      }
    }
    
    // 2D. BODEN + FLIESEN PARALLEL
    if (entry.trade_code === 'BOD') {
      const fliEntries = scheduledEntries.filter(s => 
        s.trade_code === 'FLI' && !s.isParallel
      );
      
      if (fliEntries.length > 0) {
        const fliEntry = fliEntries[fliEntries.length - 1];
        
        scheduledEntries.push({
          ...entry,
          startDate: fliEntry.startDate,
          endDate: addWorkdays(new Date(fliEntry.startDate), phase.duration_days - 1).toISOString().split('T')[0],
          isParallel: true,
          parallelTo: ['FLI']
        });
        processedIndices.add(i);
        console.log(`[PARALLEL-IMPLICIT] BOD läuft parallel zu FLI`);
        continue;
      }
    }
    
    // 2E. AUSSENANLAGEN PARALLEL ZU INNENAUSBAU
    if (entry.trade_code === 'AUSS') {
      const innenarbeiten = scheduledEntries.filter(s => 
        ['MAL', 'BOD', 'TIS', 'FLI', 'ELEKT', 'SAN', 'HEI'].includes(s.trade_code) &&
        !s.isParallel
      );
      
      if (innenarbeiten.length > 0) {
        const refEntry = innenarbeiten[0];
        
        scheduledEntries.push({
          ...entry,
          startDate: refEntry.startDate,
          endDate: addWorkdays(new Date(refEntry.startDate), phase.duration_days - 1).toISOString().split('T')[0],
          isParallel: true,
          parallelTo: ['Innenausbau']
        });
        processedIndices.add(i);
        console.log(`[PARALLEL-IMPLICIT] AUSS läuft parallel zu Innenausbau`);
        continue;
      }
    }
  
    // ================================================================
    // FALL 3: SEQUENTIELL
    // ================================================================
    const startDate = new Date(currentSequenceDate);
const endDate = addWorkdays(startDate, phase.duration_days - 1);

scheduledEntries.push({
  ...entry,
  startDate: startDate.toISOString().split('T')[0],
  endDate: endDate.toISOString().split('T')[0],
  isParallel: false
});
processedIndices.add(i);
currentSequenceDate = addWorkdays(endDate, 1); // ← NUR 1 Tag = nahtlos
    
    console.log(`[SEQUENTIAL] ${entry.trade_code} Phase ${phase.phase_number}: ${startDate.toISOString().split('T')[0]}`);
  }
  
// ================================================================
// MINOR WORKS PARALLEL EINPLANEN
// ================================================================
for (let i = 0; i < allEntries.length; i++) {
  if (processedIndices.has(i)) continue;
  
  const entry = allEntries[i];
  const phase = entry.phase;
  
  // 🟡 MINOR WORKS: Kleine Rohbauarbeiten parallel zu anderem
  if (entry.is_minor_work && entry.can_parallel_with.length > 0) {
    const parallelTrades = entry.can_parallel_with;
    const parallelEntries = scheduledEntries.filter(s => 
      parallelTrades.includes(s.trade_code)
    );
    
    if (parallelEntries.length > 0) {
      const referenceEntry = parallelEntries[0];
      scheduledEntries.push({
        ...entry,
        startDate: referenceEntry.startDate,
        endDate: addWorkdays(new Date(referenceEntry.startDate), phase.duration_days - 1).toISOString().split('T')[0],
        isParallel: true,
        parallelTo: parallelTrades,
        is_minor_work: true
      });
      processedIndices.add(i);
      console.log(`[MINOR-WORK-PARALLEL] ${entry.trade_code} läuft parallel zu ${parallelTrades.join(', ')}`);
      continue;
    }
  }
}
  
  // ================================================================
  // PHASE 3: Dependencies noch nicht erfüllt
  // ================================================================
  let maxIterations = 10;
  let iteration = 0;
  
  while (processedIndices.size < allEntries.length && iteration < maxIterations) {
    iteration++;
    
    for (let i = 0; i < allEntries.length; i++) {
      if (processedIndices.has(i)) continue;
      
      const entry = allEntries[i];
      const phase = entry.phase;
      
      const allDependenciesMet = entry.dependencies.every(dep => {
        return scheduledEntries.some(s => {
          if (typeof dep === 'string' && dep.includes('-')) {
            const [tradeDep, phaseDep] = dep.split('-');
            return s.trade_code === tradeDep && s.phase.phase_name?.includes(phaseDep);
          }
          return s.trade_code === dep;
        });
      });
      
      if (!allDependenciesMet) continue;
      
      let latestDepEnd = currentSequenceDate;
      
      entry.dependencies.forEach(dep => {
        const depEntries = scheduledEntries.filter(s => {
          if (typeof dep === 'string' && dep.includes('-')) {
            const [tradeDep, phaseDep] = dep.split('-');
            return s.trade_code === tradeDep && s.phase.phase_name?.includes(phaseDep);
          }
          return s.trade_code === dep;
        });
        
        if (depEntries.length > 0) {
          const latestDep = depEntries.reduce((latest, curr) => {
            return new Date(curr.endDate) > new Date(latest.endDate) ? curr : latest;
          });
          
          const depEndDate = addWorkdays(new Date(latestDep.endDate), 1);
          if (depEndDate > latestDepEnd) {
            latestDepEnd = depEndDate;
          }
        }
      });
      
      const startDate = new Date(latestDepEnd);
      const endDate = addWorkdays(startDate, phase.duration_days - 1);
      
      scheduledEntries.push({
        ...entry,
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        isParallel: false
      });
      processedIndices.add(i);
      
      const thisEnd = addWorkdays(endDate, 1);
if (thisEnd > currentSequenceDate) {
  currentSequenceDate = thisEnd;
}
      
      console.log(`[DEPENDENCY-MET] ${entry.trade_code} Phase ${phase.phase_number}`);
    }
  }

if (processedIndices.size < allEntries.length) {
  console.warn(`[SCHEDULE-WARNING] ${allEntries.length - processedIndices.size} Einträge nicht geplant`);
}

  // ================================================================
  // 4. SPEICHERE IN DATENBANK
  // ================================================================
  for (const entry of scheduledEntries) {
  // ✅ Zähle Phasen pro Trade für is_multi_phase
  const tradePhaseCount = scheduledEntries.filter(e => 
    e.trade_code === entry.trade_code
  ).length;
  
  await query(
    `INSERT INTO schedule_entries 
     (schedule_id, trade_id, phase_name, phase_number,
      planned_start, planned_end, duration_days, buffer_days,
      status, dependencies,
      scheduling_reason, buffer_reason, risks, is_minor_work, is_multi_phase)
     VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)`,
    [
      schedule.id,
      entry.trade_id,
      entry.phase.phase_name,
      entry.phase.phase_number,
      entry.startDate,
      entry.endDate,
      entry.phase.duration_days,
      entry.phase.buffer_days || 0,
      'pending',
      JSON.stringify(entry.dependencies),
      entry.phase.scheduling_reason,
      entry.phase.buffer_reason,
      entry.phase.risks,
      entry.is_minor_work || false,
      tradePhaseCount > 1  
    ]
  );
}
  
  console.log(`[SCHEDULE-SUCCESS] ${scheduledEntries.length} Einträge gespeichert`);
  console.log(`[PARALLEL-COUNT] ${scheduledEntries.filter(e => e.isParallel).length} parallele Phasen`);
  console.log(`[MINOR-WORK-COUNT] ${scheduledEntries.filter(e => e.is_minor_work).length} Minor Work Phasen`);
  
  // Update Schedule mit KI-Daten
  await query(
    `UPDATE project_schedules 
     SET status = 'pending_approval',
         complexity_level = $2,
         total_duration_days = $3,
         critical_path = $4,
         ai_response = $5,
         ai_model_version = $6,
         ai_prompt_used = $7,
         updated_at = NOW()
     WHERE id = $1`,
    [
      schedule.id,
      scheduleData.complexity_level,
      scheduleData.total_duration_days,
      JSON.stringify(scheduleData.critical_path),
      JSON.stringify(scheduleData),
      'claude-sonnet-4-5-20250929',
      systemPrompt
    ]
  );
  
  await query('COMMIT');

  // Validiere und fixe Dependencies
  console.log('[SCHEDULE-GEN] Validating dependencies...');
  try {
    const validationResult = await validateAndFixDependencies(schedule.id);
    
    if (validationResult.issuesFound > 0) {
      console.log('[SCHEDULE-GEN] Dependencies corrected:', validationResult.issuesFound, 'issues fixed');
    } else {
      console.log('[SCHEDULE-GEN] ✅ All dependencies valid');
    }
  } catch (validationErr) {
    console.error('[SCHEDULE-GEN] ⚠️ Dependency validation failed:', validationErr);
    // Nicht abbrechen - Schedule ist bereits gespeichert
  }
  
  // Erstelle Benachrichtigung für Bauherrn
  await query(
    `INSERT INTO notifications (user_type, user_id, type, message, reference_type, reference_id, created_at)
     VALUES ('bauherr', $1, 'schedule_generated', $2, 'schedule', $3, NOW())`,
    [
      project.bauherr_id,
      `Terminplan für Ihr Projekt wurde erstellt und wartet auf Ihre Freigabe`,
      schedule.id
    ]
  );
  
  console.log('[SCHEDULE-GEN] Generation completed successfully');
  runningGenerations.delete(projectId); 
  
  res.json({ 
    success: true, 
    scheduleId: schedule.id,
    scheduleData,
    message: 'Terminplan erfolgreich generiert'
  });
  
} catch (innerErr) {
  await query('ROLLBACK');
  throw innerErr;
}
    
  } catch (err) {
    runningGenerations.delete(projectId);
    console.error('[SCHEDULE-GEN] Generation failed:', err);
    res.status(500).json({ 
      error: 'Fehler bei der Terminplan-Generierung',
      details: err.message 
    });
  }
});

// In-Memory Store für laufende Generierungen
const runningGenerations = new Set();

app.get('/api/projects/:projectId/schedule/generation-status', async (req, res) => {
  try {
    const { projectId } = req.params;
    res.json({ isGenerating: runningGenerations.has(projectId) });
  } catch (err) {
    res.status(500).json({ error: 'Fehler' });
  }
});

// ============================================================================
// 3. TERMINPLAN ABRUFEN (für Bauherr zur Freigabe)
// ============================================================================

app.get('/api/projects/:projectId/schedule', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const scheduleResult = await query(
      `SELECT ps.*,
        json_agg(
          json_build_object(
            'id', se.id,
            'trade_id', se.trade_id,
            'trade_code', t.code,
            'trade_name', t.name,
            'phase_name', se.phase_name,
            'phase_number', se.phase_number,
            'planned_start', se.planned_start,
            'planned_end', se.planned_end,
            'duration_days', se.duration_days,
            'buffer_days', se.buffer_days,
            'confirmed', se.confirmed,
            'confirmed_by', se.confirmed_by,
            'status', se.status,
            'dependencies', se.dependencies,
            'scheduling_reason', se.scheduling_reason,
            'buffer_reason', se.buffer_reason,
            'risks', se.risks
          ) ORDER BY se.planned_start
        ) FILTER (WHERE se.id IS NOT NULL) as entries
       FROM project_schedules ps
       LEFT JOIN (
         -- ✅ Hole nur die neuesten Einträge pro trade/phase
         SELECT DISTINCT ON (schedule_id, trade_id, phase_number) *
         FROM schedule_entries
         ORDER BY schedule_id, trade_id, phase_number, updated_at DESC
       ) se ON ps.id = se.schedule_id
       LEFT JOIN trades t ON se.trade_id = t.id
       WHERE ps.project_id = $1
       GROUP BY ps.id`,
      [projectId]
    );
    
    if (scheduleResult.rows.length === 0) {
      return res.status(404).json({ error: 'Kein Terminplan gefunden' });
    }
    
    res.json(scheduleResult.rows[0]);
    
  } catch (err) {
    console.error('[SCHEDULE] Fetch failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden des Terminplans' });
  }
});

// ============================================================================
// 4. TERMINPLAN FREIGEBEN (Bauherr)
// ============================================================================

app.post('/api/schedules/:scheduleId/approve', async (req, res) => {
  try {
    const { scheduleId } = req.params;
    const { bauherrId, notes, adjustedEntries } = req.body;
    
    await query('BEGIN');
    
    try {
      // Falls Bauherr Termine angepasst hat
if (adjustedEntries && adjustedEntries.length > 0) {
  for (const entry of adjustedEntries) {
    // Berechne planned_end falls nicht vorhanden
    const plannedEnd = entry.planned_end || addWorkdays(
      new Date(entry.planned_start), 
      entry.duration_days - 1
    ).toISOString().split('T')[0];
    
    await query(
      `UPDATE schedule_entries 
       SET planned_start = $2,
           planned_end = $3,
           duration_days = $4,
           updated_at = NOW()
       WHERE id = $1`,
      [
        entry.id,
        entry.planned_start,
        plannedEnd,
        calculateWorkdays(entry.planned_start, plannedEnd)
      ]
    );
    
    // History-Eintrag
    await query(
      `INSERT INTO schedule_history 
       (schedule_entry_id, changed_by_type, changed_by_id, change_type,
        old_start, old_end, new_start, new_end, reason)
       VALUES ($1, 'bauherr', $2, 'date_change', $3, $4, $5, $6, $7)`,
      [
        entry.id,
        bauherrId,
        entry.original_start,
        entry.original_end,
        entry.planned_start,
        plannedEnd,
        'Anpassung durch Bauherr bei Freigabe'
      ]
    );
  }
}
      
      // Schedule auf 'active' setzen
      await query(
        `UPDATE project_schedules 
         SET status = 'active',
             approved_by = $2,
             approved_at = NOW(),
             approval_notes = $3,
             updated_at = NOW()
         WHERE id = $1`,
        [scheduleId, bauherrId, notes]
      );
      
      // Lade alle betroffenen Handwerker für Benachrichtigungen
      const handwerkerResult = await query(
        `SELECT DISTINCT h.id, h.email, h.company_name, t.code, t.name as trade_name
         FROM schedule_entries se
         JOIN trades t ON se.trade_id = t.id
         JOIN tenders tn ON tn.trade_id = t.id
         JOIN offers o ON o.tender_id = tn.id AND o.status = 'preliminary'
         JOIN handwerker h ON o.handwerker_id = h.id
         WHERE se.schedule_id = $1`,
        [scheduleId]
      );
      
      // Erstelle Benachrichtigungen für alle Handwerker in Vertragsanbahnung
      for (const handwerker of handwerkerResult.rows) {
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
           VALUES ('handwerker', $1, 'schedule_active', $2, 'schedule', $3, $4, NOW())`,
          [
            handwerker.id,
            `Terminplan freigegeben - Bitte bestätigen Sie Ihre Einsatzzeiten für ${handwerker.trade_name}`,
            scheduleId,
            JSON.stringify({ trade_code: handwerker.code })
          ]
        );
      }
      
      await query('COMMIT');
      
      res.json({ 
        success: true, 
        message: 'Terminplan freigegeben',
        notifiedHandwerker: handwerkerResult.rows.length
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      throw innerErr;
    }
    
  } catch (err) {
    console.error('[SCHEDULE] Approval failed:', err);
    res.status(500).json({ error: 'Fehler bei der Freigabe' });
  }
});

// ============================================================================
// 5. TERMINE FÜR HANDWERKER ABRUFEN (für HandwerkerOfferConfirmPage)
// ============================================================================

app.get('/api/offers/:offerId/schedule-dates', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    // Hole Trade des Offers
    const offerResult = await query(
      `SELECT o.*, tn.trade_id, tn.project_id
       FROM offers o
       JOIN tenders tn ON o.tender_id = tn.id
       WHERE o.id = $1`,
      [offerId]
    );
    
    if (offerResult.rows.length === 0) {
      return res.status(404).json({ error: 'Angebot nicht gefunden' });
    }
    
    const offer = offerResult.rows[0];
    
    // Prüfe ob Terminplan existiert und freigegeben ist
    const scheduleResult = await query(
      `SELECT ps.id, ps.status, ps.approved_at,
        json_agg(
          json_build_object(
            'id', se.id,
            'phase_name', se.phase_name,
            'phase_number', se.phase_number,
            'planned_start', se.planned_start,
            'planned_end', se.planned_end,
            'duration_days', se.duration_days,
            'buffer_days', se.buffer_days,
            'scheduling_reason', se.scheduling_reason,
            'buffer_reason', se.buffer_reason,
            'is_multi_phase', se.is_multi_phase
          ) ORDER BY se.phase_number
        ) as phases
       FROM project_schedules ps
       JOIN schedule_entries se ON ps.id = se.schedule_id
       WHERE ps.project_id = $1 
         AND se.trade_id = $2
         AND ps.status IN ('active', 'locked')
       GROUP BY ps.id`,
      [offer.project_id, offer.trade_id]
    );
    
    if (scheduleResult.rows.length === 0) {
      return res.json({ 
        hasSchedule: false,
        message: 'Kein Terminplan verfügbar oder noch nicht freigegeben'
      });
    }
    
    res.json({
      hasSchedule: true,
      schedule: scheduleResult.rows[0]
    });
    
  } catch (err) {
    console.error('[SCHEDULE] Fetch dates failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Termine' });
  }
});

// ============================================================================
// 6. TERMINE BESTÄTIGEN/ANPASSEN (Handwerker auf OfferConfirmPage)
// ============================================================================

app.post('/api/schedule-entries/confirm', async (req, res) => {
  try {
    const { entryIds, handwerkerId, adjustments } = req.body;
    
    await query('BEGIN');
    
    try {
      for (const entryId of entryIds) {
        const adjustment = adjustments?.find(a => a.entryId === entryId);
        
        if (adjustment && adjustment.changed) {
          // Handwerker hat Termine angepasst
          await query(
            `UPDATE schedule_entries 
             SET planned_start = $2,
                 planned_end = $3,
                 duration_days = $4,
                 confirmed = false,
                 status = 'change_requested',
                 updated_at = NOW()
             WHERE id = $1`,
            [
              entryId,
              adjustment.new_start,
              adjustment.new_end,
              calculateWorkdays(adjustment.new_start, adjustment.new_end)
            ]
          );
          
          // History
          await query(
            `INSERT INTO schedule_history 
             (schedule_entry_id, changed_by_type, changed_by_id, change_type,
              old_start, old_end, new_start, new_end, reason)
             VALUES ($1, 'handwerker', $2, 'date_change', $3, $4, $5, $6, $7)`,
            [
              entryId,
              handwerkerId,
              adjustment.old_start,
              adjustment.old_end,
              adjustment.new_start,
              adjustment.new_end,
              adjustment.reason || 'Anpassung durch Handwerker'
            ]
          );
          
        } else {
          // Handwerker hat bestätigt ohne Änderung
          await query(
            `UPDATE schedule_entries 
             SET confirmed = true,
                 confirmed_by = $2,
                 confirmed_at = NOW(),
                 status = 'confirmed',
                 updated_at = NOW()
             WHERE id = $1`,
            [entryId, handwerkerId]
          );
        }
      }
      
      // Benachrichtigung an Bauherr wenn Änderungen vorgenommen wurden
      const hasChanges = adjustments?.some(a => a.changed);
      if (hasChanges) {
        const entryInfo = await query(
          `SELECT se.*, t.name as trade_name, ps.project_id, p.bauherr_id
           FROM schedule_entries se
           JOIN trades t ON se.trade_id = t.id
           JOIN project_schedules ps ON se.schedule_id = ps.id
           JOIN projects p ON ps.project_id = p.id
           WHERE se.id = $1`,
          [entryIds[0]]
        );
        
        if (entryInfo.rows.length > 0) {
          const info = entryInfo.rows[0];
          await query(
            `INSERT INTO notifications 
             (user_type, user_id, type, message, reference_type, reference_id, created_at)
             VALUES ('bauherr', $1, 'schedule_change_request', $2, 'schedule_entry', $3, NOW())`,
            [
              info.bauherr_id,
              `Handwerker hat Terminänderung für ${info.trade_name} vorgeschlagen`,
              entryIds[0]
            ]
          );
        }
      }
      
      await query('COMMIT');
      
      res.json({ 
        success: true,
        hasChanges,
        message: hasChanges 
          ? 'Terminänderung gespeichert - wartet auf Bauherr-Freigabe'
          : 'Termine bestätigt'
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      throw innerErr;
    }
    
  } catch (err) {
    console.error('[SCHEDULE] Confirmation failed:', err);
    res.status(500).json({ error: 'Fehler bei der Terminbestätigung' });
  }
});

// ============================================================================
// TERMINÄNDERUNG DURCH BAUHERR - FINALE KORREKTE LÖSUNG
// ============================================================================

app.post('/api/schedule-entries/:entryId/update', async (req, res) => {
  try {
    const { entryId } = req.params;
    const { newStart, newEnd, reason, bauherrId, cascadeChanges } = req.body;
    
    console.log('[CASCADE] 🔄 Starting update:', { entryId, newStart, newEnd, cascadeChanges });
    
    await query('BEGIN');
    
    try {
      // ========================================================================
      // SCHRITT 1: LADE DEN ZU ÄNDERNDEN TERMIN (VOR UPDATE!)
      // ========================================================================
      const entryResult = await query(
        `SELECT se.*, ps.status, ps.project_id, t.code, t.name as trade_name
         FROM schedule_entries se
         JOIN project_schedules ps ON se.schedule_id = ps.id
         JOIN trades t ON se.trade_id = t.id
         WHERE se.id = $1`,
        [entryId]
      );
      
      if (entryResult.rows.length === 0) {
        await query('ROLLBACK');
        return res.status(404).json({ error: 'Termin nicht gefunden' });
      }
      
      // ✅ FIX: Speichere ALTE Werte VOR dem Update!
      const originalEntry = { ...entryResult.rows[0] };
      const oldStart = new Date(originalEntry.planned_start);
      const oldEnd = new Date(originalEntry.planned_end);
      const newStartDate = new Date(newStart);
      const newEndDate = new Date(newEnd);
      
      console.log('[CASCADE] 📊 Original Entry:', { 
        id: originalEntry.id,
        trade: originalEntry.code, 
        phase: originalEntry.phase_number,
        phase_name: originalEntry.phase_name,
        oldStart: oldStart.toISOString().split('T')[0],
        oldEnd: oldEnd.toISOString().split('T')[0],
        newStart: newStartDate.toISOString().split('T')[0],
        newEnd: newEndDate.toISOString().split('T')[0]
      });
      
      // ========================================================================
      // PRÜFE WAS SICH GEÄNDERT HAT
      // ========================================================================
      const startChanged = oldStart.getTime() !== newStartDate.getTime();
      const endChanged = oldEnd.getTime() !== newEndDate.getTime();
      
      console.log('[CASCADE] 🔍 Changes:', { 
        startChanged, 
        endChanged,
        changeType: startChanged && endChanged ? 'BOTH' : 
                   startChanged ? 'START_ONLY' : 
                   endChanged ? 'END_ONLY' : 'NONE'
      });
      
      // ========================================================================
      // SCHRITT 2: UPDATE DES TERMINS
      // ========================================================================
      await query(
        `UPDATE schedule_entries 
         SET planned_start = $2,
             planned_end = $3,
             duration_days = $4,
             updated_at = NOW()
         WHERE id = $1`,
        [
          entryId,
          newStart,
          newEnd,
          calculateWorkdays(newStartDate, newEndDate)
        ]
      );
      
      // History Entry
      await query(
        `INSERT INTO schedule_history 
         (schedule_entry_id, changed_by_type, changed_by_id, change_type,
          old_start, old_end, new_start, new_end, reason)
         VALUES ($1, 'bauherr', $2, 'date_change', $3, $4, $5, $6, $7)`,
        [entryId, bauherrId, oldStart.toISOString().split('T')[0], oldEnd.toISOString().split('T')[0], newStart, newEnd, reason]
      );
      
      let affectedEntries = [];
      
      // ========================================================================
      // SCHRITT 3: CASCADE - NUR WENN AKTIVIERT UND ÄNDERUNGEN VORHANDEN
      // ========================================================================
      const shouldCascade = cascadeChanges && (startChanged || endChanged);

let dayShift = 0; // ← Außerhalb, für gesamten Scope verfügbar

if (shouldCascade) {
  console.log('[CASCADE] ✅ Cascade enabled');
        
        if (startChanged) {
          // Start verschoben -> berechne Arbeitstage zwischen altem und neuem Start
          dayShift = calculateWorkdays(oldStart, newStartDate);
          console.log('[CASCADE] 📈 Start shift:', dayShift, 'days');
        } else if (endChanged) {
          // Nur Ende geändert -> berechne Arbeitstage zwischen altem und neuem Ende
          dayShift = calculateWorkdays(oldEnd, newEndDate);
          console.log('[CASCADE] 📈 End shift:', dayShift, 'days');
        }
        
        if (dayShift !== 0) {
          // ✅ FIX: Lade ALLE Entries INKLUSIVE der gerade geänderten mit NEUEN Werten
          const allEntriesResult = await query(
            `SELECT se.*, t.code as trade_code, t.name as trade_name
             FROM schedule_entries se
             JOIN trades t ON se.trade_id = t.id
             WHERE se.schedule_id = $1
             ORDER BY se.planned_start`,
            [originalEntry.schedule_id]
          );
          
          const allEntries = allEntriesResult.rows;
          console.log('[CASCADE] 📦 Total entries:', allEntries.length);
          
          // Helper: Parse Dependencies sicher
          const parseDeps = (depsField) => {
            if (!depsField) return [];
            try {
              const parsed = typeof depsField === 'string' ? JSON.parse(depsField) : depsField;
              return Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
            } catch {
              return [];
            }
          };
          
          // ===================================================================
          // ✅ FIX: VERWENDE ORIGINALE WERTE FÜR CASCADE-LOGIK
          // ===================================================================
          const toUpdate = new Set();
          const processed = new Set([entryId]);
          
          const findAllDependents = (sourceTradeCode, sourcePhaseNumber, sourcePhaseName) => {
            console.log('[CASCADE] 🔍 Finding dependents of:', sourceTradeCode, 'Phase', sourcePhaseNumber || sourcePhaseName || 'N/A');
            
            allEntries.forEach(e => {
              // Überspringe bereits verarbeitete und den ursprünglichen Entry
              if (processed.has(e.id) || e.id === entryId) return;
              
              const deps = parseDeps(e.dependencies);
              
              let shouldUpdate = false;
              let reason = '';
              
// ================================================================
// FALL 1: Nachfolgende Phase des GLEICHEN Gewerks
// ================================================================
if (e.trade_code === sourceTradeCode) {
  // Szenario A: Beide haben phase_number -> höhere Phase verschieben
  if (e.phase_number && sourcePhaseNumber && e.phase_number > sourcePhaseNumber) {
    shouldUpdate = true;
    reason = 'same-trade next phase';
    console.log('[CASCADE] ✅ Found same-trade phase:', e.trade_code, 'Phase', e.phase_number, '>', sourcePhaseNumber);
  }
  // Szenario B: Entry hat explizite Dependency auf das Gewerk oder Phase
  else if (deps.length > 0) {
    // ✅ FIX: Finde das Source-Entry aus allEntries
    const currentSourceEntry = allEntries.find(entry => 
      entry.trade_code === sourceTradeCode && 
      (entry.phase_number === sourcePhaseNumber || entry.phase_name === sourcePhaseName)
    );
    
    if (currentSourceEntry) {
      deps.forEach(dep => {
        // Format: "DACH" oder "DACH-Eindeckung"
        if (dep === sourceTradeCode || 
            (typeof dep === 'string' && dep.startsWith(sourceTradeCode + '-'))) {
          // ✅ FIX: Prüfe ob Entry NACH Source kommt (sonst Rückwärts-Cascade!)
          const eStart = new Date(e.planned_start);
          const sourceEnd = new Date(currentSourceEntry.planned_end);
          
          if (eStart >= sourceEnd) {
            shouldUpdate = true;
            reason = 'same-trade via dependency';
            console.log('[CASCADE] ✅ Found same-trade dependency:', e.trade_code);
          } else {
            console.log('[CASCADE] ⏸️ Skipping same-trade dependency (comes before source):', e.trade_code, 'Phase', e.phase_number);
          }
        }
      });
    }
  }
  // ✅ FIX: Szenario C - Implizite Reihenfolge bei gleichem Gewerk
  // Wenn keine phase_number existiert, prüfe ob Entry nach dem ORIGINAL-Ende startet
  else if (!sourcePhaseNumber && !e.phase_number) {
    const eStart = new Date(e.planned_start);
    // ⚠️ WICHTIG: Verwende das ALTE Ende vom ORIGINAL-Entry, nicht das neue!
    const sourceEndDate = oldEnd;
    
    // Prüfe ob Entry nach dem ursprünglichen Ende startet (mit 1 Tag Toleranz)
    const daysDiff = Math.floor((eStart - sourceEndDate) / (1000 * 60 * 60 * 24));
    if (daysDiff >= -1) {
      shouldUpdate = true;
      reason = 'same-trade follows by date';
      console.log('[CASCADE] ✅ Found same-trade by date:', e.trade_code, 'starts', daysDiff, 'days after original end');
    }
  }
}
              
// ================================================================
// FALL 2: ABHÄNGIGES Gewerk (via Dependencies)
// ================================================================
if (!shouldUpdate && e.trade_code !== sourceTradeCode) {
  // ✅ FIX: Finde das Source-Entry aus allEntries
  const currentSourceEntry = allEntries.find(entry => 
    entry.trade_code === sourceTradeCode && 
    (entry.phase_number === sourcePhaseNumber || entry.phase_name === sourcePhaseName)
  );
  
  if (!currentSourceEntry) {
    console.log('[CASCADE] ⚠️ Source entry not found for:', sourceTradeCode, sourcePhaseNumber);
    return;
  }
  
  deps.forEach(dep => {
    // Format 1: "DACH"
    if (dep === sourceTradeCode) {
      // ✅ FIX: Prüfe zeitliche Reihenfolge!
      const eStart = new Date(e.planned_start);
      const sourceEnd = new Date(currentSourceEntry.planned_end);
      
      if (eStart >= sourceEnd) {
        shouldUpdate = true;
        reason = 'dependent trade';
        console.log('[CASCADE] ✅ Found dependent trade:', e.trade_code, 'depends on', sourceTradeCode);
      } else {
        console.log('[CASCADE] ⏸️ Skipping dependent trade (comes before source):', e.trade_code, 'starts', eStart.toISOString().split('T')[0], 'before source ends', sourceEnd.toISOString().split('T')[0]);
      }
    }
    // Format 2: "DACH-Eindeckung" (mit Phase)
    if (typeof dep === 'string' && dep.startsWith(sourceTradeCode + '-')) {
      const depPhaseName = dep.substring(sourceTradeCode.length + 1);
      // ✅ FIX: Auch hier zeitliche Prüfung
      const eStart = new Date(e.planned_start);
      const sourceEnd = new Date(currentSourceEntry.planned_end);
      
      if (eStart < sourceEnd) {
        console.log('[CASCADE] ⏸️ Skipping dependent trade with phase (comes before source):', e.trade_code);
        return;
      }
      
      // Prüfe ob es die richtige Phase ist
      if (sourcePhaseName && depPhaseName === sourcePhaseName) {
        shouldUpdate = true;
        reason = 'dependent trade (specific phase)';
        console.log('[CASCADE] ✅ Found dependent trade with phase match:', e.trade_code, 'depends on', dep);
      } else if (!sourcePhaseNumber) {
        shouldUpdate = true;
        reason = 'dependent trade (with phase ref)';
        console.log('[CASCADE] ✅ Found dependent trade with phase ref:', e.trade_code, 'depends on', dep);
      }
    }
  });
}

if (shouldUpdate) {
  console.log('[CASCADE] ✅ Will update:', e.trade_code, 'Phase', e.phase_number || 'N/A', `(${reason})`);
  toUpdate.add(e.id);
  processed.add(e.id);
  
  // ✅ FIX: Rekursion mit AKTUELLEN Werten des gefundenen Entries
  findAllDependents(e.trade_code, e.phase_number, e.phase_name, e);
}
 });  
};     
          
          // Starte CASCADE  // ← NEU
          console.log('[CASCADE] 🚀 Starting cascade from ORIGINAL:', originalEntry.code, 'Phase', originalEntry.phase_number || originalEntry.phase_name || 'N/A');  // ← NEU
          findAllDependents(originalEntry.code, originalEntry.phase_number, originalEntry.phase_name, originalEntry);  // ← NEU
          
          console.log('[CASCADE] 🎯 Found', toUpdate.size, 'entries to shift by', dayShift, 'days');  // ← NEU
              
          // ===================================================================
          // UPDATE ALLER ABHÄNGIGEN ENTRIES
          // ===================================================================
          for (const updateId of toUpdate) {
            const updateEntry = allEntries.find(e => e.id === updateId);
            if (!updateEntry) continue;
            
            const currentStart = new Date(updateEntry.planned_start);
            const currentEnd = new Date(updateEntry.planned_end);
            
            // Verschiebe um dayShift Arbeitstage
            const newFollowStart = addWorkdays(currentStart, dayShift);
            const newFollowEnd = addWorkdays(currentEnd, dayShift);
            
            console.log('[CASCADE] 🔄 Shifting:', updateEntry.trade_code, 'Phase', updateEntry.phase_number || 'N/A', {
              oldStart: currentStart.toISOString().split('T')[0],
              newStart: newFollowStart.toISOString().split('T')[0],
              shift: dayShift + ' days'
            });
            
            // Update in DB
            await query(
              `UPDATE schedule_entries 
               SET planned_start = $2,
                   planned_end = $3,
                   updated_at = NOW()
               WHERE id = $1`,
              [
                updateEntry.id,
                newFollowStart.toISOString().split('T')[0],
                newFollowEnd.toISOString().split('T')[0]
              ]
            );
            
            // History
            await query(
              `INSERT INTO schedule_history 
               (schedule_entry_id, changed_by_type, changed_by_id, change_type,
                old_start, old_end, new_start, new_end, reason, created_at)
               VALUES ($1, 'system', $2, 'cascade_change', $3, $4, $5, $6, $7, NOW())`,
              [
                updateEntry.id,
                bauherrId,
                currentStart.toISOString().split('T')[0],
                currentEnd.toISOString().split('T')[0],
                newFollowStart.toISOString().split('T')[0],
                newFollowEnd.toISOString().split('T')[0],
                `Automatisch verschoben wegen Terminänderung bei ${originalEntry.trade_name}${originalEntry.phase_number ? ' Phase ' + originalEntry.phase_number : ''}`
              ]
            );
            
            affectedEntries.push({
              id: updateEntry.id,
              trade_id: updateEntry.trade_id,
              trade_code: updateEntry.trade_code,
              phase_number: updateEntry.phase_number,
              old_start: currentStart.toISOString().split('T')[0],
              new_start: newFollowStart.toISOString().split('T')[0],
              shift_days: dayShift
            });
          }
        } else {
          console.log('[CASCADE] ⏸️ No shift (dayShift = 0)');
        }
      } else {
        console.log('[CASCADE] ⏸️ Cascade disabled or no changes');
      }
      
      // ========================================================================
      // SCHRITT 4: BENACHRICHTIGUNGEN
      // ========================================================================
      const affectedTradeIds = [originalEntry.trade_id, ...affectedEntries.map(e => e.trade_id)];
      
      const handwerkerResult = await query(
        `SELECT DISTINCT h.id, t.code, t.name as trade_name
         FROM handwerker h
         JOIN offers o ON h.id = o.handwerker_id
         JOIN tenders tn ON o.tender_id = tn.id
         JOIN trades t ON tn.trade_id = t.id
         WHERE tn.project_id = $1 
           AND tn.trade_id = ANY($2::int[])
           AND o.status IN ('preliminary', 'confirmed')`,
        [originalEntry.project_id, affectedTradeIds]
      );
      
      for (const handwerker of handwerkerResult.rows) {
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, created_at)
           VALUES ('handwerker', $1, 'schedule_changed', $2, 'schedule_entry', $3, NOW())`,
          [
            handwerker.id,
            `Terminänderung für ${handwerker.trade_name} - Bitte prüfen Sie die neuen Termine`,
            entryId
          ]
        );
      }
      
      await query('COMMIT');
      
      console.log('[CASCADE] 🎉 Success! Affected:', affectedEntries.length, 'entries');
      
      res.json({ 
        success: true,
        affectedEntries: affectedEntries.length,
        affectedDetails: affectedEntries,
        changeType: startChanged && endChanged ? 'both' : 
                   startChanged ? 'start_only' : 
                   endChanged ? 'end_only' : 'none',
        cascadeApplied: shouldCascade && affectedEntries.length > 0,
        dayShift: shouldCascade ? dayShift : 0,
        message: shouldCascade ? 
          `Termine erfolgreich aktualisiert. ${affectedEntries.length} abhängige Termine wurden um ${Math.abs(dayShift)} Tag${Math.abs(dayShift) !== 1 ? 'e' : ''} ${dayShift > 0 ? 'nach hinten' : 'nach vorne'} verschoben.` : 
          'Termin erfolgreich aktualisiert'
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      console.error('[CASCADE] ❌ Transaction error:', innerErr);
      throw innerErr;
    }
    
  } catch (err) {
    console.error('[CASCADE] ❌ Update failed:', err);
    res.status(500).json({ error: 'Fehler bei der Terminänderung' });
  }
});

// ============================================================================
// ROUTE: EINZELNEN TERMIN LÖSCHEN (NUR VOR FREIGABE)
// ============================================================================

app.delete('/api/schedule-entries/:entryId', async (req, res) => {
  try {
    const { entryId } = req.params;
    const { bauherrId } = req.body;
    
    console.log('[DELETE] 🗑️ Deleting entry:', entryId);
    
    await query('BEGIN');
    
    try {
      // Lade den Entry und prüfe Status
      const entryResult = await query(
        `SELECT se.*, ps.status, ps.project_id, t.code, t.name as trade_name
         FROM schedule_entries se
         JOIN project_schedules ps ON se.schedule_id = ps.id
         JOIN trades t ON se.trade_id = t.id
         WHERE se.id = $1`,
        [entryId]
      );
      
      if (entryResult.rows.length === 0) {
        await query('ROLLBACK');
        return res.status(404).json({ error: 'Termin nicht gefunden' });
      }
      
      const entry = entryResult.rows[0];
      
      // ✅ Prüfe: Nur bei "pending_approval" erlaubt
      if (entry.status !== 'pending_approval') {
        await query('ROLLBACK');
        return res.status(403).json({ 
          error: 'Termine können nur vor der Freigabe gelöscht werden',
          currentStatus: entry.status
        });
      }
      
      console.log('[DELETE] ✅ Entry can be deleted:', {
        id: entry.id,
        trade: entry.code,
        phase: entry.phase_number || 'N/A',
        status: entry.status
      });
      
      // History: ERST dokumentieren (bevor Entry gelöscht wird!)
      await query(
        `INSERT INTO schedule_history 
         (schedule_entry_id, changed_by_type, changed_by_id, change_type,
          old_start, old_end, reason, created_at)
         VALUES ($1, 'bauherr', $2, 'deleted', $3, $4, $5, NOW())`,
        [
          entryId,
          bauherrId,
          entry.planned_start,
          entry.planned_end,
          `Termin für ${entry.trade_name}${entry.phase_number ? ' Phase ' + entry.phase_number : ''} wurde vor Freigabe gelöscht`
        ]
      );
      
      // DANN: Lösche den Entry
      await query('DELETE FROM schedule_entries WHERE id = $1', [entryId]);
      
      await query('COMMIT');
      
      console.log('[DELETE] 🎉 Entry deleted successfully');
      
      res.json({ 
        success: true,
        message: `Termin für ${entry.trade_name}${entry.phase_number ? ' (Phase ' + entry.phase_number + ')' : ''} wurde gelöscht`
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      console.error('[DELETE] ❌ Transaction error:', innerErr);
      throw innerErr;
    }
    
  } catch (err) {
    console.error('[DELETE] ❌ Delete failed:', err);
    res.status(500).json({ error: 'Fehler beim Löschen des Termins' });
  }
});

app.get('/api/offers/:offerId/schedule-changes', async (req, res) => {
  try {
    const { offerId } = req.params;
    
    const result = await query(
      `SELECT 
        se.id,
        se.phase_name,
        se.planned_start as new_start,
        se.planned_end as new_end,
        sh.old_start,
        sh.old_end,
        sh.reason
       FROM schedule_entries se
       JOIN LATERAL (
         SELECT old_start, old_end, reason
         FROM schedule_history
         WHERE schedule_entry_id = se.id
         ORDER BY created_at DESC
         LIMIT 1
       ) sh ON true
       JOIN project_schedules ps ON se.schedule_id = ps.id
       JOIN tenders t ON ps.project_id = t.project_id AND t.trade_id = se.trade_id
       WHERE t.id = (SELECT tender_id FROM offers WHERE id = $1)
       AND se.status = 'change_requested'
       ORDER BY se.planned_start`,
      [offerId]
    );
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error:', err);
    res.status(500).json({ error: err.message });
  }
});

// ============================================================================
// 8. TERMINÄNDERUNGS-ANFRAGE ERSTELLEN (Handwerker nach Beauftragung)
// ============================================================================

app.post('/api/schedule-entries/:entryId/request-change', async (req, res) => {
  try {
    const { entryId } = req.params;
    const { handwerkerId, requestedStart, requestedEnd, reason, urgency } = req.body;
    
    if (!reason || reason.trim().length < 10) {
      return res.status(400).json({ error: 'Bitte geben Sie eine aussagekräftige Begründung an' });
    }
    
    await query('BEGIN');
    
    try {
      // Berechne Auswirkungen
      const entryResult = await query(
        `SELECT se.*, ps.project_id, p.bauherr_id, t.name as trade_name
         FROM schedule_entries se
         JOIN project_schedules ps ON se.schedule_id = ps.id
         JOIN projects p ON ps.project_id = p.id
         JOIN trades t ON se.trade_id = t.id
         WHERE se.id = $1`,
        [entryId]
      );
      
      if (entryResult.rows.length === 0) {
        await query('ROLLBACK');
        return res.status(404).json({ error: 'Termin nicht gefunden' });
      }
      
      const entry = entryResult.rows[0];
      
      // Prüfe ob Folgetermine betroffen sind
      const followingResult = await query(
        `SELECT id, trade_id FROM schedule_entries 
         WHERE schedule_id = $1 
           AND sequence_order > $2`,
        [entry.schedule_id, entry.sequence_order]
      );
      
      const affectsFollowing = followingResult.rows.length > 0;
      const delayDays = calculateWorkdays(entry.planned_end, new Date(requestedEnd));
      
      // Erstelle Change Request
      const requestResult = await query(
        `INSERT INTO schedule_change_requests 
         (schedule_entry_id, handwerker_id, requested_start, requested_end, 
          reason, urgency, affects_following_trades, affected_trade_ids, estimated_delay_days)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
         RETURNING id`,
        [
          entryId,
          handwerkerId,
          requestedStart,
          requestedEnd,
          reason,
          urgency || 'normal',
          affectsFollowing,
          JSON.stringify(followingResult.rows.map(r => r.trade_id)),
          Math.max(0, delayDays)
        ]
      );
      
      // Update Entry Status
      await query(
        `UPDATE schedule_entries 
         SET status = 'change_requested'
         WHERE id = $1`,
        [entryId]
      );
      
      // Benachrichtige Bauherr
      await query(
        `INSERT INTO notifications 
         (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
         VALUES ('bauherr', $1, 'schedule_change_request', $2, 'change_request', $3, $4, NOW())`,
        [
          entry.bauherr_id,
          `Terminänderung für ${entry.trade_name} beantragt - ${affectsFollowing ? 'Betrifft Folgetermine' : 'Keine Auswirkungen auf andere Gewerke'}`,
          requestResult.rows[0].id,
          JSON.stringify({ 
            urgency,
            affects_following: affectsFollowing,
            delay_days: delayDays,
            reason: reason 
          })
        ]
      );
      
      await query('COMMIT');
      
      res.json({ 
        success: true,
        requestId: requestResult.rows[0].id,
        affectsFollowing,
        estimatedDelay: delayDays,
        message: 'Änderungsanfrage gesendet'
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      throw innerErr;
    }
    
  } catch (err) {
    console.error('[SCHEDULE] Change request failed:', err);
    res.status(500).json({ error: 'Fehler beim Erstellen der Anfrage' });
  }
});

// ============================================================================
// 9. TERMINÄNDERUNGS-ANFRAGE BEARBEITEN (Bauherr) - MIT CASCADE
// ============================================================================

app.post('/api/schedule-change-requests/:requestId/resolve', async (req, res) => {
  try {
    const { requestId } = req.params;
    const { bauherrId, decision, rejectionReason, cascadeChanges } = req.body;
    
    if (!['approved', 'rejected'].includes(decision)) {
      return res.status(400).json({ error: 'Ungültige Entscheidung' });
    }
    
    console.log('[RESOLVE-CASCADE] 🔄 Starting resolve:', { requestId, decision, cascadeChanges });
    
    await query('BEGIN');
    
    try {
      // ========================================================================
      // SCHRITT 1: LADE CHANGE REQUEST
      // ========================================================================
      const requestResult = await query(
        `SELECT cr.*, se.schedule_id, se.planned_start, se.planned_end, 
                se.trade_id, se.sequence_order, se.phase_number, se.phase_name,
                t.name as trade_name, t.code as trade_code, h.company_name,
                ps.project_id
         FROM schedule_change_requests cr
         JOIN schedule_entries se ON cr.schedule_entry_id = se.id
         JOIN project_schedules ps ON se.schedule_id = ps.id
         JOIN trades t ON se.trade_id = t.id
         JOIN handwerker h ON cr.handwerker_id = h.id
         WHERE cr.id = $1`,
        [requestId]
      );
      
      if (requestResult.rows.length === 0) {
        await query('ROLLBACK');
        return res.status(404).json({ error: 'Anfrage nicht gefunden' });
      }
      
      const request = requestResult.rows[0];
      const entryId = request.schedule_entry_id;
      
      // Speichere ALTE Werte VOR dem Update
      const oldStart = new Date(request.planned_start);
      const oldEnd = new Date(request.planned_end);
      const newStartDate = new Date(request.requested_start);
      const newEndDate = new Date(request.requested_end);
      
      console.log('[RESOLVE-CASCADE] 📊 Request Details:', {
        id: entryId,
        trade: request.trade_code,
        phase: request.phase_number || request.phase_name,
        oldStart: oldStart.toISOString().split('T')[0],
        oldEnd: oldEnd.toISOString().split('T')[0],
        newStart: newStartDate.toISOString().split('T')[0],
        newEnd: newEndDate.toISOString().split('T')[0]
      });
      
      if (decision === 'approved') {
        // ====================================================================
        // GENEHMIGT: UPDATE MIT CASCADE
        // ====================================================================
        
        // Berechne Verschiebung
        const startChanged = oldStart.getTime() !== newStartDate.getTime();
        const endChanged = oldEnd.getTime() !== newEndDate.getTime();
        
        console.log('[RESOLVE-CASCADE] 🔍 Changes:', { startChanged, endChanged });
        
        // Update Entry selbst
        await query(
          `UPDATE schedule_entries 
           SET planned_start = $2,
               planned_end = $3,
               duration_days = $4,
               status = 'confirmed',
               updated_at = NOW()
           WHERE id = $1`,
          [
            entryId,
            request.requested_start,
            request.requested_end,
            calculateWorkdays(newStartDate, newEndDate)
          ]
        );
        
        // History
        await query(
          `INSERT INTO schedule_history 
           (schedule_entry_id, changed_by_type, changed_by_id, change_type,
            old_start, old_end, new_start, new_end, reason, change_request_id)
           VALUES ($1, 'bauherr', $2, 'approved_change', $3, $4, $5, $6, $7, $8)`,
          [
            entryId,
            bauherrId,
            oldStart.toISOString().split('T')[0],
            oldEnd.toISOString().split('T')[0],
            request.requested_start,
            request.requested_end,
            `Änderungsanfrage von ${request.company_name} genehmigt: ${request.reason}`,
            requestId
          ]
        );
        
        let affectedEntries = [];
        
        // ====================================================================
        // CASCADE-LOGIK (KOPIERT AUS /update)
        // ====================================================================
        const shouldCascade = cascadeChanges && (startChanged || endChanged);
        let dayShift = 0;
        
        if (shouldCascade) {
          console.log('[RESOLVE-CASCADE] ✅ Cascade enabled');
          
          if (startChanged) {
            dayShift = calculateWorkdays(oldStart, newStartDate);
            console.log('[RESOLVE-CASCADE] 📈 Start shift:', dayShift, 'days');
          } else if (endChanged) {
            dayShift = calculateWorkdays(oldEnd, newEndDate);
            console.log('[RESOLVE-CASCADE] 📈 End shift:', dayShift, 'days');
          }
          
          if (dayShift !== 0) {
            // Lade ALLE Entries
            const allEntriesResult = await query(
              `SELECT se.*, t.code as trade_code, t.name as trade_name
               FROM schedule_entries se
               JOIN trades t ON se.trade_id = t.id
               WHERE se.schedule_id = $1
               ORDER BY se.planned_start`,
              [request.schedule_id]
            );
            
            const allEntries = allEntriesResult.rows;
            console.log('[RESOLVE-CASCADE] 📦 Total entries:', allEntries.length);
            
            // Helper: Parse Dependencies
            const parseDeps = (depsField) => {
              if (!depsField) return [];
              try {
                const parsed = typeof depsField === 'string' ? JSON.parse(depsField) : depsField;
                return Array.isArray(parsed) ? parsed : (parsed ? [parsed] : []);
              } catch {
                return [];
              }
            };
            
            const toUpdate = new Set();
            const processed = new Set([entryId]);
            
            const findAllDependents = (sourceTradeCode, sourcePhaseNumber, sourcePhaseName) => {
              console.log('[RESOLVE-CASCADE] 🔍 Finding dependents of:', sourceTradeCode, 'Phase', sourcePhaseNumber || sourcePhaseName || 'N/A');
              
              allEntries.forEach(e => {
                if (processed.has(e.id) || e.id === entryId) return;
                
                const deps = parseDeps(e.dependencies);
                let shouldUpdate = false;
                let reason = '';
                
                // FALL 1: Nachfolgende Phase des GLEICHEN Gewerks
                if (e.trade_code === sourceTradeCode) {
                  if (e.phase_number && sourcePhaseNumber && e.phase_number > sourcePhaseNumber) {
                    shouldUpdate = true;
                    reason = 'same-trade next phase';
                  } else if (deps.length > 0) {
                    const currentSourceEntry = allEntries.find(entry => 
                      entry.trade_code === sourceTradeCode && 
                      (entry.phase_number === sourcePhaseNumber || entry.phase_name === sourcePhaseName)
                    );
                    
                    if (currentSourceEntry) {
                      deps.forEach(dep => {
                        if (dep === sourceTradeCode || 
                            (typeof dep === 'string' && dep.startsWith(sourceTradeCode + '-'))) {
                          const eStart = new Date(e.planned_start);
                          const sourceEnd = new Date(currentSourceEntry.planned_end);
                          
                          if (eStart >= sourceEnd) {
                            shouldUpdate = true;
                            reason = 'same-trade via dependency';
                          }
                        }
                      });
                    }
                  } else if (!sourcePhaseNumber && !e.phase_number) {
                    const eStart = new Date(e.planned_start);
                    const sourceEndDate = oldEnd;
                    const daysDiff = Math.floor((eStart - sourceEndDate) / (1000 * 60 * 60 * 24));
                    
                    if (daysDiff >= -1) {
                      shouldUpdate = true;
                      reason = 'same-trade follows by date';
                    }
                  }
                }
                
                // FALL 2: ABHÄNGIGES Gewerk
                if (!shouldUpdate && e.trade_code !== sourceTradeCode) {
                  const currentSourceEntry = allEntries.find(entry => 
                    entry.trade_code === sourceTradeCode && 
                    (entry.phase_number === sourcePhaseNumber || entry.phase_name === sourcePhaseName)
                  );
                  
                  if (currentSourceEntry) {
                    deps.forEach(dep => {
                      if (dep === sourceTradeCode) {
                        const eStart = new Date(e.planned_start);
                        const sourceEnd = new Date(currentSourceEntry.planned_end);
                        
                        if (eStart >= sourceEnd) {
                          shouldUpdate = true;
                          reason = 'dependent trade';
                        }
                      }
                      if (typeof dep === 'string' && dep.startsWith(sourceTradeCode + '-')) {
                        const depPhaseName = dep.substring(sourceTradeCode.length + 1);
                        const eStart = new Date(e.planned_start);
                        const sourceEnd = new Date(currentSourceEntry.planned_end);
                        
                        if (eStart >= sourceEnd) {
                          if (sourcePhaseName && depPhaseName === sourcePhaseName) {
                            shouldUpdate = true;
                            reason = 'dependent trade (specific phase)';
                          } else if (!sourcePhaseNumber) {
                            shouldUpdate = true;
                            reason = 'dependent trade (with phase ref)';
                          }
                        }
                      }
                    });
                  }
                }
                
                if (shouldUpdate) {
                  console.log('[RESOLVE-CASCADE] ✅ Will update:', e.trade_code, 'Phase', e.phase_number || 'N/A', `(${reason})`);
                  toUpdate.add(e.id);
                  processed.add(e.id);
                  findAllDependents(e.trade_code, e.phase_number, e.phase_name);
                }
              });
            };
            
            // Starte CASCADE
            findAllDependents(request.trade_code, request.phase_number, request.phase_name);
            
            console.log('[RESOLVE-CASCADE] 🎯 Found', toUpdate.size, 'entries to shift by', dayShift, 'days');
            
            // UPDATE ALLER ABHÄNGIGEN ENTRIES
            for (const updateId of toUpdate) {
              const updateEntry = allEntries.find(e => e.id === updateId);
              if (!updateEntry) continue;
              
              const currentStart = new Date(updateEntry.planned_start);
              const currentEnd = new Date(updateEntry.planned_end);
              
              const newFollowStart = addWorkdays(currentStart, dayShift);
              const newFollowEnd = addWorkdays(currentEnd, dayShift);
              
              console.log('[RESOLVE-CASCADE] 🔄 Shifting:', updateEntry.trade_code, 'Phase', updateEntry.phase_number || 'N/A');
              
              await query(
                `UPDATE schedule_entries 
                 SET planned_start = $2,
                     planned_end = $3,
                     updated_at = NOW()
                 WHERE id = $1`,
                [
                  updateEntry.id,
                  newFollowStart.toISOString().split('T')[0],
                  newFollowEnd.toISOString().split('T')[0]
                ]
              );
              
              await query(
                `INSERT INTO schedule_history 
                 (schedule_entry_id, changed_by_type, changed_by_id, change_type,
                  old_start, old_end, new_start, new_end, reason, created_at)
                 VALUES ($1, 'system', $2, 'cascade_change', $3, $4, $5, $6, $7, NOW())`,
                [
                  updateEntry.id,
                  bauherrId,
                  currentStart.toISOString().split('T')[0],
                  currentEnd.toISOString().split('T')[0],
                  newFollowStart.toISOString().split('T')[0],
                  newFollowEnd.toISOString().split('T')[0],
                  `Automatisch verschoben wegen genehmigter Terminänderung bei ${request.trade_name}${request.phase_number ? ' Phase ' + request.phase_number : ''}`
                ]
              );
              
              affectedEntries.push({
                id: updateEntry.id,
                trade_id: updateEntry.trade_id,
                trade_code: updateEntry.trade_code,
                trade_name: updateEntry.trade_name,
                phase_number: updateEntry.phase_number,
                old_start: currentStart.toISOString().split('T')[0],
                new_start: newFollowStart.toISOString().split('T')[0],
                shift_days: dayShift
              });
            }
          }
        }
        
        // ====================================================================
        // BENACHRICHTIGUNGEN
        // ====================================================================
        
        // Benachrichtige ursprünglichen Handwerker
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, created_at)
           VALUES ('handwerker', $1, 'change_request_approved', $2, 'schedule_entry', $3, NOW())`,
          [
            request.handwerker_id,
            `Ihre Terminänderung für ${request.trade_name} wurde genehmigt`,
            entryId
          ]
        );
        
        // Benachrichtige ALLE betroffenen Handwerker
        if (affectedEntries.length > 0) {
          const affectedTradeIds = [...new Set(affectedEntries.map(e => e.trade_id))];
          
          const handwerkerResult = await query(
            `SELECT DISTINCT h.id, t.code, t.name as trade_name
             FROM handwerker h
             JOIN offers o ON h.id = o.handwerker_id
             JOIN tenders tn ON o.tender_id = tn.id
             JOIN trades t ON tn.trade_id = t.id
             WHERE tn.project_id = $1 
               AND tn.trade_id = ANY($2::int[])
               AND o.status IN ('preliminary', 'confirmed')
               AND h.id != $3`,
            [request.project_id, affectedTradeIds, request.handwerker_id]
          );
          
          for (const handwerker of handwerkerResult.rows) {
            const affectedForThisHandwerker = affectedEntries.filter(e => 
              e.trade_code === handwerker.code
            );
            
            if (affectedForThisHandwerker.length > 0) {
              await query(
                `INSERT INTO notifications 
                 (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
                 VALUES ('handwerker', $1, 'schedule_changed', $2, 'project', $3, $4, NOW())`,
                [
                  handwerker.id,
                  `Ihre Termine für ${handwerker.trade_name} wurden um ${Math.abs(dayShift)} Tag${Math.abs(dayShift) !== 1 ? 'e' : ''} ${dayShift > 0 ? 'nach hinten' : 'nach vorne'} verschoben`,
                  request.project_id,
                  JSON.stringify({
                    reason: `Terminänderung bei ${request.trade_name} genehmigt`,
                    shift_days: dayShift,
                    affected_phases: affectedForThisHandwerker.map(e => e.phase_number || 'N/A')
                  })
                ]
              );
            }
          }
        }
        
      } else {
        // ====================================================================
        // ABGELEHNT: STATUS ZURÜCKSETZEN
        // ====================================================================
        await query(
          `UPDATE schedule_entries 
           SET status = 'confirmed'
           WHERE id = $1`,
          [entryId]
        );
        
        await query(
          `INSERT INTO notifications 
           (user_type, user_id, type, message, reference_type, reference_id, metadata, created_at)
           VALUES ('handwerker', $1, 'change_request_rejected', $2, 'schedule_entry', $3, $4, NOW())`,
          [
            request.handwerker_id,
            `Ihre Terminänderung für ${request.trade_name} wurde abgelehnt`,
            entryId,
            JSON.stringify({ reason: rejectionReason })
          ]
        );
      }
      
      // Update Change Request Status
      await query(
        `UPDATE schedule_change_requests 
         SET status = $2,
             resolved_at = NOW(),
             resolved_by = $3,
             rejection_reason = $4
         WHERE id = $1`,
        [requestId, decision, bauherrId, rejectionReason]
      );
      
      await query('COMMIT');
      
      console.log('[RESOLVE-CASCADE] 🎉 Success! Affected:', affectedEntries?.length || 0, 'entries');
      
      res.json({ 
        success: true,
        decision,
        affectedEntries: affectedEntries?.length || 0,
        affectedDetails: affectedEntries || [],
        cascadeApplied: shouldCascade && (affectedEntries?.length || 0) > 0,
        dayShift: shouldCascade ? dayShift : 0,
        message: decision === 'approved' 
          ? (affectedEntries && affectedEntries.length > 0 
              ? `Terminänderung genehmigt. ${affectedEntries.length} abhängige Termine wurden um ${Math.abs(dayShift)} Tag${Math.abs(dayShift) !== 1 ? 'e' : ''} ${dayShift > 0 ? 'nach hinten' : 'nach vorne'} verschoben.`
              : 'Terminänderung genehmigt')
          : 'Terminänderung abgelehnt'
      });
      
    } catch (innerErr) {
      await query('ROLLBACK');
      console.error('[RESOLVE-CASCADE] ❌ Transaction error:', innerErr);
      throw innerErr;
    }
    
  } catch (err) {
    console.error('[RESOLVE-CASCADE] ❌ Resolve failed:', err);
    res.status(500).json({ error: 'Fehler bei der Bearbeitung' });
  }
});

// ============================================================================
// 10. TERMINPLAN SPERREN (alle Gewerke vergeben)
// ============================================================================

app.post('/api/schedules/:scheduleId/lock', async (req, res) => {
  try {
    const { scheduleId } = req.params;
    
    // Prüfe ob alle Einträge bestätigt sind
    const unconfirmedResult = await query(
      `SELECT COUNT(*) as count 
       FROM schedule_entries 
       WHERE schedule_id = $1 AND confirmed = false`,
      [scheduleId]
    );
    
    if (unconfirmedResult.rows[0].count > 0) {
      return res.status(400).json({ 
        error: 'Nicht alle Termine sind bestätigt',
        unconfirmed: unconfirmedResult.rows[0].count
      });
    }
    
    // Sperre Schedule
    await query(
      `UPDATE project_schedules 
       SET status = 'locked',
           updated_at = NOW()
       WHERE id = $1`,
      [scheduleId]
    );
    
    res.json({ 
      success: true,
      message: 'Terminplan gesperrt - Änderungen nur noch durch Bauherr möglich'
    });
    
  } catch (err) {
    console.error('[SCHEDULE] Lock failed:', err);
    res.status(500).json({ error: 'Fehler beim Sperren' });
  }
});

// ============================================================================
// 11. TERMINPLAN-ÜBERSICHT FÜR HANDWERKER
// ============================================================================

app.get('/api/handwerker/:handwerkerId/schedule', async (req, res) => {
  try {
    const { handwerkerId } = req.params;
    
    // Lade alle Projekte mit Terminen wo Handwerker beauftragt ist
    const scheduleResult = await query(
      `SELECT 
        p.id as project_id,
        p.description as project_description,
        p.street,
        p.house_number,
        p.zip_code,
        p.city,
        t.code as trade_code,
        t.name as trade_name,
        se.id as entry_id,
        se.phase_name,
        se.phase_number,
        se.planned_start,
        se.planned_end,
        se.duration_days,
        se.status,
        se.confirmed,
        o.id as order_id,
        CASE 
          WHEN o.id IS NOT NULL THEN true 
          ELSE false 
        END as is_contracted
       FROM schedule_entries se
       JOIN project_schedules ps ON se.schedule_id = ps.id
       JOIN projects p ON ps.project_id = p.id
       JOIN trades t ON se.trade_id = t.id
       JOIN offers of ON of.tender_id IN (
         SELECT id FROM tenders WHERE project_id = p.id AND trade_id = t.id
       )
       LEFT JOIN orders o ON o.offer_id = of.id
       WHERE of.handwerker_id = $1
         AND of.status IN ('preliminary', 'confirmed', 'accepted')
         AND ps.status IN ('active', 'locked')
       ORDER BY se.planned_start, p.id, se.phase_number`,
      [handwerkerId]
    );
    
    // Gruppiere nach Projekt
    const projects = {};
    scheduleResult.rows.forEach(row => {
      if (!projects[row.project_id]) {
        projects[row.project_id] = {
          project_id: row.project_id,
          project_description: row.project_description,
          address: `${row.street} ${row.house_number}, ${row.zip_code} ${row.city}`,
          entries: []
        };
      }
      
      projects[row.project_id].entries.push({
        entry_id: row.entry_id,
        trade_code: row.trade_code,
        trade_name: row.trade_name,
        phase_name: row.phase_name,
        phase_number: row.phase_number,
        planned_start: row.planned_start,
        planned_end: row.planned_end,
        duration_days: row.duration_days,
        status: row.status,
        confirmed: row.confirmed,
        order_id: row.order_id,
        is_contracted: row.is_contracted
      });
    });
    
    res.json(Object.values(projects));
    
  } catch (err) {
    console.error('[SCHEDULE] Handwerker schedule failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Terminübersicht' });
  }
});

// ============================================================================
// 12. BADGE-COUNT FÜR TERMINPLAN-TAB
// ============================================================================

app.get('/api/projects/:projectId/schedule/badge-count', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT 
        COUNT(*) FILTER (WHERE se.status = 'change_requested') as pending_changes,
        COUNT(*) FILTER (WHERE se.confirmed = false AND ps.status = 'active') as pending_confirmations,
        COUNT(*) FILTER (WHERE ps.status = 'pending_approval') as needs_approval
       FROM project_schedules ps
       LEFT JOIN schedule_entries se ON ps.id = se.schedule_id
       WHERE ps.project_id = $1`,
      [projectId]
    );
    
    const counts = result.rows[0];
    const totalBadge = 
      parseInt(counts.pending_changes || 0) + 
      parseInt(counts.pending_confirmations || 0) + 
      parseInt(counts.needs_approval || 0);
    
    res.json({
      total: totalBadge,
      details: {
        pendingChanges: parseInt(counts.pending_changes || 0),
        pendingConfirmations: parseInt(counts.pending_confirmations || 0),
        needsApproval: parseInt(counts.needs_approval || 0)
      }
    });
    
  } catch (err) {
    console.error('[SCHEDULE] Badge count failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden' });
  }
});

// ============================================================================
// LADE ALLE CHANGE REQUESTS FÜR EIN PROJEKT
// ============================================================================
app.get('/api/projects/:projectId/schedule-change-requests', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const result = await query(
      `SELECT scr.*
       FROM schedule_change_requests scr
       JOIN schedule_entries se ON scr.schedule_entry_id = se.id
       JOIN project_schedules ps ON se.schedule_id = ps.id
       WHERE ps.project_id = $1
       ORDER BY scr.created_at DESC`,
      [projectId]
    );
    
    res.json(result.rows);
    
  } catch (err) {
    console.error('[SCHEDULE] Load change requests failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden' });
  }
});

// ============================================================================
// HANDWERKER-INFO FÜR SCHEDULE ENTRY ABRUFEN
// ============================================================================
app.get('/api/schedule-entries/:entryId/handwerker-info', async (req, res) => {
  try {
    const { entryId } = req.params;
    
    const result = await query(
      `SELECT 
         h.id,
         h.company_name,
         h.contact_person,
         se.confirmed,
         se.confirmed_at,
         se.status
       FROM schedule_entries se
       LEFT JOIN offers o ON o.id = (
         SELECT o2.id 
         FROM offers o2
         JOIN tenders t ON o2.tender_id = t.id
         WHERE t.trade_id = se.trade_id 
         AND o2.status IN ('confirmed', 'accepted')
         ORDER BY o2.updated_at DESC
         LIMIT 1
       )
       LEFT JOIN handwerker h ON o.handwerker_id = h.id
       WHERE se.id = $1`,
      [entryId]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Entry nicht gefunden' });
    }
    
    res.json(result.rows[0]);
    
  } catch (err) {
    console.error('[SCHEDULE] Handwerker info failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Handwerker-Info' });
  }
});

// ============================================================================
// HANDWERKER SCHEDULE - ALLE EIGENEN TERMINE
// ============================================================================
app.get('/api/handwerker/:handwerkerId/schedule', async (req, res) => {
  try {
    const { handwerkerId } = req.params;
    
    const result = await query(
      `SELECT 
         p.id as project_id,
         p.street,
         p.house_number,
         p.zip_code,
         p.city,
         p.description as project_description,
         b.name as bauherr_name,
         b.phone as bauherr_phone,
         b.email as bauherr_email,
         se.id as entry_id,
         se.trade_id,
         se.phase_name,
         se.phase_number,
         se.planned_start,
         se.planned_end,
         se.duration_days,
         se.buffer_days,
         se.confirmed,
         se.confirmed_at,
         se.status,
         se.scheduling_reason,
         t.name as trade_name,
         t.code as trade_code,
         o.id as order_id,
         o.amount as order_amount
       FROM schedule_entries se
       JOIN project_schedules ps ON se.schedule_id = ps.id
       JOIN projects p ON ps.project_id = p.id
       JOIN bauherren b ON p.bauherr_id = b.id
       JOIN trades t ON se.trade_id = t.id
       JOIN orders o ON o.project_id = p.id AND o.trade_id = se.trade_id AND o.handwerker_id = $1
       WHERE ps.status IN ('active', 'locked')
       AND o.status = 'active'
       ORDER BY se.planned_start ASC`,
      [handwerkerId]
    );
    
    // Gruppiere nach Projekt
    const projects = {};
    result.rows.forEach(row => {
      if (!projects[row.project_id]) {
        projects[row.project_id] = {
          project_id: row.project_id,
          address: `${row.street} ${row.house_number}, ${row.zip_code} ${row.city}`,
          description: row.project_description,
          bauherr_name: row.bauherr_name,
          bauherr_phone: row.bauherr_phone,
          bauherr_email: row.bauherr_email,
          entries: []
        };
      }
      
      projects[row.project_id].entries.push({
        entry_id: row.entry_id,
        trade_id: row.trade_id,
        trade_name: row.trade_name,
        trade_code: row.trade_code,
        phase_name: row.phase_name,
        phase_number: row.phase_number,
        planned_start: row.planned_start,
        planned_end: row.planned_end,
        duration_days: row.duration_days,
        buffer_days: row.buffer_days,
        confirmed: row.confirmed,
        confirmed_at: row.confirmed_at,
        status: row.status,
        scheduling_reason: row.scheduling_reason,
        order_id: row.order_id,
        order_amount: row.order_amount
      });
    });
    
    res.json(Object.values(projects));
    
  } catch (err) {
    console.error('[HANDWERKER] Schedule load failed:', err);
    res.status(500).json({ error: 'Fehler beim Laden des Terminplans' });
  }
});



// ============================================================================
// HELPER-FUNKTION EXPORT (falls benötigt)
// ============================================================================

module.exports = {
  calculateWorkdays,
  addWorkdays,
  checkScheduleEligibility
};

// ADMIN ROUTES - COMPLETE DASHBOARD API
// ===========================================================================

// Simple token storage (in production, use Redis or database)
const activeSessions = new Map();

// Generate random token
function generateToken() {
  return require('crypto').randomBytes(32).toString('hex');
}

// Simple admin authentication without bcrypt
app.post('/api/admin/auth', async (req, res) => {
  try {
    const { password } = req.body;
    
    // Use environment variable for admin password
    const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'ChangeThisPassword2024!';

    if (!password) {
      return res.status(400).json({ error: 'Password required' });
    }

    // Simple password check
    if (password !== ADMIN_PASSWORD) {
      console.warn(`Failed admin login attempt from IP: ${req.ip}`);
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // Generate simple token
    const token = generateToken();
    
    // Store token with metadata
    activeSessions.set(token, {
      role: 'admin',
      createdAt: Date.now(),
      ip: req.ip
    });

    // Clean up old tokens (older than 24 hours)
    const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
    for (const [key, value] of activeSessions.entries()) {
      if (value.createdAt < oneDayAgo) {
        activeSessions.delete(key);
      }
    }

    console.log(`Successful admin login from IP: ${req.ip}`);

    res.json({ 
      token,
      message: 'Login successful'
    });
  } catch (err) {
    console.error('Admin auth failed:', err);
    res.status(500).json({ error: 'Authentication failed' });
  }
});

// Simple middleware for admin routes
function requireAdmin(req, res, next) {
  const auth = req.headers.authorization;
  
  if (!auth || !auth.startsWith('Bearer ')) {
    return res.status(401).json({ error: 'Authorization required' });
  }
  
  const token = auth.slice(7);
  
  // Check if token exists and is valid
  const session = activeSessions.get(token);
  
  if (!session) {
    return res.status(403).json({ error: 'Invalid or expired token' });
  }
  
  // Check if token is not too old (24 hours)
  const dayInMs = 24 * 60 * 60 * 1000;
  if (Date.now() - session.createdAt > dayInMs) {
    activeSessions.delete(token);
    return res.status(403).json({ error: 'Token expired' });
  }
  
  if (session.role !== 'admin') {
    return res.status(403).json({ error: 'Admin access required' });
  }
  
  req.admin = session;
  next();
}

// Logout endpoint
app.post('/api/admin/logout', requireAdmin, async (req, res) => {
  const auth = req.headers.authorization;
  if (auth && auth.startsWith('Bearer ')) {
    const token = auth.slice(7);
    activeSessions.delete(token);
  }
  res.json({ message: 'Logout successful' });
});

// ===========================================================================
// DASHBOARD OVERVIEW STATS
// ===========================================================================

app.get('/api/admin/stats', requireAdmin, async (req, res) => {
  try {
    // Get total users
    const userStats = await query(`
      SELECT 
        (SELECT COUNT(*) FROM bauherren) as bauherren_count,
        (SELECT COUNT(*) FROM handwerker) as handwerker_count
    `);
    
    // Get project stats
    const projectStats = await query(`
      SELECT 
        COUNT(*) as total_projects,
        COUNT(CASE WHEN status = 'active' THEN 1 END) as active_projects,
        SUM(budget) as total_value
      FROM projects
    `);
    
    // Get payment stats
    const paymentStats = await query(`
      SELECT 
        SUM(CASE WHEN status = 'completed' THEN amount END) as total_revenue,
        COUNT(CASE WHEN status = 'pending' THEN 1 END) as pending_payments
      FROM payments
    `);
    
    // Get order stats
    const orderStats = await query(`
      SELECT COUNT(CASE WHEN status = 'active' THEN 1 END) as active_orders
      FROM orders
    `);
    
    // Get verification queue
    const verificationStats = await query(`
      SELECT COUNT(*) as verification_queue
      FROM handwerker
      WHERE verified = false OR verification_status = 'pending'
    `);
    
    const totalUsers = parseInt(userStats.rows[0].bauherren_count || 0) + 
                      parseInt(userStats.rows[0].handwerker_count || 0);
    
    res.json({
      totalUsers: totalUsers,
      totalProjects: parseInt(projectStats.rows[0].total_projects || 0),
      totalRevenue: parseFloat(paymentStats.rows[0].total_revenue || 0),
      activeOrders: parseInt(orderStats.rows[0].active_orders || 0),
      pendingPayments: parseInt(paymentStats.rows[0].pending_payments || 0),
      verificationQueue: parseInt(verificationStats.rows[0].verification_queue || 0)
    });
  } catch (err) {
    console.error('Failed to fetch stats:', err);
    res.status(500).json({ error: 'Failed to fetch statistics' });
  }
});

// ===========================================================================
// USER MANAGEMENT
// ===========================================================================

app.get('/api/admin/users', requireAdmin, async (req, res) => {
  try {
    // Bauherren - hat sowohl zip als auch zip_code
    const bauherrenResult = await query(`
      SELECT 
        b.id,
        b.name,
        b.email,
        b.phone,
        b.street,
        b.house_number,
        b.zip,  -- Verwende zip (existiert in der Tabelle)
        b.city,
        b.created_at,
        COUNT(DISTINCT p.id) as project_count
      FROM bauherren b
      LEFT JOIN projects p ON p.bauherr_id = b.id
      GROUP BY b.id
      ORDER BY b.created_at DESC
    `);
    
    // Handwerker - hat zip_code
    const handwerkerResult = await query(`
      SELECT 
        h.id,
        h.company_name,
        h.company_id,
        h.contact_person,
        h.email,
        h.phone,
        h.street,
        h.house_number,
        h.zip_code,  -- Korrekt: zip_code
        h.city,
        h.verified,
        h.verification_status,
        h.created_at,
        STRING_AGG(ht.trade_name, ', ' ORDER BY ht.trade_name) as trades
      FROM handwerker h
      LEFT JOIN handwerker_trades ht ON ht.handwerker_id = h.id
      GROUP BY h.id
      ORDER BY h.created_at DESC
    `);
    
    res.json({
      bauherren: bauherrenResult.rows,
      handwerker: handwerkerResult.rows
    });
  } catch (err) {
    console.error('Failed to fetch users:', err);
    res.status(500).json({ error: 'Failed to fetch users' });
  }
});

// Admin: Handwerker löschen
app.delete('/api/admin/handwerker/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    await query('BEGIN');
    
    // Zuerst contract_negotiations löschen (verweisen auf offers)
    await query(`
      DELETE FROM contract_negotiations 
      WHERE offer_id IN (SELECT id FROM offers WHERE handwerker_id = $1)
    `, [id]);
    
    // Alle Tabellen löschen, die direkt auf handwerker verweisen
    await query('DELETE FROM handwerker_insurances WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM handwerker_certifications WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM handwerker_references WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM email_logs WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM login_attempts WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM tender_handwerker WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM tender_tracking WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM tender_handwerker_status WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM offers WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM handwerker_trades WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM handwerker_documents WHERE handwerker_id = $1', [id]);
    await query('DELETE FROM orders WHERE handwerker_id = $1', [id]);
    
    // Zum Schluss Handwerker löschen
    await query('DELETE FROM handwerker WHERE id = $1', [id]);
    
    await query('COMMIT');
    
    res.json({ success: true, message: 'Handwerker gelöscht' });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error deleting handwerker:', error);
    res.status(500).json({ error: 'Fehler beim Löschen' });
  }
});

// Admin: Bauherr löschen
app.delete('/api/admin/bauherren/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    await query('BEGIN');
    
    // Hole alle Projekte des Bauherrn
    const projects = await query('SELECT id FROM projects WHERE bauherr_id = $1', [id]);
    
    for (const project of projects.rows) {
      const projectId = project.id;
      
      // Lösche alle tenders und deren abhängige Daten
      const tenders = await query('SELECT id FROM tenders WHERE project_id = $1', [projectId]);
      
      for (const tender of tenders.rows) {
        const tenderId = tender.id;
        
        // Lösche offers für diesen tender
        const offers = await query('SELECT id FROM offers WHERE tender_id = $1', [tenderId]);
        
        for (const offer of offers.rows) {
          // Lösche contract_negotiations für dieses offer
          await query('DELETE FROM contract_negotiations WHERE offer_id = $1', [offer.id]);
        }
        
        // Lösche offers
        await query('DELETE FROM offers WHERE tender_id = $1', [tenderId]);
        
        // Lösche tender_handwerker und tender_handwerker_status
        await query('DELETE FROM tender_handwerker WHERE tender_id = $1', [tenderId]);
        await query('DELETE FROM tender_handwerker_status WHERE tender_id = $1', [tenderId]);
        await query('DELETE FROM tender_tracking WHERE tender_id = $1', [tenderId]);
      }
      
      // WICHTIG: questions ZUERST löschen (vor project_trades!)
      await query('DELETE FROM questions WHERE project_id = $1', [projectId]);
      
      // Dann alle anderen project-abhängigen Daten
      await query('DELETE FROM answers WHERE project_id = $1', [projectId]);
      await query('DELETE FROM bundle_projects WHERE project_id = $1', [projectId]);
      await query('DELETE FROM intake_responses WHERE project_id = $1', [projectId]);
      await query('DELETE FROM lv_items WHERE project_id = $1', [projectId]);
      await query('DELETE FROM lv_snapshots WHERE project_id = $1', [projectId]);
      await query('DELETE FROM lvs WHERE project_id = $1', [projectId]);
      await query('DELETE FROM orders WHERE project_id = $1', [projectId]);
      await query('DELETE FROM payments WHERE project_id = $1', [projectId]);
      await query('DELETE FROM project_answers WHERE project_id = $1', [projectId]);
      await query('DELETE FROM project_logs WHERE project_id = $1', [projectId]);
      await query('DELETE FROM project_optimizations WHERE project_id = $1', [projectId]);
      await query('DELETE FROM project_trades WHERE project_id = $1', [projectId]);
      await query('DELETE FROM schedules WHERE project_id = $1', [projectId]);
      await query('DELETE FROM tenders WHERE project_id = $1', [projectId]);
      await query('DELETE FROM trade_optimizations WHERE project_id = $1', [projectId]);
      await query('DELETE FROM trade_progress WHERE project_id = $1', [projectId]);
    }
    
    // Lösche alle Projekte
    await query('DELETE FROM projects WHERE bauherr_id = $1', [id]);
    
    // Lösche email_logs
    await query('DELETE FROM email_logs WHERE bauherr_id = $1', [id]);
    
    // Lösche Bauherr
    await query('DELETE FROM bauherren WHERE id = $1', [id]);
    
    await query('COMMIT');
    
    res.json({ success: true, message: 'Bauherr gelöscht' });
    
  } catch (error) {
    await query('ROLLBACK');
    console.error('Error deleting bauherr:', error);
    res.status(500).json({ error: 'Fehler beim Löschen' });
  }
});

// ===========================================================================
// PROJECT MANAGEMENT
// ===========================================================================

app.get('/api/admin/projects', requireAdmin, async (req, res) => {
  try {
    const result = await query(`
      SELECT 
        p.id,
        p.category,
        p.sub_category,
        p.description,
        p.budget,
        p.timeframe,
        p.created_at,
        p.metadata,  -- Enthält vermutlich die Adressdaten
        b.name as bauherr_name,
        COUNT(DISTINCT pt.trade_id) as trade_count
      FROM projects p
      LEFT JOIN bauherren b ON b.id = p.bauherr_id
      LEFT JOIN project_trades pt ON pt.project_id = p.id
      GROUP BY p.id, b.name
      ORDER BY p.created_at DESC
    `);
    
    res.json({ projects: result.rows });
  } catch (err) {
    console.error('Failed to fetch projects:', err);
    res.status(500).json({ error: 'Failed to fetch projects' });
  }
});

// ===========================================================================
// PAYMENT MANAGEMENT
// ===========================================================================

app.get('/api/admin/payments', requireAdmin, async (req, res) => {
  try {
    // payments hat: id, project_id, amount, payment_type, status, stripe_payment_id, created_at
    const result = await query(`
      SELECT 
        p.id,
        p.project_id,
        p.amount,
        p.payment_type,
        p.status,
        p.stripe_payment_id,
        p.created_at,
        pr.description as project_description,
        pr.category as project_category,
        b.name as bauherr_name,
        b.email as bauherr_email
      FROM payments p
      LEFT JOIN projects pr ON pr.id = p.project_id
      LEFT JOIN bauherren b ON b.id = pr.bauherr_id
      ORDER BY p.created_at DESC
    `);
    
    res.json({ payments: result.rows });
  } catch (err) {
    console.error('Failed to fetch payments:', err);
    res.status(500).json({ error: 'Failed to fetch payments' });
  }
});

app.put('/api/admin/payments/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    
    const result = await query(
      `UPDATE payments 
       SET status = $1  -- KEIN updated_at, da Spalte nicht existiert
       WHERE id = $2
       RETURNING *`,
      [status, id]
    );
    
    res.json({ payment: result.rows[0] });
  } catch (err) {
    console.error('Failed to update payment:', err);
    res.status(500).json({ error: 'Failed to update payment' });
  }
});

// ===========================================================================
// VERIFICATION MANAGEMENT
// ===========================================================================

app.get('/api/admin/verifications', requireAdmin, async (req, res) => {
  try {
    const result = await query(`
      SELECT 
        h.id,
        h.company_name,
        h.email,
        h.phone,
        h.street,
        h.house_number,
        h.zip_code,
        h.city,
        h.verified,
        h.created_at,
        STRING_AGG(t.name, ', ' ORDER BY t.name) as trades,
        ARRAY_AGG(
          json_build_object(
            'type', 'Gewerbeschein',
            'url', h.gewerbeschein_url
          )
        ) as documents
      FROM handwerker h
      LEFT JOIN handwerker_trades ht ON ht.handwerker_id = h.id
      LEFT JOIN trades t ON t.id = ht.trade_id
      WHERE h.verified = false
      GROUP BY h.id
      ORDER BY h.created_at DESC
    `);
    
    res.json({ verifications: result.rows });
  } catch (err) {
    console.error('Failed to fetch verifications:', err);
    res.status(500).json({ error: 'Failed to fetch verifications' });
  }
});

app.put('/api/admin/verifications/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { approved } = req.body;
    
    const result = await query(
      `UPDATE handwerker 
       SET verified = $1, updated_at = NOW()
       WHERE id = $2
       RETURNING *`,
      [approved, id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Handwerker not found' });
    }
    
    res.json({ handwerker: result.rows[0] });
  } catch (err) {
    console.error('Failed to update verification:', err);
    res.status(500).json({ error: 'Failed to update verification' });
  }
});

// ===========================================================================
// ORDER MANAGEMENT
// ===========================================================================

app.get('/api/admin/orders', requireAdmin, async (req, res) => {
  try {
    // orders hat: id, offer_id, project_id, handwerker_id, status, progress, is_bundle, created_at, trade_id
    const result = await query(`
      SELECT 
        o.id,
        o.offer_id,
        o.project_id,
        o.handwerker_id,
        o.status,
        o.progress,
        o.is_bundle,
        o.created_at,
        o.trade_id,
        pr.description as project_description,
        h.company_name as handwerker_name,
        t.name as trade_name,
        of.amount as total  -- Hole amount aus offers Tabelle
      FROM orders o
      LEFT JOIN projects pr ON pr.id = o.project_id
      LEFT JOIN handwerker h ON h.id = o.handwerker_id
      LEFT JOIN trades t ON t.id = o.trade_id
      LEFT JOIN offers of ON of.id = o.offer_id
      ORDER BY o.created_at DESC
    `);
    
    res.json({ orders: result.rows });
  } catch (err) {
    console.error('Failed to fetch orders:', err);
    res.status(500).json({ error: 'Failed to fetch orders' });
  }
});

// ===========================================================================
// TENDER MANAGEMENT
// ===========================================================================

app.get('/api/admin/tenders', requireAdmin, async (req, res) => {
  try {
    // Da tenders nicht in der Liste war, prüfen wir ob sie existiert
    const tableCheck = await query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'tenders'
      )
    `);
    
    if (!tableCheck.rows[0].exists) {
      // Erstelle tenders Tabelle
      await query(`
        CREATE TABLE tenders (
          id SERIAL PRIMARY KEY,
          project_id INTEGER REFERENCES projects(id),
          trade_id INTEGER REFERENCES trades(id),
          trade_code VARCHAR(10),
          status VARCHAR(50) DEFAULT 'open',
          deadline TIMESTAMP,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
      `);
      console.log('Created tenders table');
    }
    
    // Hole tenders mit offers count
    const result = await query(`
      SELECT 
        t.id,
        t.project_id,
        t.trade_id,
        t.trade_code,
        t.status,
        t.deadline,
        t.created_at,
        pr.description as project_description,
        tr.name as trade_name,
        COUNT(o.id) as offer_count
      FROM tenders t
      LEFT JOIN projects pr ON pr.id = t.project_id
      LEFT JOIN trades tr ON tr.id = t.trade_id OR tr.code = t.trade_code
      LEFT JOIN offers o ON o.tender_id = t.id
      GROUP BY t.id, pr.description, tr.name
      ORDER BY t.created_at DESC
    `);
    
    res.json({ tenders: result.rows });
  } catch (err) {
    console.error('Failed to fetch tenders:', err);
    res.status(500).json({ error: 'Failed to fetch tenders' });
  }
});

// ===========================================================================
// SUPPLEMENT MANAGEMENT
// ===========================================================================

app.get('/api/admin/supplements', requireAdmin, async (req, res) => {
  try {
    const result = await query(`
      SELECT 
        s.id,
        s.order_id,
        s.reason,
        s.amount,
        s.status,
        s.created_at
      FROM supplements s
      ORDER BY s.created_at DESC
    `);
    
    res.json({ supplements: result.rows });
  } catch (err) {
    console.error('Failed to fetch supplements:', err);
    res.status(500).json({ error: 'Failed to fetch supplements' });
  }
});

// Pending Handwerker abrufen
app.get('/api/admin/pending-handwerker', requireAdmin, async (req, res) => {
  try {
    // Nutze verification_status oder verified=false
    const result = await query(`
      SELECT 
        h.id,
        h.company_name,
        h.company_id,
        h.contact_person,
        h.email,
        h.phone,
        h.street,
        h.house_number,
        h.zip_code,
        h.city,
        h.created_at,
        h.verified,
        h.verification_status,
        array_agg(DISTINCT ht.trade_code) as trades,
        array_agg(DISTINCT ht.trade_name) as trade_names
      FROM handwerker h
      LEFT JOIN handwerker_trades ht ON h.id = ht.handwerker_id
      WHERE h.verified = false OR h.verification_status = 'pending'
      GROUP BY h.id
      ORDER BY h.created_at DESC
    `);
    
    res.json(result.rows);
  } catch (err) {
    console.error('Error fetching pending handwerker:', err);
    res.status(500).json({ error: 'Fehler beim Laden' });
  }
});

// Handwerker verifizieren, ablehnen oder löschen
// Diese Route ersetzt die komplette app.post('/api/admin/verify-handwerker/:id' Route in server.js
app.post('/api/admin/verify-handwerker/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { action, reason } = req.body; // action: 'approve', 'reject', 'delete'
    
    // Hole Handwerker-Details
    const handwerkerResult = await query(
      `SELECT company_name, contact_person, email, company_id 
       FROM handwerker 
       WHERE id = $1`,
      [id]
    );
    
    if (handwerkerResult.rows.length === 0) {
      return res.status(404).json({ error: 'Handwerker nicht gefunden' });
    }
    
    const handwerker = handwerkerResult.rows[0];
    
    switch(action) {
      case 'approve':
        // === GENEHMIGUNG ===
        let finalId = handwerker.company_id;
        
        if (!finalId || finalId === 'PENDING') {
          const year = new Date().getFullYear();
          const random = Math.floor(Math.random() * 9000) + 1000;
          finalId = `HW-${year}-${random}`;
        }
        
        await query(
          `UPDATE handwerker 
           SET verified = true,
               verification_status = 'verified',
               company_id = $2,
               verified_at = NOW(),
               rejection_reason = NULL
           WHERE id = $1`,
          [id, finalId]
        );
        
        // Bestätigungs-E-Mail
        if (transporter) {
          try {
            await transporter.sendMail({
              to: handwerker.email,
              subject: 'Ihre Registrierung bei byndl wurde bestätigt',
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px;">
                  <h2 style="color: #14b8a6;">Willkommen bei byndl!</h2>
                  <p>Sehr geehrte/r ${handwerker.contact_person},</p>
                  <p>Ihre Registrierung für <strong>${handwerker.company_name}</strong> wurde erfolgreich verifiziert.</p>
                  <p><strong>Ihre Handwerker-ID:</strong> ${finalId}</p>
                  <p>Sie können sich nun in Ihr Dashboard einloggen und auf Ausschreibungen zugreifen.</p>
                  <a href="https://byndl.de/handwerker/login" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background-color: #14b8a6; color: white; text-decoration: none; border-radius: 6px;">Zum Dashboard</a>
                </div>
              `
            });
            console.log(`Bestätigungs-E-Mail gesendet an: ${handwerker.email}`);
          } catch (emailError) {
            console.log('E-Mail-Versand fehlgeschlagen:', emailError.message);
          }
        }
        
        console.log(`Handwerker ${id} (${handwerker.company_name}) genehmigt mit ID: ${finalId}`);
        res.json({ 
          success: true, 
          message: 'Handwerker erfolgreich verifiziert',
          handwerkerId: finalId
        });
        break;
        
      case 'reject':
        // === ABLEHNUNG MIT BEGRÜNDUNG (NICHT LÖSCHEN) ===
        if (!reason || reason.trim() === '') {
          return res.status(400).json({ error: 'Begründung für Ablehnung erforderlich' });
        }
        
        await query(
          `UPDATE handwerker 
           SET verified = false,
               verification_status = 'rejected',
               rejection_reason = $2
           WHERE id = $1`,
          [id, reason]
        );
        
        // Ablehnungs-E-Mail mit Begründung
        if (transporter) {
          try {
            await transporter.sendMail({
              to: handwerker.email,
              subject: 'Ihre Registrierung bei byndl - Nachbesserung erforderlich',
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px;">
                  <h2 style="color: #dc2626;">Nachbesserung erforderlich</h2>
                  <p>Sehr geehrte/r ${handwerker.contact_person},</p>
                  <p>Ihre Registrierung für <strong>${handwerker.company_name}</strong> konnte noch nicht genehmigt werden.</p>
                  
                  <div style="background-color: #fef2f2; padding: 20px; border-radius: 8px; margin: 20px 0;">
                    <p><strong>Grund:</strong></p>
                    <p>${reason}</p>
                  </div>
                  
                  <h3>Was können Sie tun?</h3>
                  <p>Bitte beheben Sie die genannten Punkte und ergänzen Sie Ihre Unterlagen entsprechend. 
                     Sie können die fehlenden Dokumente in Ihrem Dashboard hochladen.</p>
                  
                  <a href="https://byndl.de/handwerker/login" style="display: inline-block; margin-top: 20px; padding: 12px 24px; background-color: #14b8a6; color: white; text-decoration: none; border-radius: 6px;">Zum Dashboard</a>
                  
                  <p style="margin-top: 30px; color: #666;">Bei Fragen wenden Sie sich an: verifizierung@byndl.de</p>
                </div>
              `
            });
            console.log(`Ablehnungs-E-Mail gesendet an: ${handwerker.email}`);
          } catch (emailError) {
            console.log('E-Mail-Versand fehlgeschlagen:', emailError.message);
          }
        }
        
        console.log(`Handwerker ${id} (${handwerker.company_name}) abgelehnt. Grund: ${reason}`);
        res.json({ 
          success: true, 
          message: 'Handwerker wurde zur Nachbesserung aufgefordert',
          reason: reason
        });
        break;
        
      case 'delete':
        // === VOLLSTÄNDIGE LÖSCHUNG (NUR BEI VÖLLIG UNGEEIGNET) ===
        console.log(`LÖSCHE Handwerker ${id} (${handwerker.company_name}) vollständig...`);
        
        // Lösche alle abhängigen Einträge
        await query('DELETE FROM handwerker_trades WHERE handwerker_id = $1', [id])
          .catch(() => {});
        await query('DELETE FROM handwerker_documents WHERE handwerker_id = $1', [id])
          .catch(() => {});
        await query('DELETE FROM handwerker_certifications WHERE handwerker_id = $1', [id])
          .catch(() => {});
        await query('DELETE FROM handwerker_insurances WHERE handwerker_id = $1', [id])
          .catch(() => {});
        await query('DELETE FROM offers WHERE handwerker_id = $1', [id])
          .catch(() => {});
        await query('DELETE FROM orders WHERE handwerker_id = $1', [id])
          .catch(() => {});
        
        // Lösche den Handwerker selbst
        await query('DELETE FROM handwerker WHERE id = $1', [id]);
        
        // Lösch-E-Mail
        if (transporter) {
          try {
            await transporter.sendMail({
              to: handwerker.email,
              subject: 'Ihre Registrierung bei byndl wurde abgelehnt',
              html: `
                <div style="font-family: Arial, sans-serif; max-width: 600px;">
                  <h2 style="color: #dc2626;">Registrierung abgelehnt</h2>
                  <p>Sehr geehrte/r ${handwerker.contact_person},</p>
                  <p>Ihre Registrierung für <strong>${handwerker.company_name}</strong> wurde abgelehnt.</p>
                  ${reason ? `
                    <div style="background-color: #fef2f2; padding: 20px; border-radius: 8px; margin: 20px 0;">
                      <p><strong>Grund:</strong> ${reason}</p>
                    </div>
                  ` : ''}
                  <p>Ihre Daten wurden aus unserem System entfernt.</p>
                  <p style="margin-top: 30px; color: #666;">Bei Fragen wenden Sie sich an: support@byndl.de</p>
                </div>
              `
            });
          } catch (emailError) {
            console.log('E-Mail-Versand fehlgeschlagen:', emailError.message);
          }
        }
        
        console.log(`✓ Handwerker ${handwerker.company_name} vollständig gelöscht`);
        res.json({ 
          success: true, 
          message: 'Handwerker vollständig aus dem System entfernt',
          deletedCompany: handwerker.company_name
        });
        break;
        
      default:
        return res.status(400).json({ error: 'Ungültige Aktion. Verwende: approve, reject oder delete' });
    }
    
  } catch (err) {
    console.error('Fehler bei Handwerker-Verifizierung:', err);
    res.status(500).json({ 
      error: 'Verifizierung fehlgeschlagen',
      details: err.message 
    });
  }
});

// Einzelnen Handwerker abrufen
app.get('/api/admin/handwerker/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Hauptdaten
    const handwerkerResult = await query(
      `SELECT * FROM handwerker WHERE id = $1`,
      [id]
    );
    
    if (handwerkerResult.rows.length === 0) {
      return res.status(404).json({ error: 'Handwerker nicht gefunden' });
    }
    
    // Gewerke
    const tradesResult = await query(
      `SELECT * FROM handwerker_trades WHERE handwerker_id = $1`,
      [id]
    );
    
    // Dokumente
    const documentsResult = await query(
      `SELECT * FROM handwerker_documents WHERE handwerker_id = $1`,
      [id]
    );
    
    // Zertifikate
    const certificationsResult = await query(
      `SELECT * FROM handwerker_certifications WHERE handwerker_id = $1`,
      [id]
    );
    
    // Versicherungen
    const insurancesResult = await query(
      `SELECT * FROM handwerker_insurances WHERE handwerker_id = $1`,
      [id]
    );
    
    res.json({
      handwerker: handwerkerResult.rows[0],
      trades: tradesResult.rows,
      documents: documentsResult.rows,
      certifications: certificationsResult.rows,
      insurances: insurancesResult.rows
    });
  } catch (err) {
    console.error('Failed to fetch handwerker details:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Details' });
  }
});

// Handwerker aktualisieren
app.put('/api/admin/handwerker/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    // Dynamisch UPDATE Query bauen
    const fields = [];
    const values = [];
    let paramCount = 1;
    
    for (const [key, value] of Object.entries(updates)) {
      if (key !== 'id' && key !== 'created_at') {
        fields.push(`${key} = $${paramCount}`);
        values.push(value);
        paramCount++;
      }
    }
    
    values.push(id);
    
    const updateQuery = `
      UPDATE handwerker 
      SET ${fields.join(', ')}
      WHERE id = $${paramCount}
      RETURNING *
    `;
    
    const result = await query(updateQuery, values);
    
    res.json({ handwerker: result.rows[0] });
  } catch (err) {
    console.error('Failed to update handwerker:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// Einzelnen Bauherr abrufen
app.get('/api/admin/bauherren/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    const bauherrResult = await query(
      `SELECT b.*, 
        COUNT(DISTINCT p.id) as project_count,
        SUM(p.budget) as total_budget
       FROM bauherren b
       LEFT JOIN projects p ON p.bauherr_id = b.id
       WHERE b.id = $1
       GROUP BY b.id`,
      [id]
    );
    
    if (bauherrResult.rows.length === 0) {
      return res.status(404).json({ error: 'Bauherr nicht gefunden' });
    }
    
    // Projekte des Bauherrn
    const projectsResult = await query(
      `SELECT * FROM projects WHERE bauherr_id = $1 ORDER BY created_at DESC`,
      [id]
    );
    
    res.json({
      bauherr: bauherrResult.rows[0],
      projects: projectsResult.rows
    });
  } catch (err) {
    console.error('Failed to fetch bauherr details:', err);
    res.status(500).json({ error: 'Fehler beim Laden der Details' });
  }
});

// Bauherr aktualisieren
app.put('/api/admin/bauherren/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const updates = req.body;
    
    const fields = [];
    const values = [];
    let paramCount = 1;
    
    for (const [key, value] of Object.entries(updates)) {
  // Filtere berechnete Felder und schreibgeschützte Felder aus
  if (key !== 'id' && 
      key !== 'created_at' && 
      key !== 'project_count' && 
      key !== 'total_budget') {
    fields.push(`${key} = $${paramCount}`);
    values.push(value);
    paramCount++;
  }
}
    
    values.push(id);
    
    const updateQuery = `
      UPDATE bauherren 
      SET ${fields.join(', ')}
      WHERE id = $${paramCount}
      RETURNING *
    `;
    
    const result = await query(updateQuery, values);
    
    res.json({ bauherr: result.rows[0] });
  } catch (err) {
    console.error('Failed to update bauherr:', err);
    res.status(500).json({ error: 'Update fehlgeschlagen' });
  }
});

// ===========================================================================
// EXISTING ROUTES (from your original code)
// ===========================================================================

// Get all prompts with full content for editing
app.get('/api/admin/prompts/full', requireAdmin, async (req, res) => {
  try {
    const result = await query(
      `SELECT p.*, t.name as trade_name, t.code as trade_code 
       FROM prompts p 
       LEFT JOIN trades t ON t.id = p.trade_id 
       ORDER BY p.type, t.sort_order, p.name`
    );
    
    res.json({ prompts: result.rows });
  } catch (err) {
    console.error('Failed to fetch prompts:', err);
    res.status(500).json({ error: 'Failed to fetch prompts' });
  }
});

// Update prompt content
app.put('/api/admin/prompts/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    const { content, name } = req.body;
    
    if (!content) {
      return res.status(400).json({ error: 'Content is required' });
    }

    const result = await query(
      `UPDATE prompts 
       SET content = $1, name = $2, updated_at = NOW()
       WHERE id = $3
       RETURNING *`,
      [content, name || null, id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Prompt not found' });
    }

    res.json({ prompt: result.rows[0] });
  } catch (err) {
    console.error('Failed to update prompt:', err);
    res.status(500).json({ error: 'Failed to update prompt' });
  }
});

// Get all LVs with quality metrics - FIXED CAST
app.get('/api/admin/lvs', requireAdmin, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 100;
    const offset = parseInt(req.query.offset) || 0;
    
    const result = await query(
      `SELECT 
        l.*,
        t.name as trade_name,
        t.code as trade_code,
        p.description as project_description,
        p.budget,
        p.category,
        CASE 
          WHEN l.content->>'totalSum' IS NOT NULL 
          THEN (l.content->>'totalSum')::numeric 
          ELSE NULL 
        END as total_sum,
        CASE 
          WHEN l.content->'positions' IS NOT NULL 
          THEN jsonb_array_length(l.content->'positions') 
          ELSE 0 
        END as position_count
       FROM lvs l
       JOIN trades t ON t.id = l.trade_id
       JOIN projects p ON p.id = l.project_id
       ORDER BY l.created_at DESC
       LIMIT $1 OFFSET $2`,
      [limit, offset]
    );
    
    // Calculate quality metrics with error handling
    const lvs = result.rows.map(lv => {
      try {
        const content = typeof lv.content === 'string' ? JSON.parse(lv.content) : lv.content;
        let qualityScore = 100;
        const issues = [];
        
        // Check for common issues
        if (!content || !content.positions || content.positions.length === 0) {
          qualityScore -= 50;
          issues.push('Keine Positionen');
        }
        
        if (content && content.positions && Array.isArray(content.positions)) {
          const invalidPrices = content.positions.filter(p => !p.unitPrice || p.unitPrice <= 0);
          if (invalidPrices.length > 0) {
            qualityScore -= 20;
            issues.push(`${invalidPrices.length} Positionen ohne Preis`);
          }
          
          const missingDescriptions = content.positions.filter(p => !p.description);
          if (missingDescriptions.length > 0) {
            qualityScore -= 10;
            issues.push(`${missingDescriptions.length} Positionen ohne Beschreibung`);
          }
        }
        
        return {
          ...lv,
          content,
          qualityScore: Math.max(0, qualityScore),
          issues
        };
      } catch (parseError) {
        console.error(`Error parsing LV content for ID ${lv.project_id}-${lv.trade_id}:`, parseError);
        return {
          ...lv,
          content: lv.content,
          qualityScore: 0,
          issues: ['Fehler beim Parsen des Inhalts']
        };
      }
    });

    res.json({ lvs });
  } catch (err) {
    console.error('Failed to fetch LVs:', err);
    res.status(500).json({ error: 'Failed to fetch LVs' });
  }
});

// Update LV content (for price corrections)
app.put('/api/admin/lvs/:projectId/:tradeId', requireAdmin, async (req, res) => {
  try {
    const { projectId, tradeId } = req.params;
    const { content } = req.body;
    
    if (!content || typeof content !== 'object') {
      return res.status(400).json({ error: 'Valid content object is required' });
    }
    
    const result = await query(
      `UPDATE lvs 
       SET content = $1::jsonb, updated_at = NOW()
       WHERE project_id = $2 AND trade_id = $3
       RETURNING *`,
      [JSON.stringify(content), projectId, tradeId]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'LV not found' });
    }

    res.json({ lv: result.rows[0] });
  } catch (err) {
    console.error('Failed to update LV:', err);
    res.status(500).json({ error: 'Failed to update LV' });
  }
});

// Get detailed project analytics - FIXED CASTS
app.get('/api/admin/analytics', requireAdmin, async (req, res) => {
  try {
    // Project statistics
    const projectStats = await query(
      `SELECT 
        COUNT(*) as total_projects,
        COUNT(CASE WHEN created_at > NOW() - INTERVAL '7 days' THEN 1 END) as last_week,
        COUNT(CASE WHEN created_at > NOW() - INTERVAL '30 days' THEN 1 END) as last_month,
        AVG(CASE WHEN budget IS NOT NULL THEN budget END) as avg_budget
       FROM projects`
    );
    
    // Trade usage statistics - FIXED CAST
    const tradeStats = await query(`
      SELECT 
        t.code,
        t.name,
        COUNT(DISTINCT pt.project_id) as usage_count,
        COUNT(DISTINCT l.id) as lv_count,
        AVG(
          CASE 
            WHEN l.content->>'totalSum' IS NOT NULL 
            THEN (l.content->>'totalSum')::numeric 
            ELSE NULL 
          END
        ) as avg_lv_value
      FROM trades t
      LEFT JOIN project_trades pt ON pt.trade_id = t.id
      LEFT JOIN lvs l ON l.trade_id = t.id
      GROUP BY t.id, t.code, t.name
      ORDER BY usage_count DESC
    `);

    // Prompt effectiveness - FIXED CASTS
    const promptStats = await query(`
      SELECT 
        p.id,
        p.name,
        p.type,
        t.name as trade_name,
        COUNT(l.id) as usage_count,
        AVG(
          CASE 
            WHEN l.content->>'totalSum' IS NOT NULL 
            THEN (l.content->>'totalSum')::numeric 
            ELSE NULL 
          END
        ) as avg_lv_value,
        AVG(
          CASE 
            WHEN l.content->'positions' IS NOT NULL 
            THEN jsonb_array_length(l.content->'positions') 
            ELSE 0 
          END
        ) as avg_position_count
      FROM prompts p
      LEFT JOIN trades t ON t.id = p.trade_id
      LEFT JOIN lvs l ON l.trade_id = p.trade_id
      WHERE p.type IN ('questions', 'lv')
      GROUP BY p.id, p.name, p.type, t.name
      ORDER BY usage_count DESC
    `);

    // Question/Answer completion rates
    const completionStats = await query(`
      SELECT 
        t.name as trade_name,
        COUNT(DISTINCT q.question_id) as total_questions,
        COUNT(DISTINCT a.question_id) as answered_questions,
        CASE 
          WHEN COUNT(DISTINCT q.question_id) > 0 
          THEN ROUND((COUNT(DISTINCT a.question_id)::float / COUNT(DISTINCT q.question_id) * 100)::numeric, 2)
          ELSE 0 
        END as completion_rate
      FROM trades t
      LEFT JOIN questions q ON q.trade_id = t.id
      LEFT JOIN answers a ON a.trade_id = t.id AND a.question_id = q.question_id
      GROUP BY t.id, t.name
      ORDER BY completion_rate DESC
    `);

    res.json({
      projects: projectStats.rows[0],
      trades: tradeStats.rows,
      prompts: promptStats.rows,
      completion: completionStats.rows
    });
  } catch (err) {
    console.error('Failed to fetch analytics:', err);
    res.status(500).json({ error: 'Failed to fetch analytics' });
  }
});

// Get all projects with full details
app.get('/api/admin/projects/detailed', requireAdmin, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50;
    const offset = parseInt(req.query.offset) || 0;
    
    const result = await query(
      `SELECT 
        p.*,
        COUNT(DISTINCT pt.trade_id) as trade_count,
        COUNT(DISTINCT q.question_id) as question_count,
        COUNT(DISTINCT a.question_id) as answer_count,
        COUNT(DISTINCT l.id) as lv_count,
        STRING_AGG(DISTINCT t.name, ', ' ORDER BY t.name) as trade_names
       FROM projects p
       LEFT JOIN project_trades pt ON pt.project_id = p.id
       LEFT JOIN trades t ON t.id = pt.trade_id
       LEFT JOIN questions q ON q.project_id = p.id
       LEFT JOIN answers a ON a.project_id = p.id
       LEFT JOIN lvs l ON l.project_id = p.id
       GROUP BY p.id
       ORDER BY p.created_at DESC
       LIMIT $1 OFFSET $2`,
      [limit, offset]
    );

    res.json({ projects: result.rows });
  } catch (err) {
    console.error('Failed to fetch projects:', err);
    res.status(500).json({ error: 'Failed to fetch projects' });
  }
});

// Get specific project with all Q&A
app.get('/api/admin/projects/:id/full', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    // Get project
    const projectResult = await query('SELECT * FROM projects WHERE id = $1', [id]);
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }

    const project = projectResult.rows[0];

    // Get trades with Q&A
    const tradesResult = await query(
      `SELECT 
        t.*, 
        pt.created_at as assigned_at
       FROM trades t
       JOIN project_trades pt ON pt.trade_id = t.id
       WHERE pt.project_id = $1
       ORDER BY
         CASE WHEN COALESCE(pt.is_manual, false) THEN 1 ELSE 0 END,
         t.sort_order,
         t.id`,
      [id]
    );

    // Get all questions and answers
    const qaResult = await query(
      `SELECT 
        q.*,
        a.answer_text,
        a.assumption,
        t.name as trade_name,
        t.code as trade_code
       FROM questions q
       LEFT JOIN answers a ON a.project_id = q.project_id 
         AND a.trade_id = q.trade_id 
         AND a.question_id = q.question_id
       JOIN trades t ON t.id = q.trade_id
       WHERE q.project_id = $1
       ORDER BY t.sort_order, q.question_id`,
      [id]
    );

    // Get Intake-Fragen aus intake_responses
    const intakeResult = await query(
      `SELECT 
        question_text,
        answer_text,
        created_at
       FROM intake_responses
       WHERE project_id = $1
       ORDER BY created_at ASC`,
      [id]
    );

    // Get Gewerke-Antworten mit Fragen aus der questions Tabelle
    const answersResult = await query(
      `SELECT 
        t.name as trade_name,
        t.code as trade_code,
        q.text as question_text,
        a.answer_text,
        a.assumption,
        a.created_at
       FROM answers a
       JOIN trades t ON t.id = a.trade_id
       LEFT JOIN questions q ON q.project_id = a.project_id 
         AND q.trade_id = a.trade_id 
         AND q.question_id = a.question_id
       WHERE a.project_id = $1
       ORDER BY t.sort_order, a.created_at`,
      [id]
    );

    // Get LVs
    const lvsResult = await query(
      `SELECT 
        l.*,
        t.name as trade_name,
        t.code as trade_code
       FROM lvs l
       JOIN trades t ON t.id = l.trade_id
       WHERE l.project_id = $1`,
      [id]
    );

    res.json({
      project,
      trades: tradesResult.rows,
      questionsAnswers: qaResult.rows,
      intakeQuestions: intakeResult.rows,
      tradeAnswers: answersResult.rows,
      totalQuestions: intakeResult.rows.length + answersResult.rows.length,
      lvs: lvsResult.rows.map(lv => {
        try {
          return {
            ...lv,
            content: typeof lv.content === 'string' ? JSON.parse(lv.content) : lv.content
          };
        } catch (e) {
          console.error(`Error parsing LV content for project ${lv.project_id}, trade ${lv.trade_id}:`, e);
          return lv;
        }
      })
    });
    
  } catch (err) {
    console.error('Failed to fetch project details:', err);
    res.status(500).json({ error: 'Failed to fetch project details' });
  }
});

// Admin: Projekt löschen - FINALE VERSION
app.delete('/api/admin/projects/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`Starte Löschvorgang für Projekt ${id}`);
    
    await query('BEGIN');
    
    try {
      // Test ob Projekt existiert
      const projectCheck = await query('SELECT id FROM projects WHERE id = $1', [id]);
      if (projectCheck.rows.length === 0) {
        throw new Error('Projekt nicht gefunden');
      }
      
      // 1. Direkte Projekt-Abhängigkeiten löschen
      await query('DELETE FROM intake_responses WHERE project_id = $1', [id]);
      await query('DELETE FROM questions WHERE project_id = $1', [id]);
      await query('DELETE FROM answers WHERE project_id = $1', [id]);
      await query('DELETE FROM project_trades WHERE project_id = $1', [id]);
      await query('DELETE FROM lvs WHERE project_id = $1', [id]);
      await query('DELETE FROM trade_progress WHERE project_id = $1', [id]);
      await query('DELETE FROM payments WHERE project_id = $1', [id]);
      
      // 2. Offers über tenders finden und löschen
      // Zuerst alle tender IDs für dieses Projekt holen
      const tenders = await query('SELECT id FROM tenders WHERE project_id = $1', [id]);
      
      for (const tender of tenders.rows) {
        // Alle offers für diesen tender
        const offers = await query('SELECT id FROM offers WHERE tender_id = $1', [tender.id]);
        
        for (const offer of offers.rows) {
          // Contract negotiations löschen
          await query('DELETE FROM contract_negotiations WHERE offer_id = $1', [offer.id]);
          
          // Orders und supplements
          const orders = await query('SELECT id FROM orders WHERE offer_id = $1', [offer.id]);
          for (const order of orders.rows) {
            await query('DELETE FROM supplements WHERE order_id = $1', [order.id]);
          }
          
          // Orders löschen
          await query('DELETE FROM orders WHERE offer_id = $1', [offer.id]);
          
          // Offer selbst löschen
          await query('DELETE FROM offers WHERE id = $1', [offer.id]);
        }
      }
      
      // 3. Jetzt tenders löschen (nachdem offers gelöscht wurden)
      await query('DELETE FROM tenders WHERE project_id = $1', [id]);
      
      // 4. Falls orders auch direkt project_id haben (prüfen)
      const ordersCheck = await query(`
        SELECT column_name 
        FROM information_schema.columns 
        WHERE table_name = 'orders' 
        AND column_name = 'project_id'
      `);
      
      if (ordersCheck.rows.length > 0) {
        await query('DELETE FROM orders WHERE project_id = $1', [id]);
      }
      
      // 5. Projekt selbst löschen
      await query('DELETE FROM projects WHERE id = $1', [id]);
      
      await query('COMMIT');
      
      console.log(`Projekt ${id} erfolgreich gelöscht`);
      res.json({ success: true, message: 'Projekt erfolgreich gelöscht' });
      
    } catch (error) {
      await query('ROLLBACK');
      throw error;
    }
    
  } catch (error) {
    console.error('Error deleting project:', error);
    res.status(500).json({ 
      error: 'Fehler beim Löschen des Projekts', 
      details: error.message 
    });
  }
});

// Create new prompt
app.post('/api/admin/prompts', requireAdmin, async (req, res) => {
  try {
    const { name, type, trade_id, content } = req.body;
    
    if (!name || !type || !content) {
      return res.status(400).json({ error: 'Name, type and content are required' });
    }

    const result = await query(
      `INSERT INTO prompts (name, type, trade_id, content)
       VALUES ($1, $2, $3, $4)
       RETURNING *`,
      [name, type, trade_id || null, content]
    );

    res.json({ prompt: result.rows[0] });
  } catch (err) {
    console.error('Failed to create prompt:', err);
    res.status(500).json({ error: 'Failed to create prompt' });
  }
});

// Delete prompt
app.delete('/api/admin/prompts/:id', requireAdmin, async (req, res) => {
  try {
    const { id } = req.params;
    
    const result = await query(
      'DELETE FROM prompts WHERE id = $1 RETURNING *',
      [id]
    );

    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Prompt not found' });
    }

    res.json({ message: 'Prompt deleted successfully' });
  } catch (err) {
    console.error('Failed to delete prompt:', err);
    res.status(500).json({ error: 'Failed to delete prompt' });
  }
});

// Health check endpoint
app.get('/api/admin/health', requireAdmin, async (req, res) => {
  try {
    // Check database connection
    await query('SELECT 1');
    
    res.json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      sessions: activeSessions.size
    });
  } catch (err) {
    res.status(503).json({
      status: 'unhealthy',
      error: 'Database connection failed'
    });
  }
});

// Clean up expired tokens periodically (every hour)
setInterval(() => {
  const oneDayAgo = Date.now() - (24 * 60 * 60 * 1000);
  let cleaned = 0;
  
  for (const [token, session] of activeSessions.entries()) {
    if (session.createdAt < oneDayAgo) {
      activeSessions.delete(token);
      cleaned++;
    }
  }
  
  if (cleaned > 0) {
    console.log(`Cleaned up ${cleaned} expired admin sessions`);
  }
}, 60 * 60 * 1000); // Run every hour

// ===========================================================================
// PUBLIC PROMPT ROUTES
// ===========================================================================

// Get all prompts with details
app.get('/api/prompts', async (req, res) => {
  try {
    const result = await query(
      `SELECT p.id, p.name, p.type, p.trade_id,
              t.name as trade_name, t.code as trade_code,
              LENGTH(p.content) as content_length,
              p.updated_at
       FROM prompts p
       LEFT JOIN trades t ON t.id = p.trade_id
       ORDER BY p.type, t.name`
    );
    
    res.json({ 
      prompts: result.rows,
      stats: {
        total: result.rows.length,
        master: result.rows.filter(p => p.type === 'master').length,
        questions: result.rows.filter(p => p.type === 'questions').length,
        lv: result.rows.filter(p => p.type === 'lv').length
      }
    });
    
  } catch (err) {
    console.error('Failed to fetch prompts:', err);
    res.status(500).json({ error: 'Failed to fetch prompts' });
  }
});

// Get single prompt with content
app.get('/api/prompts/:id', async (req, res) => {
  try {
    const { id } = req.params;
    const result = await query(
      `SELECT p.*, t.name as trade_name, t.code as trade_code
       FROM prompts p
       LEFT JOIN trades t ON t.id = p.trade_id
       WHERE p.id = $1`,
      [id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ error: 'Prompt not found' });
    }
    
    res.json(result.rows[0]);
    
  } catch (err) {
    console.error('Failed to fetch prompt:', err);
    res.status(500).json({ error: 'Failed to fetch prompt' });
  }
});

// ===========================================================================
// TEST & DEBUG ENDPOINTS
// ===========================================================================

// Test OpenAI
app.get('/api/test/openai', async (req, res) => {
  try {
    const response = await openai.chat.completions.create({
      model: MODEL_OPENAI,
      messages: [{ role: 'user', content: 'Say "OpenAI is working"' }],
      max_completion_tokens: 20
    });
    res.json({ 
      status: 'ok',
      response: response.choices[0].message.content 
    });
  } catch (err) {
    res.status(500).json({ 
      status: 'error',
      error: err.message 
    });
  }
});

// Test beide Anthropic Modelle
app.get('/api/test/anthropic/:type', async (req, res) => {
  try {
    const { type } = req.params;
    const testModel = type === 'lv' 
      ? MODEL_ANTHROPIC_LV 
      : MODEL_ANTHROPIC_QUESTIONS;
      
    const response = await anthropic.messages.create({
      model: testModel,
      max_tokens: 20,
      messages: [{ role: 'user', content: `Say "Model ${testModel} works"` }]
    });
    
    res.json({ 
      status: 'ok',
      type: type,
      model: testModel,
      response: response.content[0].text 
    });
  } catch (err) {
    res.status(500).json({ 
      status: 'error',
      model: testModel,
      error: err.message 
    });
  }
});

// Debug: Project trade details
app.get('/api/debug/project/:projectId/trades', async (req, res) => {
  try {
    const { projectId } = req.params;
    
    const trades = await query(
      `SELECT pt.*, t.code, t.name, pt.created_at,
              COUNT(q.question_id) as question_count,
              COUNT(a.question_id) as answer_count
       FROM project_trades pt
       JOIN trades t ON t.id = pt.trade_id
       LEFT JOIN questions q ON q.project_id = pt.project_id AND q.trade_id = pt.trade_id
       LEFT JOIN answers a ON a.project_id = pt.project_id AND a.trade_id = pt.trade_id
       WHERE pt.project_id = $1
       GROUP BY pt.project_id, pt.trade_id, t.id, t.code, t.name, pt.created_at
       ORDER BY pt.created_at`,
      [projectId]
    );
    
    const project = await query(
      'SELECT * FROM projects WHERE id = $1',
      [projectId]
    );
    
    res.json({
      project: project.rows[0],
      complexity: determineProjectComplexity(project.rows[0]),
      tradeCount: trades.rows.length,
      trades: trades.rows.map(t => {
        const intelligentCount = getIntelligentQuestionCount(
          t.code, 
          project.rows[0],
          [] // Keine Intake-Antworten im Debug-Modus
        );
        return {
          ...t,
          targetQuestions: intelligentCount.count,
          informationCompleteness: intelligentCount.completeness,
          missingInfo: intelligentCount.missingInfo,
          completeness: t.question_count > 0 
            ? Math.round((t.answer_count / t.question_count) * 100)
            : 0
        };
      })
    });
    
  } catch (err) {
    console.error('Debug failed:', err);
    res.status(500).json({ error: err.message });
  }
});

// Debug: List all routes
app.get('/api/debug/routes', (req, res) => {
  const routes = [];
  app._router.stack.forEach(middleware => {
    if (middleware.route) {
      const methods = Object.keys(middleware.route.methods);
      routes.push({
        path: middleware.route.path,
        methods: methods.map(m => m.toUpperCase())
      });
    }
  });
  res.json({ routes });
});

// Health check
app.get('/healthz', (req, res) => {
  res.json({ 
    message: "BYNDL Backend v4.0", 
    status: "running",
    features: {
      intelligentQuestions: true,
      adaptiveQuestionCount: true,
      detailedMeasurements: true,
      realisticPricing: true,
      uncertaintyHandling: true,
      dataValidation: true
    },
    tradeComplexity: Object.keys(TRADE_COMPLEXITY).length + ' trades configured'
  });
});

// Environment info
app.get('/__info', (req, res) => {
  res.json({
    node: process.version,
    version: "4.0",
    env: {
      OPENAI_MODEL: MODEL_OPENAI,
      ANTHROPIC_QUESTIONS: MODEL_ANTHROPIC_QUESTIONS,  // NEU
      ANTHROPIC_LV: MODEL_ANTHROPIC_LV,  // NEU
      DATABASE_URL: process.env.DATABASE_URL ? "✔️ gesetzt" : "❌ fehlt",
      JWT_SECRET: process.env.JWT_SECRET ? "✔️ gesetzt" : "❌ fehlt"
    },
    limits: {
      detect: "3000 tokens",
      questions: "10000 tokens",
      lv: "16000 tokens",
      intake: "8000 tokens",
      validation: "3000 tokens"
    },
    features: {
      tradeBasedQuestions: "8-40 Fragen je nach Gewerk",
      measurementFocus: "Explizite Mengenerfassung",
      uncertaintyHandling: "Intelligente Schätzungen",
      dataQuality: "Tracking von Datenquellen",
      realisticPricing: "Marktpreise 2024/2025"
    }
  });
});

// 404 handler
app.use((req, res) => {
  res.status(404).json({ 
    error: 'Route not found',
    path: req.path,
    method: req.method
  });
});

// Error handler
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ 
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? err.message : undefined
  });
});

// ===========================================================================
// SERVER START
// ===========================================================================

const PORT = process.env.PORT || 3001;
app.listen(PORT, () => {
  console.log(`
╔════════════════════════════════════════╗
║                                        ║
║     BYNDL Backend v4.0                 ║
║     Intelligente LV-Erstellung         ║
║                                        ║
║     Port: ${PORT}                        ║
║     Environment: ${process.env.NODE_ENV || 'development'}          ║
║                                        ║
║     Features:                          ║
║     ✓ Adaptive Fragenanzahl           ║
║       (8-40 Fragen je nach Gewerk)    ║
║     ✓ Detaillierte Mengenerfassung    ║
║     ✓ Laienverständliche Fragen       ║
║     ✓ Intelligente Schätzlogik        ║
║     ✓ Realistische Preiskalkulation   ║
║     ✓ Datenqualitäts-Tracking         ║
║                                        ║
║     Gewerke-Komplexität:               ║
║     • Sehr hoch: DACH, ELEKT, SAN     ║
║     • Hoch: TIS, FEN, FASS            ║
║     • Mittel: FLI, ESTR, TRO          ║
║     • Einfach: MAL, GER, ABBR         ║
║                                        ║
╚════════════════════════════════════════╝
    `);
});
